<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ„¤æ€’çš„å†¯æ™¨ç¬‘</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%);
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background-color: rgba(255,255,255,0.2);
            border-radius: 15px;
            border: 8px solid #4a2c12;
        }
        .game-header h1 {
            font-size: 48px;
            margin: 0;
            color: #f8a51b;
            text-shadow: 3px 3px 0 #8B4513, 6px 6px 0 rgba(0,0,0,0.2);
            letter-spacing: 2px;
        }
        .game-header {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        .game-header h1 {
            font-size: 48px;
            margin: 0;
            color: #f8a51b;
        }
        .score {
            position: absolute;
            top: 100px;
            left: 20px;
            font-size: 24px;
            color: white;
            background-color: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            margin: 0 15px;
            cursor: pointer;
            background: linear-gradient(to bottom, #f8a51b 0%, #e67e22 100%);
            border: none;
            border-radius: 30px;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>æ„¤æ€’çš„å†¯æ™¨ç¬‘</h1>
        <div class="score">åˆ†æ•°: <span id="score">0</span> | å…³å¡: <span id="levelDisplay">1</span>Â·<span id="levelNameDisplay">ç²¾å‡†å…¥é—¨</span> | å‰©ä½™å­å¼¹: <span id="remainingBirds">5</span>/<span id="totalBirds">5</span> | é£: <span id="windDisplay">0</span> | æ—¶é—´: <span id="timeLeft">--</span>s | å€ç‡: <span id="comboDisplay">1.00x</span> | é“å…·: <span id="powerupsDisplay">æ— </span> | æ¯æ—¥: <span id="dailyFlag">å…³</span></div>
    </div>
            
    <!-- å…³å¡é€‰æ‹©ç•Œé¢ -->
    <div id="levelSelection" style="text-align: center; padding-top: 50px;">
        <h2>é€‰æ‹©å…³å¡</h2>
        <div class="level-buttons">
            <!-- ç”Ÿæˆ5ä¸ªå…³å¡æŒ‰é’® -->
            <button class="level-btn" data-level="1">ç¬¬1å…³Â·ç²¾å‡†å…¥é—¨</button>
            <button class="level-btn locked" data-level="2" disabled>ç¬¬2å…³Â·é£æ´è¯•ç‚¼</button>
            <button class="level-btn locked" data-level="3" disabled>ç¬¬3å…³Â·ä¼ é€å·¥å‚</button>
            <button class="level-btn locked" data-level="4" disabled>ç¬¬4å…³Â·ç¬ç§»Boss</button>
            <button class="level-btn locked" data-level="5" disabled>ç¬¬5å…³Â·è·¯å¾„è°œé¢˜</button>
        </div>
        <div style="margin-top:20px;">
            <button id="dailyChallengeBtn">æ¯æ—¥æŒ‘æˆ˜</button>
            <canvas id="windPreview" width="120" height="24" style="margin-left:8px;vertical-align:middle;cursor:pointer;"></canvas>
            <div id="dailyPreview" style="margin-top:10px;color:#fff;"></div>
            <canvas id="routePreview" width="360" height="120" style="margin-top:10px;display:block;cursor:pointer;"></canvas>
            <canvas id="materialLegend" width="240" height="24" style="margin-top:8px;display:block;cursor:pointer;"></canvas>
        </div>
    </div>
    
    <canvas id="gameCanvas" style="display:none;"></canvas>
    <div class="controls">
        <button id="startBtn" style="display:none;">å¼€å§‹æ¸¸æˆ</button>
        <button id="restartBtn" style="display:none;">é‡æ–°å¼€å§‹</button>
        <button id="pauseBtn" style="display:none;">æš‚åœ</button>
        <button id="settingsBtn" style="display:none;">è®¾ç½®</button>
        <button id="statsBtn" style="display:none;">ç»Ÿè®¡</button>
        <button id="skillsBtn" style="display:none;">æŠ€èƒ½è¯´æ˜</button>
    </div>
    <button id="skipReplayBtn" style="display:none; position:fixed; top:12px; right:12px; z-index:1100;">è·³è¿‡å›æ”¾</button>
    <button id="muteBtn" style="position:fixed; top:12px; right:60px; z-index:1100;">ğŸ”Š</button>
    <div id="overlay" class="overlay" style="display:none;">
        <div class="overlay-content">
            <h2 id="overlayTitle"></h2>
            <p>åˆ†æ•°: <span id="overlayScore">0</span></p>
            <div id="overlayStars" style="font-size:24px;color:#f8a51b;">â˜†â˜†â˜†</div>
            <p>æœ€ä½³è¿å‡»å€ç‡: <span id="overlayBestCombo">1</span>x</p>
            <p>æœ€é«˜å•æ¬¡å¾—åˆ†: <span id="overlayBestHit">0</span></p>
            <p>æ€»æ˜Ÿæ•°: <span id="overlayTotalStars">0</span></p>
            <p id="overlayReason"></p>
            <p id="overlayPrecisionBonus"></p>
            <p id="overlayTargetSummary"></p>
            <p id="overlayTargetsDetail"></p>
            <p>å‘½ä¸­ç‡: <span id="overlayHitRate">0%</span> | å¹³å‡å¾—åˆ†/å‘å°„: <span id="overlayAvgScore">0</span> | ç›®æ ‡å®Œæˆæ•ˆç‡: <span id="overlayEff">0%</span> | çˆ†ç‚¸: <span id="overlayExplosions">0</span></p>
            <p>èƒ½åŠ›ä½¿ç”¨: <span id="overlayAbilities">--</span></p>
            <p>æˆå°±: <span id="overlayAchievements">--</span></p>
            <div class="overlay-actions">
                <button id="nextLevelBtn">ä¸‹ä¸€å…³</button>
                <button id="restartLevelBtn">é‡ç©æœ¬å…³</button>
                <button id="backToSelectBtn">è¿”å›å…³å¡</button>
                <button id="watchReplayBtn" style="display:none;">è§‚çœ‹å›æ”¾</button>
            </div>
        </div>
    </div>
    <div id="settingsPanel" class="overlay" style="display:none;">
        <div class="overlay-content" style="min-width:320px;text-align:left;">
            <h3 style="text-align:center;">æ¸¸æˆè®¾ç½®</h3>
            <label style="display:block;margin:8px 0;"><input type="checkbox" id="settingDaily"> æ¯æ—¥æ¨¡å¼</label>
            <label style="display:block;margin:8px 0;"><input type="checkbox" id="settingPrecision"> ç²¾å‡†æ¨¡å¼</label>
            <label style="display:block;margin:8px 0;"><input type="checkbox" id="settingTrajectory"> æ˜¾ç¤ºè½¨è¿¹</label>
            <label style="display:block;margin:8px 0;"><input type="checkbox" id="settingBgm"> èƒŒæ™¯éŸ³ä¹</label>
            <div style="margin:8px 0;">
                <label>éŸ³ä¹éŸ³é‡</label>
                <input type="range" id="settingBgmVolume" min="0" max="1" step="0.01" style="width:100%;">
                <div style="font-size:12px;color:#555;">éŸ³é‡: <span id="settingBgmVolumeLabel">0.12</span></div>
            </div>
            <div style="margin:8px 0;">
                <label>é£åŠ›é”å®š <input type="checkbox" id="settingWindLock"></label>
                <input type="range" id="settingWindValue" min="-0.05" max="0.05" step="0.001" style="width:100%;">
                <div style="font-size:12px;color:#555;">å½“å‰é£: <span id="settingWindValueLabel">0</span></div>
            </div>
            <div style="margin:8px 0;">
                <label>é•œå¤´ç¼©æ”¾</label>
                <input type="range" id="settingCameraScale" min="0.80" max="1.20" step="0.01" style="width:100%;">
                <div style="font-size:12px;color:#555;">ç¼©æ”¾: <span id="settingCameraScaleLabel">1.00</span>x</div>
            </div>
            <div style="text-align:center;margin-top:12px;">
                <button id="settingsCloseBtn">å…³é—­</button>
            </div>
        </div>
    </div>
    <div id="statsPanel" class="overlay" style="display:none;">
        <div class="overlay-content" style="min-width:360px;text-align:left;">
            <h3 style="text-align:center;">ç»Ÿè®¡ä¸æˆå°±</h3>
            <div>å‘å°„æ¬¡æ•°: <span id="statsShots">0</span></div>
            <div>å‘½ä¸­æ¬¡æ•°: <span id="statsHits">0</span></div>
            <div>å‘½ä¸­ç‡: <span id="statsHitRate">0%</span></div>
            <div>å¹³å‡å¾—åˆ†/å‘å°„: <span id="statsAvgScore">0</span></div>
            <div>ç›®æ ‡å®Œæˆ: <span id="statsTargetsEff">0/0 (0%)</span></div>
            <div>èƒ½åŠ›ä½¿ç”¨: <span id="statsAbilitiesList">--</span></div>
            <div>çˆ†ç‚¸æ¬¡æ•°: <span id="statsExplosions">0</span></div>
            <div>æœ€ä½³è¿å‡»: <span id="statsBestCombo">1.00x</span></div>
            <div style="margin-top:8px;">æˆå°±: <span id="statsAchievementsList">--</span></div>
            <div style="text-align:center;margin-top:12px;">
                <button id="statsCloseBtn">å…³é—­</button>
            </div>
        </div>
    </div>
    <div id="skillsPanel" class="overlay" style="display:none;">
        <div class="overlay-content" style="min-width:360px;text-align:left;">
            <h3 style="text-align:center;">å¼¹è¯æŠ€èƒ½è¯´æ˜</h3>
            <div id="skillsList" style="font-size:14px;line-height:1.6;">--</div>
            <div style="text-align:center;margin-top:12px;">
                <button id="skillsCloseBtn">å…³é—­</button>
            </div>
        </div>
    </div>
    
    <style>
        .level-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            max-width: 800px;
            margin: 30px auto;
        }
        .level-btn {
            padding: 15px;
            font-size: 18px;
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .level-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .level-btn:disabled {
            background: linear-gradient(to bottom, #9E9E9E, #616161);
            cursor: not-allowed;
        }
        .level-btn.locked::after {
            content: 'ğŸ”’';
            margin-left: 5px;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .overlay-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
            min-width: 280px;
        }
        .overlay-actions button {
            margin: 0 8px;
        }
        </style>

        <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const statsBtn = document.getElementById('statsBtn');
        const skillsBtn = document.getElementById('skillsBtn');

        // è®¾ç½®ç”»å¸ƒå¤§å°ä¸ºçª—å£å¤§å°
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.touchAction = 'none';

        // åŠ è½½äººç‰©å¤´åƒå›¾ç‰‡
        const ASSET_BASE = 'assets/';
        const headImage = new Image();
        headImage.src = ASSET_BASE + 'head.jpg';
        let imageLoaded = false;
        
        headImage.onload = function() {
            imageLoaded = true;
            console.log('å¤´åƒå›¾ç‰‡åŠ è½½æˆåŠŸ');
        };
        
        headImage.onerror = function() {
            console.log('å¤´åƒå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å°é¸Ÿ');
            imageLoaded = false;
        };

        // åŠ è½½å°çŒªå¤´åƒå›¾ç‰‡
        const pigImage = new Image();
        pigImage.src = ASSET_BASE + 'pig.png';
        let pigImageLoaded = false;
        
        pigImage.onload = function() {
            pigImageLoaded = true;
            console.log('çŒªå¤´åƒå›¾ç‰‡åŠ è½½æˆåŠŸ');
        };
        
        pigImage.onerror = function() {
            console.log('çŒªå¤´åƒå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤çŒª');
            pigImageLoaded = false;
        };

        const bossImage = new Image();
        bossImage.src = ASSET_BASE + 'boss1.png';
        let bossImageLoaded = false;
        bossImage.onload = function() { bossImageLoaded = true; };
        bossImage.onerror = function() { bossImageLoaded = false; };

        const boss2Image = new Image();
        boss2Image.src = ASSET_BASE + 'boss2.png';
        let boss2ImageLoaded = false;
        boss2Image.onload = function() { boss2ImageLoaded = true; };
        boss2Image.onerror = function() { boss2ImageLoaded = false; };

        const boss3Image = new Image();
        boss3Image.src = ASSET_BASE + 'boss3.png';
        let boss3ImageLoaded = false;
        boss3Image.onload = function() { boss3ImageLoaded = true; };
        boss3Image.onerror = function() { boss3ImageLoaded = false; };



        // æ¸¸æˆå‚æ•°
        const gravity = 0.24;
        let score = 0;
        let gameRunning = false;
        let birds = [];
        let blocks = [];
        let pigs = [];
        let slingshot = {};
        let draggedBird = null;
        let mouse = { x: 0, y: 0 };
        let gameLoop;
        let animationId;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        let loopLastTime = 0;
        let replayLastTime = 0;
        let currentLevel = 1;
        let maxUnlockedLevel = parseInt(localStorage.getItem('maxUnlockedLevel')) || 1;
        let totalBirds = 5; // æ¯å…³æ€»å…±5å‘å­å¼¹
        let remainingBirds = 5; // å‰©ä½™å­å¼¹æ•°
        let birdQueue = [];
        let nextBirdIndex = 0;
        let activeBird = null;
        let windX = 0;
        let lastLaunchTime = 0;
        let spawnNextBirdTimer = null;
        let explosions = [];
        let eggs = [];
        let windTunnels = [];
        let bouncers = [];
        let windTargetX = 0;
        let windChangeTimer = 0;
        let bulletTimeFrames = 0;
        let comboMultiplier = 1;
        let comboTimer = 0;
        let bestCombo = 1;
        let highestSingleHit = 0;
        let shakeFrames = 0;
        let flashFrames = 0;
        let flashColor = '#FFF';
        let flashWorldX = null;
        let flashWorldY = null;
        let lensFrames = 0;
        let lensColor = '#FFF';
        let lensWorldX = null;
        let lensWorldY = null;
        let slingJitterFrames = 0;
        let shakeIntensity = 2;
        let shakeKick = 0;
        let rotorBars = [];
        let safeZones = [];
        let pickups = [];
        let floatScores = [];
        let summonLabels = [];
        let riftLabels = [];
        let dailyMode = false;
        let totalStars = parseInt(localStorage.getItem('totalStars')) || 0;
        let precisionMode = false;
        let precisionFail = false;
        let targetsTotal = 0;
        let targetsDestroyed = 0;
        let precisionBonusAccum = 0;
        let targetLabelCounter = 0;
        let completedTargets = [];
        let cameraScale = 1;
        let windRandomOffset = 0;
        let windRandomTimer = 0;

        function uiSize(n) { const s = cameraScale || 1; return n / s; }
        let ringTheme = null;
        let cameraX = 0, cameraY = 0;
        let lastDrawShakeX = 0, lastDrawShakeY = 0;
        let bossUi = { displayFrac: 1, flash: 0, pulse: 0 };
        let victoryFrames = 0;
        let bossDeathFx = null;
        let timeSlowFrames = 0;
        let lastBossAlive = false;
        let bossLastPos = null;
        let bossFinale = null;
        let bossFinaleBurst = null;
        let bossFinaleCollapse = null;
        let frameCounter = 0;
        let bossDamageLock = 0;
        let targetCameraX = 0, targetCameraY = 0, targetCameraScale = 1;
        let cameraUserFrames = 0;
        let introFocusFrames = 0;
        let introHintFrames = 0;
        let supportPauseFrames = 0;
        let timeLeft = 0;
        let portals = [];
        let wheels = [];
        let particles = [];
        let bossShockwaves = [];
        let bossTrails = [];
        let shadowRifts = [];
        let MAX_PARTICLES = 450;
        let spawnBudget = 0;
        const FX_OVERDRIVE = true;
        const FX_BOOST = 2.2;
        let fxQ = 1;
        let fxBoost = 1;
        let fxHeavy = true;
        function updateFxDyn(){
            const q = getFxQuality();
            fxQ = q;
            fxBoost = FX_OVERDRIVE ? (FX_BOOST * q) : q;
            fxHeavy = q >= 0.75;
        }
        function rayIntersectAABB(px, py, ang, left, right, top, bottom) {
            const dx = Math.cos(ang), dy = Math.sin(ang);
            let best = Infinity;
            if (Math.abs(dx) > 1e-6) {
                const tv1 = (left - px) / dx;
                const yv1 = py + tv1 * dy;
                if (tv1 > 0 && yv1 >= top && yv1 <= bottom) best = Math.min(best, tv1);
                const tv2 = (right - px) / dx;
                const yv2 = py + tv2 * dy;
                if (tv2 > 0 && yv2 >= top && yv2 <= bottom) best = Math.min(best, tv2);
            }
            if (Math.abs(dy) > 1e-6) {
                const th1 = (top - py) / dy;
                const xh1 = px + th1 * dx;
                if (th1 > 0 && xh1 >= left && xh1 <= right) best = Math.min(best, th1);
                const th2 = (bottom - py) / dy;
                const xh2 = px + th2 * dx;
                if (th2 > 0 && xh2 >= left && xh2 <= right) best = Math.min(best, th2);
            }
            return (best === Infinity) ? null : best;
        }
        let hitPauseFrames = 0;
        let impactRings = [];
        let introInkRings = [];
        let inkDissolve = null;
        let audioCtx = null;
        let bgmEl = null;
        let bgm = { activeFile: false, currentName: null };
        let weather = null;
        let weatherDrops = [];
        let weatherSnow = [];
        let fogAlpha = 0;
        let structureChangedFrames = 0;
        let settings = (() => { try { return JSON.parse(localStorage.getItem('gameSettings')||'{}'); } catch(e) { return {}; } })();
        const skillDescriptions = { red:'åŸºç¡€ï¼šæ— æŠ€èƒ½', blue:'åˆ†è£‚', yellow:'åŠ é€Ÿè´¯ç©¿', black:'çˆ†ç‚¸', white:'ä¸‹è›‹', orange:'è†¨èƒ€å…‰ç¯', green:'æ—‹è½¬åè¿½è¸ªï¼šéšæœºå¤„å†³2åªï¼ŒBosså…ç–«ï¼Œå…¨ç¨‹æ— æ•Œ' };
        const typeNames = { red:'çº¢', blue:'è“', yellow:'é»„', black:'é»‘', white:'ç™½', orange:'æ©™', green:'ç»¿' };
        if (settings.showTrajectory === undefined) settings.showTrajectory = true;
        if (settings.windLock === undefined) settings.windLock = false;
        if (settings.windValue === undefined) settings.windValue = 0;
        if (settings.cameraScale === undefined) settings.cameraScale = null;
        if (settings.bgmEnabled === undefined) settings.bgmEnabled = true;
        if (settings.bgmVolume === undefined) settings.bgmVolume = 0.12;
        if (settings.muted === undefined) settings.muted = false;
        function saveSettings(){ localStorage.setItem('gameSettings', JSON.stringify(settings)); }
        function safeVolume(){ let v = (typeof settings.bgmVolume==='number')?settings.bgmVolume:0.12; if (!isFinite(v)||v<0) v=0.12; if (v>1) v=1; if (settings.muted) v=0; return v; }
        function startBGM(){ if (bgm.activeFile) return; if (settings.bgmEnabled===false) return; if (!bgmEl) { bgmEl = new Audio(); bgmEl.loop = true; } const url = (ASSET_BASE + 'bgm.m4a'); if (bgmEl.src !== url) bgmEl.src = url; bgmEl.volume = safeVolume(); const p = bgmEl.play(); if (p && typeof p.then==='function') { p.then(()=>{ bgm.activeFile=true; bgm.currentName='bgm.m4a'; }).catch(()=>{}); } else { bgm.activeFile=true; bgm.currentName='bgm.m4a'; } }
        function switchBGMTo(name){ if (settings.bgmEnabled===false) return; if (bgm.currentName===name) return; if (!bgmEl) { bgmEl = new Audio(); bgmEl.loop = true; } const url = (ASSET_BASE + name); bgmEl.src = url; bgmEl.volume = safeVolume(); const p = bgmEl.play(); if (p && typeof p.then==='function') { p.then(()=>{ bgm.activeFile=true; bgm.currentName=name; }).catch(()=>{}); } else { bgm.activeFile=true; bgm.currentName=name; } }
        function setBGMVolume(v){ settings.bgmVolume = v; if (bgmEl) bgmEl.volume = safeVolume(); }
        let recordReplay = false;
        let replayFrames = [];
        let replayMode = false;
        let replayIndex = 0;
        let replayAniId = null;
        let levelHasPigObjective = false;
        let levelHasTargetObjective = false;
        let levelHasEscortObjective = false;
        let stats = { shotsFired: 0, shotsHit: 0, explosions: 0, abilities: {} };
        let perf = { lastFrameTime: 0, fps: 60, inputEventTime: 0, inputLatencyMs: 0, frameTimes: [], droppedFrames: 0 };
        function getFxQuality(){
            const f = (perf && typeof perf.fps === 'number') ? perf.fps : 60;
            if (f >= 55) return 1;
            if (f >= 45) return 0.75;
            if (f >= 35) return 0.55;
            if (f >= 25) return 0.4;
            if (f >= 18) return 0.25;
            return 0.18;
        }
        let bossIntroFrames = 0;
        let bossIntroInfo = null;
        let bossIntroPlayed = false;
        let bossBridgeFrames = 0;
        let bossBridgeTarget = null;
        let bossSpawnPortal = null;
        let bossPending = null;
        let portalSparkPhase = 0;
        function inputLocked(){ return (bossIntroFrames > 0) || (bossBridgeFrames > 0) || (!!bossSpawnPortal && !bossSpawnPortal.done); }
        function canDragDuringLock(){
            if (!(bossIntroFrames > 0 || bossBridgeFrames > 0 || (bossSpawnPortal && !bossSpawnPortal.done))) return false;
            return birds.some(b=>!b.launched && b.inSlingshot);
        }

        function drawBossBlackFX(pig){
            const t = Date.now();
            const ph = t/800;
            const r = pig.radius*1.6;
            const boost = 1 + Math.min(0.3, (bossUi.pulse||0)*0.02);
            const qFx = fxQ;
            
            ctx.save();
            
            // 1. éœ¸æ°”é»‘æ´æ ¸å¿ƒ (Pulse Core) - çº¯é»‘å‹æŠ‘é£æ ¼
            const pulse = Math.sin(t/150) * 5;
            const coreR = r * 1.6 + pulse;
            
            // æ ¸å¿ƒå…‰æ™• - æ·±æ¸Šé»‘ä¸è‹ç™½å…‰æ™•
            const gCore = ctx.createRadialGradient(pig.x, pig.y, r*0.5, pig.x, pig.y, coreR*1.8);
            gCore.addColorStop(0, 'rgba(0,0,0,1)');
            gCore.addColorStop(0.4, 'rgba(10,10,10,0.95)');
            gCore.addColorStop(0.7, 'rgba(50,50,50,0.5)');
            gCore.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gCore;
            ctx.beginPath(); ctx.arc(pig.x, pig.y, coreR*1.8, 0, Math.PI*2); ctx.fill();

            // æ ¸å¿ƒæ•…éšœæ•ˆæœ (Glitch Effect) - é»‘ç™½å™ªç‚¹
            if (Math.random() < 0.25 * qFx) {
                ctx.save();
                ctx.translate((Math.random()-0.5)*15, (Math.random()-0.5)*15);
                ctx.globalCompositeOperation = 'difference';
                ctx.fillStyle = Math.random() < 0.5 ? 'rgba(255,255,255,0.8)' : 'rgba(0,0,0,0.8)';
                ctx.beginPath(); ctx.arc(pig.x, pig.y, coreR*0.95, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }

            // 2. ä¸‰é‡ç¬¦æ–‡é˜µåˆ— (Triple Rune Rings) - è‹ç™½ç¬¦æ–‡
            const runeStr = 'áš áš¢áš¦áš¨áš±áš²áš·áš¹ášºáš¾á›á›ƒá›‡á›’á›–á›—á›š';
            const layers = qFx >= 0.7 ? 3 : (qFx >= 0.5 ? 2 : 1);
            for(let L=0; L<layers; L++) {
                const dir = L%2===0 ? 1 : -1;
                const speed = (0.6 + L*0.4) * dir; 
                const count = Math.max(8, Math.floor((12 + L*6) * qFx));
                const rad = r * (1.8 + L*0.65);
                const angBase = ph * speed;
                
                ctx.save();
                ctx.translate(pig.x, pig.y);
                ctx.rotate(angBase);
                // è‹ç™½è‰²ï¼Œéšå±‚æ•°å˜æš—
                const val = 200 - L*40;
                ctx.fillStyle = `rgba(${val}, ${val}, ${val}, ${0.9 - L*0.1})`;
                ctx.font = `bold ${Math.round(uiSize(14 + (2-L)*2))}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // å¶å°”é—ªçƒé»‘è‰²å…‰æ™•
                if(Math.random() < 0.05) { ctx.shadowBlur = 10; ctx.shadowColor = '#000'; }

                for(let i=0; i<count; i++){
                    const a = i * (Math.PI*2/count);
                    const x = Math.cos(a) * rad;
                    const y = Math.sin(a) * rad;
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(a + Math.PI/2);
                    ctx.fillText(runeStr[(i+L)%runeStr.length], 0, 0);
                    ctx.restore();
                }
                // ç¯çº¿ - æ·±ç°
                ctx.strokeStyle = `rgba(100,100,100,${0.5 - L*0.1})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(0, 0, rad, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            }

            if (qFx >= 0.55) {
                const neonR = r * (2.25 + 0.25 * boost);
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                const a0 = 0.22 * (0.55 + 0.45 * qFx);
                ctx.globalAlpha = a0;
                const gN = ctx.createRadialGradient(pig.x, pig.y, neonR*0.55, pig.x, pig.y, neonR);
                gN.addColorStop(0, 'rgba(0,0,0,0)');
                gN.addColorStop(0.35, 'rgba(0,255,255,0.55)');
                gN.addColorStop(0.65, 'rgba(255,0,180,0.45)');
                gN.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.strokeStyle = gN;
                ctx.lineWidth = uiSize(6 + 10 * qFx);
                ctx.shadowBlur = uiSize(18 + 26 * qFx);
                ctx.shadowColor = 'rgba(0,255,255,0.75)';
                ctx.beginPath();
                ctx.arc(pig.x, pig.y, neonR, 0, Math.PI*2);
                ctx.stroke();
                ctx.shadowColor = 'rgba(255,0,180,0.65)';
                ctx.globalAlpha = a0 * 0.75;
                ctx.beginPath();
                ctx.arc(pig.x, pig.y, neonR * 0.82, 0, Math.PI*2);
                ctx.stroke();
                ctx.restore();
            }

            // 3. è™šç©ºé—ªç”µé“¾ (Void Lightning Chains) - é»‘ç™½é—ªç”µ
            const chainCount = 6;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            for(let i=0; i<chainCount; i++) {
                if (Math.random() > 0.8) continue;
                const ang = (t/1000) + i*(Math.PI*2/chainCount) + Math.sin(t/150 + i)*1.2;
                const dist = r * (2.8 + Math.sin(t/200 + i)*0.8);
                
                const ex = pig.x + Math.cos(ang) * dist;
                const ey = pig.y + Math.sin(ang) * dist;
                
                // å¤–å‘å…‰ - é»‘è‰²å…‰æ™•
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(0,0,0,1)';
                ctx.strokeStyle = 'rgba(0,0,0,1)'; // é»‘èŠ¯
                ctx.lineWidth = uiSize(4 + Math.random()*3);
                
                ctx.beginPath();
                ctx.moveTo(pig.x, pig.y);
                let cx = pig.x, cy = pig.y;
                const segs = 10;
                for(let j=0; j<segs; j++) {
                    const tSeg = (j+1)/segs;
                    const tx = pig.x + (ex - pig.x) * tSeg;
                    const ty = pig.y + (ey - pig.y) * tSeg;
                    const jitter = (Math.random()-0.5) * 35; 
                    cx = tx + Math.cos(ang + Math.PI/2)*jitter;
                    cy = ty + Math.sin(ang + Math.PI/2)*jitter;
                    ctx.lineTo(cx, cy);
                }
                ctx.stroke();
                
                // å åŠ ä¸€å±‚ç™½è‰²ç»†çº¿å¢åŠ é«˜äº®æ„Ÿï¼Œå½¢æˆé»‘ç™½å¼ºå¯¹æ¯”
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.stroke();

                ctx.shadowBlur = 0;
                
                // é—ªç”µæœ«ç«¯çš„ç«èŠ± - ç™½è‰²
                ctx.fillStyle = 'rgba(255,255,255,1)';
                ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill();
            }

            // 4. æ—‹è½¬é»‘åˆƒ (Rotating Dark Blades) ä¸ é—ªç”µç¬¼ (Lightning Cage)
            const blades = 6;
            const bladeR = r * 2.8;
            const bladePoints = []; // å­˜å‚¨åˆ€é”‹ä½ç½®ç”¨äºè¿æ¥é—ªç”µ
            
            ctx.save();
            ctx.translate(pig.x, pig.y);
            const rotAng = -ph * 3.0; // æé€Ÿæ—‹è½¬
            ctx.rotate(rotAng); 
            
            for(let i=0; i<blades; i++){
                const a = i * (Math.PI*2/blades);
                ctx.save();
                ctx.rotate(a);
                ctx.translate(bladeR, 0);
                
                // è®°å½•ä¸–ç•Œåæ ‡å¤§æ¦‚ä½ç½® (è¿™é‡Œåªè®°å½•ç›¸å¯¹æ—‹è½¬åçš„ï¼Œå®é™…è¿çº¿æ¯”è¾ƒéº»çƒ¦ï¼Œç®€åŒ–ä¸ºåœ¨æ—‹è½¬åæ ‡ç³»å†…è¿çº¿)
                // å®é™…ä¸Šåœ¨æ—‹è½¬åæ ‡ç³»å†…è¿çº¿å³å¯
                
                // åˆ€é”‹å½¢çŠ¶
                ctx.fillStyle = 'rgba(0,0,0,0.95)';
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(50,50,50,0.8)'; // æ·±ç°é˜´å½±
                ctx.beginPath();
                ctx.moveTo(-12, -12);
                ctx.lineTo(70, 0); // æ›´é•¿æ›´å°–
                ctx.lineTo(-12, 12);
                ctx.quadraticCurveTo(-6, 0, -12, -12);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // åˆ€é”‹ä¸Šçš„ç¬¦æ–‡
                ctx.fillStyle = 'rgba(200,200,200,0.6)'; // è‹ç™½ç¬¦æ–‡
                ctx.font = '12px serif';
                ctx.fillText('âš¡', 20, 4);
                
                ctx.restore();
                
                // å­˜å‚¨ç›¸å¯¹åæ ‡ç”¨äºè¿çº¿
                bladePoints.push({
                    x: Math.cos(a) * bladeR,
                    y: Math.sin(a) * bladeR
                });
            }
            
            // é—ªç”µç¬¼ï¼šè¿æ¥ç›¸é‚»åˆ€é”‹
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(100,100,100,0.6)'; // ç°è‰²é—ªç”µ
            ctx.lineWidth = 2;
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#fff'; // ç™½è‰²å…‰æ™•
            
            for(let i=0; i<blades; i++){
                const p1 = bladePoints[i];
                const p2 = bladePoints[(i+1)%blades];
                
                if(Math.random() < 0.3) { // éšæœºé—ªç”µè¿æ¥
                    ctx.moveTo(p1.x, p1.y);
                    // æŠ–åŠ¨è¿çº¿
                    const midX = (p1.x+p2.x)/2 + (Math.random()-0.5)*20;
                    const midY = (p1.y+p2.y)/2 + (Math.random()-0.5)*20;
                    ctx.quadraticCurveTo(midX, midY, p2.x, p2.y);
                }
            }
            ctx.stroke();
            ctx.restore();

            // 6. äº”æ¯’æŠ¤ç›¾ (Five Poisons Shield) - é‡åˆ¶ï¼šç½ªä¸šå…‰è½® & å¿ƒé­”ä½è¯­ (Sin Halo & Whispering Demons)
            // æ ¸å¿ƒæ€è·¯ï¼šä¸å†æ˜¯å›´ç»•ç‰©ä½“è½¬åœˆï¼Œè€Œæ˜¯ä½œä¸ºèƒŒæ™¯çš„å‹è¿«æ„Ÿå…‰è½® + éšæœºé—ªç°çš„ç²¾ç¥æ±¡æŸ“æ–‡å­—
            
            const shieldR = r * 2.8; // æ›´å¤§çš„å…‰è½®
            
            // 1. ç½ªä¸šå…‰è½® (Sin Halo) - ä½äºBossèƒŒåçš„å·¨å¤§æ³•é˜µ
            ctx.save();
            ctx.translate(pig.x, pig.y);
            // æå…¶ç¼“æ…¢çš„æ—‹è½¬ï¼Œæ˜¾å¾—åº„ä¸¥æ²‰é‡
            ctx.rotate(t / 2000);
            
            // å…‰è½®ä¸»ä½“ - é»‘è‰²ä¸è§„åˆ™åˆºç¯
            ctx.beginPath();
            const spikeCount = 16;
            for(let i=0; i<=spikeCount; i++) {
                const ang = i * (Math.PI*2/spikeCount);
                // å°–åˆºé•¿åº¦å‘¼å¸å˜åŒ–
                const breath = Math.sin(t/500 + i)*0.1;
                const rad = shieldR * (0.85 + (i%2)*0.2 + breath); 
                const x = Math.cos(ang) * rad;
                const y = Math.sin(ang) * rad;
                if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                
                // å°–åˆºä¹‹é—´çš„å†…å‡¹å¼§çº¿
                if (i < spikeCount) {
                    const nextAng = (i+1) * (Math.PI*2/spikeCount);
                    const midAng = (ang + nextAng) / 2;
                    const midR = shieldR * 0.55;
                    const nextRad = shieldR * (0.85 + ((i+1)%2)*0.2 + Math.sin(t/500 + i+1)*0.1);
                    ctx.quadraticCurveTo(Math.cos(midAng)*midR, Math.sin(midAng)*midR, Math.cos(nextAng)*nextRad, Math.sin(nextAng)*nextRad);
                }
            }
            ctx.closePath();
            
            // å¡«å……ï¼šæ·±æ¸Šé»‘
            ctx.fillStyle = 'rgba(5, 5, 5, 0.95)';
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#000'; // Pure Black Shadow
            ctx.fill();
            
            // æè¾¹ï¼šé”åˆ©çš„é»‘è‰²
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // å…‰è½®å†…éƒ¨çš„ç¬¦æ–‡ç¯ - é™æ€æˆ–åå‘æ—‹è½¬
            ctx.beginPath();
            ctx.arc(0, 0, shieldR * 0.45, 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(80, 80, 80, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 15]); // ç¨€ç–çš„è™šçº¿
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();

            // 2. å¿ƒé­”ä½è¯­ (Whispering Demons) - éšæœºæµ®ç°çš„æ–‡å­—
            // è´ªã€å—”ã€ç—´ã€æ…¢ã€ç–‘
            const poisons = [
                { color: '#3e2723', label: 'è´ª' }, // Dark Brown
                { color: '#b71c1c', label: 'å—”' }, // Dark Red
                { color: '#263238', label: 'ç—´' }, // Dark Grey
                { color: '#000000', label: 'æ…¢' }, // Black (Was Purple)
                { color: '#1b5e20', label: 'ç–‘' }  // Dark Green
            ];
            
            // æ¯éš”ä¸€æ®µæ—¶é—´ç”Ÿæˆä¸€ä¸ªæ–°çš„å¿ƒé­”æ–‡å­—ç²’å­
            // å­˜å‚¨åœ¨ pig å¯¹è±¡ä¸Š
            if (!pig.demonWhispers) pig.demonWhispers = [];
            
            // åªæœ‰åœ¨æ´»ç€çš„æ—¶å€™ç”Ÿæˆ
            if (pig.health > 0 && Math.random() < 0.06) { 
                const pType = poisons[Math.floor(Math.random() * poisons.length)];
                // éšæœºä½ç½®ï¼Œä¸é™äºåœ†å‘¨
                const angle = Math.random() * Math.PI * 2;
                const distance = r * (1.2 + Math.random() * 1.5);
                pig.demonWhispers.push({
                    x: pig.x + Math.cos(angle) * distance,
                    y: pig.y + Math.sin(angle) * distance,
                    label: pType.label,
                    color: pType.color,
                    life: 1.0,
                    maxLife: 1.0,
                    scale: 0.2,
                    // ç¼“æ…¢å‘ä¸Šé£˜åŠ¨
                    vx: (Math.random()-0.5)*1.5,
                    vy: -0.5 - Math.random(),
                    // éšæœºæ•…éšœåç§»
                    glitch: Math.random() < 0.3
                });
            }
            
            // æ›´æ–°å’Œç»˜åˆ¶å¿ƒé­”æ–‡å­—
            pig.demonWhispers = pig.demonWhispers.filter(p => p.life > 0);
            pig.demonWhispers.forEach(p => {
                p.life -= 0.015;
                p.x += p.vx;
                p.y += p.vy;
                // å‡ºç°æ—¶å˜å¤§ï¼Œæ¶ˆå¤±æ—¶å˜æ·¡
                if (p.life > 0.8) p.scale += 0.05;
                
                ctx.save();
                ctx.translate(p.x, p.y);
                
                // æ•…éšœæŠ–åŠ¨
                if (p.glitch && Math.random() < 0.2) {
                    ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);
                }
                
                ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
                
                // æ–‡å­—æ•ˆæœï¼šå·¨å¤§ã€æ¨¡ç³Šã€å‹æŠ‘
                const fontSize = uiSize(30 * p.scale);
                ctx.font = `bold ${fontSize}px "KaiTi", "æ¥·ä½“", serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // é˜´å½±
                ctx.shadowBlur = 10;
                ctx.shadowColor = p.color;
                ctx.fillStyle = '#000'; // çº¯é»‘æ–‡å­—
                ctx.fillText(p.label, 0, 0);
                
                // æè¾¹ - è‹ç™½
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeText(p.label, 0, 0);
                
                ctx.restore();
            });
            
            // 3. èº«ä¸Šæ•£å‘çš„é»‘æ°” (Dark Aura)
            // ç®€å•çš„å‘ä¸Šé£˜åŠ¨çš„çº¿æ¡
             if (Math.random() < 0.3) {
                const auraX = pig.x + (Math.random()-0.5) * r * 1.5;
                const auraY = pig.y + (Math.random()-0.5) * r;
                ctx.beginPath();
                ctx.moveTo(auraX, auraY);
                ctx.quadraticCurveTo(auraX + (Math.random()-0.5)*20, auraY - 40, auraX, auraY - 80);
                ctx.strokeStyle = `rgba(0,0,0,${Math.random()*0.3})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawBossDeathInk(pig){
            const t = Date.now();
            const r = pig.radius * 3.0; 
            const k = pig.deathFrames ? Math.max(0, Math.min(1, pig.deathFrames/120)) : 1; 
            const prog = 1 - k; // 0(åˆšæ­») -> 1(æ¶ˆå¤±)
            
            ctx.save();
            
            // 1. ç°å®å´©å (Reality Collapse) - å±å¹•æ•…éšœä¸å‹é»‘
            // ä¸å†æ˜¯ç®€å•çš„æ¸å˜ï¼Œè€Œæ˜¯å……æ»¡å™ªç‚¹çš„é»‘æš—
            const gVignette = ctx.createRadialGradient(pig.x, pig.y, r*0.2, pig.x, pig.y, Math.max(canvas.width, canvas.height));
            gVignette.addColorStop(0, `rgba(0,0,0,${0.4 + 0.6*prog})`);
            gVignette.addColorStop(0.6, 'rgba(0,0,0,0.95)'); 
            gVignette.addColorStop(1, 'rgba(0,0,0,1)');
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // è¦†ç›–å…¨å±
            ctx.fillStyle = gVignette;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // å…¨å±æ•…éšœçº¿æ¡ (Glitch Lines) - æ¨¡æ‹Ÿæ˜¾åƒç®¡æ•…éšœ
            if (Math.random() < 0.4 * prog) {
                const y = Math.random() * canvas.height;
                const h = Math.random() * 20 + 5;
                ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.8)';
                ctx.fillRect(0, y, canvas.width, h);
                // é”™ä½
                ctx.drawImage(canvas, 0, y, canvas.width, h, (Math.random()-0.5)*20, y, canvas.width, h);
            }
            ctx.restore();

            // 2. ç»æœ›ä¹‹æ¡ (Grasp of Despair) - Bossæœ¬ä½“å¼‚å˜
            // Bosså˜æˆé«˜å¯¹æ¯”åº¦çš„å‰ªå½±ï¼Œç„¶ååƒä¿¡å·ä¸¢å¤±ä¸€æ ·è§£ä½“
            
            if (prog < 0.7) {
                // é˜¶æ®µ1ï¼šé»‘åŒ–å‰ªå½± (Silhouette)
                const shake = 5 * prog;
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
                
                // ç»˜åˆ¶é»‘è‰²å‰ªå½±
                ctx.beginPath();
                ctx.arc(pig.x, pig.y, pig.radius * (1 + prog), 0, Math.PI*2);
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 20 + 50*prog;
                ctx.shadowColor = '#fff'; // å¼ºçƒˆçš„ç™½è‰²èƒŒå…‰
                ctx.fill();
                
                // å†…éƒ¨çš„ç™½è‰²å™ªç‚¹
                ctx.fillStyle = '#fff';
                for(let i=0; i<10; i++) {
                    if(Math.random() < 0.3) {
                        const noiseR = Math.random() * pig.radius;
                        const noiseA = Math.random() * Math.PI * 2;
                        ctx.fillRect(pig.x + Math.cos(noiseA)*noiseR, pig.y + Math.sin(noiseA)*noiseR, 2, 2);
                    }
                }
            } else {
                // é˜¶æ®µ2ï¼šä¿¡å·ä¸¢å¤± (Signal Lost) - æ–¹å—è§£ä½“
                const particles = 50;
                ctx.fillStyle = '#000';
                for(let i=0; i<particles; i++) {
                    // ç²’å­å‘ä¸Šé£˜æ•£ï¼Œåƒç°çƒ¬
                    const spread = r * 1.5;
                    const px = pig.x + (Math.random()-0.5) * spread;
                    const py = pig.y + (Math.random()-0.5) * spread - (prog-0.7)*200;
                    const size = Math.random() * 15 * (1-prog);
                    
                    ctx.fillRect(px, py, size, size);
                    // ç™½è‰²æè¾¹å¢åŠ å¯¹æ¯”
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(px, py, size, size);
                }
            }
            
            // 3. è§†è§‰æ®‹ç•™ (Visual Echo) - å¶å°”çš„åè‰²é—ªçƒ
            if (Math.random() < 0.15 * prog) {
                ctx.globalCompositeOperation = 'difference';
                ctx.fillStyle = '#fff';
                ctx.fillRect(pig.x - r, pig.y - r, r*2, r*2);
            }

            ctx.restore();
        }

        function drawBossFinale(cx, cy, alpha){
            const a = Math.max(0, Math.min(1, alpha));
            const t = Date.now();
            
            // æ›¿æ¢ä¸ºï¼šç ´ç¢è™šç©º (Shattered Void)
            // å±å¹•ä»¿ä½›è£‚å¼€ï¼Œéœ²å‡ºèƒŒåçš„è™šæ— 
            
            ctx.save();
            ctx.globalAlpha = a;
            
            // 1. å·¨å¤§çš„é»‘è‰²è£‚ç¼ (Abyssal Cracks) - ä»ä¸­å¿ƒå‘å¤–è¾å°„
            ctx.strokeStyle = 'rgba(0,0,0,0.95)';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const crackCount = 8;
            for(let i=0; i<crackCount; i++) {
                const baseAng = i * (Math.PI*2/crackCount);
                const seed = Math.floor(t/10000) + i; // éšæ—¶é—´æ…¢é€Ÿå˜åŒ–
                
                ctx.lineWidth = uiSize(6 + Math.sin(t/200 + i)*2);
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                
                let currX = cx;
                let currY = cy;
                let currDist = 0;
                let currAng = baseAng;
                
                // ç”Ÿæˆé—ªç”µçŠ¶è£‚çº¹
                while(currDist < Math.max(canvas.width, canvas.height)) {
                    const step = 30 + Math.random() * 50;
                    currDist += step;
                    // è§’åº¦éšæœºåè½¬
                    currAng += (Math.random() - 0.5) * 0.8;
                    currX += Math.cos(currAng) * step;
                    currY += Math.sin(currAng) * step;
                    ctx.lineTo(currX, currY);
                }
                ctx.stroke();
                
                // è£‚ç¼è¾¹ç¼˜çš„ç™½è‰²é«˜å…‰
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
            
            // 2. æ‚¬æµ®çš„é•œé¢ç¢ç‰‡ (Floating Shards) - åªæœ‰é»‘ç™½
            const shardCount = 15;
            for(let i=0; i<shardCount; i++) {
                // èºæ—‹åˆ†å¸ƒ
                const r = 150 + (i * 40 + t/3) % 600;
                const ang = i * 2.4 + t/1000; 
                const x = cx + Math.cos(ang) * r;
                const y = cy + Math.sin(ang) * r;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(ang + t/400); // è‡ªè½¬
                
                // ç»˜åˆ¶å°–é”ç¢ç‰‡
                ctx.beginPath();
                ctx.moveTo(-15, -25);
                ctx.lineTo(20, -5);
                ctx.lineTo(5, 25);
                ctx.lineTo(-20, 10);
                ctx.closePath();
                
                // ç¢ç‰‡æ˜¯é»‘è‰²çš„ï¼Œå¸¦ç™½è¾¹
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#fff';
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.restore();
            }
            
            // 3. ä¸­å¿ƒçš„è™šç©ºå¥‡ç‚¹ (Singularity)
            ctx.beginPath();
            ctx.arc(cx, cy, 80 + Math.sin(t/100)*10, 0, Math.PI*2);
            ctx.fillStyle = '#000';
            ctx.shadowBlur = 50;
            ctx.shadowColor = '#fff'; // å¼ºçƒˆçš„å¯¹æ¯”
            ctx.fill();
            
            ctx.restore();
        }

        function drawBossFinaleBurst(cx, cy, alpha){
            const a = Math.max(0, Math.min(1, alpha));
            const t = Date.now();
            ctx.save();
            
            // 1. ç¬é—´åè‰²å†²å‡» (Inverted Flash)
            if (a > 0.8) {
                ctx.globalCompositeOperation = 'difference';
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // 2. æ¢å¤æ­£å¸¸æ··åˆï¼Œç»˜åˆ¶å†²å‡»æ³¢
            ctx.globalCompositeOperation = 'source-over';
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(canvas.width, canvas.height));
            g.addColorStop(0, `rgba(0,0,0,${0.9*a})`);
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, Math.max(canvas.width, canvas.height), 0, Math.PI*2); ctx.fill();
            
            // 3. å†²å‡»æ³¢çº¹ - æç®€çš„é»‘ç™½åœˆ
            ctx.lineWidth = uiSize(20);
            ctx.strokeStyle = `rgba(0,0,0,${a})`;
            const r = (1-a) * 1000; // æ‰©æ•£
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI*2);
            ctx.stroke();
            
            // 4. é”™ä½æ–‡å­— "FATAL ERROR"
            if (Math.random() < 0.5) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(2, 2);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const txt = "FATAL ERROR";
                const offset = (Math.random()-0.5)*10;
                ctx.fillText(txt, offset, 0);
                ctx.restore();
            }

            ctx.restore();
        }

        function drawBossFinaleCollapse(cx, cy, alpha){
            const a = Math.max(0, Math.min(1, alpha));
            const t = Date.now();
            const k = bossFinaleCollapse && bossFinaleCollapse.frames ? bossFinaleCollapse.frames/30 : 0;
            ctx.save();
            const g = ctx.createRadialGradient(cx, cy, 40*k, cx, cy, Math.max(canvas.width, canvas.height));
            g.addColorStop(0, `rgba(0,0,0,${0.98*a})`);
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, Math.max(canvas.width, canvas.height), 0, Math.PI*2); ctx.fill();
            
            ctx.globalCompositeOperation = 'source-over';
            
            ctx.lineWidth = uiSize(8);
            for (let i=0;i<18;i++){
                const ang = t/540 + i*(Math.PI*2/18);
                const rad = 220 + i*22 - k*40;
                ctx.globalAlpha = 0.92*a;
                
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.beginPath(); ctx.arc(cx, cy, rad, ang, ang + 1.2); ctx.stroke();
                
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(cx, cy, rad, ang, ang + 1.2); ctx.stroke();
                ctx.lineWidth = uiSize(8);
            }
            
            ctx.globalAlpha = 0.9*a;
            ctx.lineWidth = uiSize(6);
            for (let i=0;i<28;i++){
                const ang = i*(Math.PI*2/28) + t/720;
                const len = 380 - k*120;
                const x2 = cx + Math.cos(ang) * len;
                const y2 = cy + Math.sin(ang) * len;
                
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(x2, y2); ctx.stroke();
                
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(x2, y2); ctx.stroke();
                ctx.lineWidth = uiSize(6);
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }

        const levelThemes = {
            1: { name: 'ç²¾å‡†å…¥é—¨', sky: '#70c5ce', ground: '#90EE90' },
            2: { name: 'é£æ´è¯•ç‚¼', sky: '#8ecae6', ground: '#99d98c' },
            3: { name: 'ä¼ é€å·¥å‚', sky: '#bde0fe', ground: '#c5e1a5' },
            4: { name: 'ç¬ç§»Boss', sky: '#a5b4fc', ground: '#a5d6a7' },
            5: { name: 'è·¯å¾„è°œé¢˜', sky: '#cfd8dc', ground: '#b2dfdb' }
        };
        function getLevelThemeColors(lvl){ const t = levelThemes[lvl] || levelThemes[1]; return { sky: t.sky, ground: t.ground }; }
        
        // å…³å¡è®¾è®¡ - å¡”çŠ¶æœ¨æ¿ç»“æ„
        const levels = [
            // ç¬¬1å…³ - ç®€å•å¡”çŠ¶ç»“æ„
            {
                blocks: [
                    // åº•åº§
                    {x: canvas.width - 300, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 1, fallen: false, rotation: 0},
                    {x: canvas.width - 280, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 1, fallen: false, rotation: 0},
                    {x: canvas.width - 260, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 1, fallen: false, rotation: 0},
                    // æ¨ªæ¢
                    {x: canvas.width - 280, y: canvas.height - 120, width: 60, height: 15, color: '#A0522D', health: 1, fallen: false, rotation: 0, target: true},
                    // ä¿æŠ¤æ 
                    {x: canvas.width - 280, y: canvas.height - 150, width: 80, height: 10, color: '#795548', health: 1, fallen: false, rotation: 0, material: 'fence'},
                    // é¡¶éƒ¨
                    {x: canvas.width - 280, y: canvas.height - 160, width: 15, height: 40, color: '#8B4513', health: 1, fallen: false, rotation: 0}
                ],
                pigs: [
                    {x: canvas.width - 280, y: canvas.height - 140, radius: 20, color: 'green', health: 1, crushed: false}
                ],
                birds: 5,
                precision: true
            },
            // ç¬¬2å…³ - åŒå±‚å¡”çŠ¶ç»“æ„ï¼ˆåŠ å¼ºï¼‰
            {
                blocks: [
                    // ç¬¬ä¸€å±‚åº•åº§
                    {x: canvas.width - 320, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 300, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 280, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 260, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 240, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    // ç¬¬ä¸€å±‚æ¨ªæ¢
                    {x: canvas.width - 280, y: canvas.height - 120, width: 100, height: 15, color: '#9E9E9E', health: 2, fallen: false, rotation: 0, material: 'metal'},
                    // ç¬¬äºŒå±‚åº•åº§
                    {x: canvas.width - 300, y: canvas.height - 160, width: 15, height: 60, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 280, y: canvas.height - 160, width: 15, height: 60, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 260, y: canvas.height - 160, width: 15, height: 60, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    // ç¬¬äºŒå±‚æ¨ªæ¢
                    {x: canvas.width - 280, y: canvas.height - 200, width: 60, height: 15, color: '#BDE1FF', health: 1, fallen: false, rotation: 0, material: 'glass', target: true},
                    {x: canvas.width - 250, y: canvas.height - 180, width: 12, height: 90, color: '#795548', health: 2, fallen: false, rotation: -0.4, material: 'fence'},
                    {x: canvas.width - 310, y: canvas.height - 180, width: 12, height: 90, color: '#795548', health: 2, fallen: false, rotation: 0.4, material: 'fence'}
                ],
                pigs: [
                    {x: canvas.width - 280, y: canvas.height - 180, radius: 20, color: 'green', health: 2, crushed: false},
                    {x: canvas.width - 280, y: canvas.height - 140, radius: 20, color: 'green', health: 2, crushed: false}
                ],
                birds: 5
            },
            // ç¬¬3å…³ - å¤æ‚å¡”çŠ¶ç»“æ„ï¼ˆåŠ å¼ºï¼‰
            {
                blocks: [
                    // åº•å±‚æ”¯æ’‘
                    {x: canvas.width - 340, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 300, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 260, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 220, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    // åº•å±‚æ¨ªæ¢
                    {x: canvas.width - 280, y: canvas.height - 120, width: 140, height: 15, color: '#A0522D', health: 1, fallen: false, rotation: 0, material: 'ice'},
                    // ä¸­å±‚æ”¯æ’‘
                    {x: canvas.width - 300, y: canvas.height - 160, width: 15, height: 60, color: '#8B4513', health: 1, fallen: false, rotation: 0},
                    {x: canvas.width - 260, y: canvas.height - 160, width: 15, height: 60, color: '#8B4513', health: 1, fallen: false, rotation: 0},
                    // ä¸­å±‚æ¨ªæ¢
                    {x: canvas.width - 280, y: canvas.height - 200, width: 80, height: 15, color: '#A0522D', health: 1, fallen: false, rotation: 0, material: 'rubber'},
                    // é¡¶å±‚
                    {x: canvas.width - 280, y: canvas.height - 240, width: 15, height: 40, color: '#8B4513', health: 2, fallen: false, rotation: 0, material: 'flammable', target: true},
                    // å€¾æ–œæ …æ åˆ¶é€ æ—¶æœºè¦æ±‚
                    {x: canvas.width - 240, y: canvas.height - 190, width: 12, height: 100, color: '#795548', health: 2, fallen: false, rotation: -0.5, material: 'fence'},
                    {x: canvas.width - 320, y: canvas.height - 190, width: 12, height: 100, color: '#795548', health: 2, fallen: false, rotation: 0.5, material: 'fence'}
                ],
                pigs: [
                    {x: canvas.width - 280, y: canvas.height - 220, radius: 20, color: 'green', health: 2, crushed: false},
                    {x: canvas.width - 280, y: canvas.height - 180, radius: 20, color: 'green', health: 2, crushed: false},
                    {x: canvas.width - 280, y: canvas.height - 140, radius: 20, color: 'green', health: 2, crushed: false}
                ],
                birds: 5
            },
            // ç¬¬4å…³ - åšå›ºå¡”çŠ¶ç»“æ„ï¼ˆåŠ å¼ºï¼‰
            {
                blocks: [
                    // åšå›ºåº•åº§
                    {x: canvas.width - 320, y: canvas.height - 80, width: 15, height: 80, color: '#9E9E9E', health: 3, fallen: false, rotation: 0, material: 'metal'},
                    {x: canvas.width - 300, y: canvas.height - 80, width: 15, height: 80, color: '#9E9E9E', health: 3, fallen: false, rotation: 0, material: 'metal'},
                    {x: canvas.width - 280, y: canvas.height - 80, width: 15, height: 80, color: '#9E9E9E', health: 3, fallen: false, rotation: 0, material: 'metal'},
                    {x: canvas.width - 260, y: canvas.height - 80, width: 15, height: 80, color: '#9E9E9E', health: 3, fallen: false, rotation: 0, material: 'metal'},
                    {x: canvas.width - 240, y: canvas.height - 80, width: 15, height: 80, color: '#9E9E9E', health: 3, fallen: false, rotation: 0, material: 'metal'},
                    // åšå›ºæ¨ªæ¢
                    {x: canvas.width - 280, y: canvas.height - 120, width: 100, height: 15, color: '#BDE1FF', health: 1, fallen: false, rotation: 0, material: 'glass'},
                    // ä¸Šå±‚ç»“æ„
                    {x: canvas.width - 280, y: canvas.height - 160, width: 15, height: 60, color: '#B85C00', health: 1, fallen: false, rotation: 0, material: 'barrel'}
                ],
                pigs: [
                    {x: canvas.width - 280, y: canvas.height - 140, radius: 20, color: 'green', health: 2, crushed: false},
                    {x: canvas.width - 280, y: canvas.height - 100, radius: 20, color: 'green', health: 2, crushed: false}
                ],
                birds: 5
            },
            // ç¬¬5å…³ - å¤æ‚å¤šå±‚å¡”çŠ¶ç»“æ„ï¼ˆåŠ å¼ºï¼‰
            {
                blocks: [
                    // åº•å±‚
                    {x: canvas.width - 360, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 320, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 280, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 240, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    {x: canvas.width - 200, y: canvas.height - 80, width: 15, height: 80, color: '#8B4513', health: 2, fallen: false, rotation: 0},
                    // åº•å±‚æ¨ªæ¢
                    {x: canvas.width - 280, y: canvas.height - 120, width: 180, height: 15, color: '#BDE1FF', health: 1, fallen: false, rotation: 0, material: 'glass'},
                    // ä¸­å±‚
                    {x: canvas.width - 300, y: canvas.height - 160, width: 15, height: 60, color: '#B85C00', health: 1, fallen: false, rotation: 0, material: 'barrel'},
                    {x: canvas.width - 260, y: canvas.height - 160, width: 15, height: 60, color: '#8B4513', health: 1, fallen: false, rotation: 0},
                    // ä¸­å±‚æ¨ªæ¢
                    {x: canvas.width - 280, y: canvas.height - 200, width: 80, height: 15, color: '#9E9E9E', health: 1, fallen: false, rotation: 0, material: 'metal'},
                    // é¡¶å±‚
                    {x: canvas.width - 280, y: canvas.height - 240, width: 15, height: 40, color: '#8B4513', health: 1, fallen: false, rotation: 0, target: true},
                    // æ”¯æ’‘æ¢
                    {x: canvas.width - 320, y: canvas.height - 180, width: 15, height: 40, color: '#8B4513', health: 1, fallen: false, rotation: 0},
                    {x: canvas.width - 240, y: canvas.height - 180, width: 15, height: 40, color: '#8B4513', health: 1, fallen: false, rotation: 0}
                    ,{x: canvas.width - 320, y: canvas.height - 260, width: 100, height: 15, color: '#BDE1FF', health: 1, fallen: false, rotation: 0, material: 'glass', target: true}
                    ,{x: canvas.width - 350, y: canvas.height - 140, width: 15, height: 60, color: '#9E9E9E', health: 2, fallen: false, rotation: 0, material: 'metal'}
                    ,{x: canvas.width - 180, y: canvas.height - 160, width: 15, height: 60, color: '#8B4513', health: 1, fallen: false, rotation: 0, material: 'flammable', target: true}
                    ,{x: canvas.width - 180, y: canvas.height - 120, width: 20, height: 20, color: '#B85C00', health: 1, fallen: false, rotation: 0, material: 'barrel'}
                ],
                pigs: [
                    {x: canvas.width - 280, y: canvas.height - 220, radius: 20, color: 'green', health: 2, crushed: false},
                    {x: canvas.width - 280, y: canvas.height - 180, radius: 20, color: 'green', health: 2, crushed: false},
                    {x: canvas.width - 280, y: canvas.height - 140, radius: 20, color: 'green', health: 2, crushed: false}
                ],
                birds: 5
            }
        ];

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame(level = 1) {
            currentLevel = level;
            frameCounter = 0;
            score = 0;
            if (spawnNextBirdTimer) { clearTimeout(spawnNextBirdTimer); spawnNextBirdTimer = null; }
            birds = [];
            activeBird = null;
            draggedBird = null;
            blocks = [];
            pigs = [];
            const levelData = levels[currentLevel - 1];
            totalBirds = levelData.birds;
            remainingBirds = totalBirds;
            birdQueue = getBirdQueueForLevel(currentLevel, totalBirds);
            nextBirdIndex = 0;
            windX = dailyMode ? getDailyWind() : getWindForLevel(currentLevel);
            windTargetX = windX;
            windChangeTimer = 240;
            bulletTimeFrames = 0;
            eggs = [];
            explosions = [];
            particles = [];
            impactRings = [];
            introInkRings = [];
            bossShockwaves = [];
            bossTrails = [];
            summonLabels = [];
            riftLabels = [];
            shadowRifts = [];
            bossUi = { displayFrac: 1, flash: 0, pulse: 0 };
            victoryFrames = 0;
            bossDeathFx = null;
            bossFinale = null;
            bossFinaleBurst = null;
            bossFinaleCollapse = null;
            timeSlowFrames = 0;
            lastBossAlive = false;
            bossLastPos = null;
            bossDamageLock = 0;
            bossIntroFrames = 0;
            bossIntroInfo = null;
            bossBridgeFrames = 0;
            bossBridgeTarget = null;
            portalSparkPhase = 0;
            structureChangedFrames = 0;
            supportPauseFrames = 0;
            shakeFrames = 0;
            flashFrames = 0;
            flashWorldX = null;
            flashWorldY = null;
            slingJitterFrames = 0;
            shakeKick = 0;
            cameraUserFrames = 0;
            perf = { lastFrameTime: 0, fps: 60, inputEventTime: 0, inputLatencyMs: 0, frameTimes: [], droppedFrames: 0 };
            comboMultiplier = 1.3;
            comboTimer = 0;
            bestCombo = 1;
            highestSingleHit = 0;
            timeLeft = getLevelTime(currentLevel);
            slingshot = { x: 200, y: canvas.height - 200, radius: 20 };
            bossSpawnPortal = null;
            bossPending = null;
            try {
                const bossLv = (currentLevel===2 || currentLevel===3 || currentLevel===4);
                const want = bossLv ? 'bgm_boss.ogg' : 'bgm.m4a';
                if (bgm.currentName !== want) switchBGMTo(want);
            } catch(e){}
            createLevel(currentLevel);
            const bossPig = pigs.find(p=>p.isBoss);
            if (bossPig) {
                const profiles = {
                    boss1: { name: 'é˜¿ç‘æ–¯', subtitle: 'æš´åŠ›ä¹‹ç¥', img: bossImage },
                    boss2: { name: 'é˜¿ç‘æ–¯', subtitle: 'æš´åŠ›ä¹‹ç¥', img: boss2Image },
                    boss3: { name: 'é˜¿ç‘æ–¯', subtitle: 'æš´åŠ›ä¹‹ç¥', img: boss3Image }
                };
                let pf = profiles[bossPig.bossType||'boss1'] || profiles.boss1;
                if (currentLevel === 2) { pf = { name: 'æ–½ç»å¯¿', subtitle: 'ç½šæŠ„ä¹‹ç¥', img: bossImage }; }
                else if (currentLevel === 3) { pf = { name: 'å¼ æ¬²ä¸°', subtitle: 'å¾·è‚²ä¹‹ç¥', img: boss2Image }; }
                else if (currentLevel === 4) { pf = { name: 'ææ±Ÿ', subtitle: 'å¤„åˆ†ä¹‹ç¥', img: boss3Image }; }
                bossIntroInfo = { name: pf.name, subtitle: pf.subtitle, img: pf.img };
                bossIntroFrames = 120;
                if (!bossIntroPlayed) { try { playBossIntroSound(1); } catch(e){} bossIntroPlayed = true; }
                shakeFrames = Math.max(shakeFrames, 16);
                bossBridgeTarget = { x: bossPig.x, y: bossPig.y };
            }
            precisionMode = !!levelData.precision;
            if (typeof settings.precisionOverride === 'boolean') precisionMode = settings.precisionOverride;
            precisionFail = false;
            updateThemeFromStars();
            cameraScale = 1;
            cameraX = 0; cameraY = 0; targetCameraX = 0; targetCameraY = 0; targetCameraScale = cameraScale;
            recordReplay = true; replayFrames = []; replayIndex = 0; replayMode = false;
            windTunnels = [];
            bouncers = [];
            portals = [];
            wheels = [];
            rotorBars = [];
            safeZones = [];
            pickups = [];
            floatScores = [];
            stats = { shotsFired: 0, shotsHit: 0, explosions: 0, abilities: {} };
            weather = setWeatherForLevel(currentLevel);
            weatherDrops = [];
            weatherSnow = [];
            fogAlpha = 0;
            switch(currentLevel){
                case 1:
                    break;
                case 2:
                    windTunnels.push({ x: canvas.width - 700, y: canvas.height - 280, w: 240, h: 110, forceX: 0.06, forceY: -0.02 });
                    windTunnels.push({ x: canvas.width - 400, y: canvas.height - 220, w: 200, h: 90, forceX: -0.04, forceY: 0.01 });
                    bouncers.push({ x: slingshot.x + 260, y: canvas.height - 62, w: 160, h: 12 });
                    break;
                case 3:
                    portals.push({ id: 1, twoWay: true, x: canvas.width - 720, y: canvas.height - 260, w: 48, h: 78, exitX: canvas.width - 240, exitY: canvas.height - 280, rotate: 0 });
                    portals.push({ id: 2, twoWay: true, x: canvas.width - 520, y: canvas.height - 190, w: 48, h: 78, exitX: canvas.width - 320, exitY: canvas.height - 240, rotate: 0 });
                    wheels.push({ x: canvas.width - 520, y: canvas.height - 70, r: 30, angle: 0, omega: 0.05 });
                    rotorBars.push({ cx: canvas.width - 460, cy: canvas.height - 150, length: 120, width: 12, angle: 0, omega: 0.04 });
                    bouncers.push({ x: canvas.width - 300, y: canvas.height - 60, w: 120, h: 12 });
                    break;
                case 4:
                    wheels.push({ x: canvas.width - 420, y: canvas.height - 140, r: 26, angle: 0, omega: 0.06 });
                    wheels.push({ x: canvas.width - 380, y: canvas.height - 100, r: 22, angle: 0, omega: 0.07 });
                    rotorBars.push({ cx: canvas.width - 240, cy: canvas.height - 180, length: 110, width: 12, angle: 0, omega: 0.05 });
                    windTunnels.push({ x: canvas.width - 820, y: canvas.height - 300, w: 160, h: 100, forceX: 0.04, forceY: -0.01 });
                    break;
                case 5:
                    portals.push({ id: 3, twoWay: true, x: canvas.width - 860, y: canvas.height - 280, w: 50, h: 80, exitX: canvas.width - 250, exitY: canvas.height - 200, rotate: 0 });
                    portals.push({ id: 4, twoWay: true, x: canvas.width - 600, y: canvas.height - 210, w: 50, h: 70, exitX: canvas.width - 320, exitY: canvas.height - 260, rotate: 0 });
                    portals.push({ id: 5, twoWay: true, x: canvas.width - 720, y: canvas.height - 150, w: 50, h: 70, exitX: canvas.width - 180, exitY: canvas.height - 140, rotate: 0 });
                    safeZones.push({ x: canvas.width - 180, y: canvas.height - 90, w: 160, h: 40 });
                    wheels.push({ x: canvas.width - 350, y: canvas.height - 140, r: 26, angle: 0, omega: 0.06 });
                    bouncers.push({ x: canvas.width - 320, y: canvas.height - 60, w: 110, h: 16 });
                    bouncers.push({ x: canvas.width - 200, y: canvas.height - 60, w: 100, h: 10 });
                    rotorBars.push({ cx: canvas.width - 220, cy: canvas.height - 190, length: 100, width: 12, angle: 0, omega: 0.05 });
                    wheels.push({ x: canvas.width - 420, y: canvas.height - 140, r: 22, angle: 0, omega: 0.06 });
                    wheels.push({ x: canvas.width - 390, y: canvas.height - 110, r: 20, angle: 0, omega: 0.07 });
                    windTunnels.push({ x: canvas.width - 880, y: canvas.height - 300, w: 160, h: 100, forceX: 0.05, forceY: -0.01 });
                    windTunnels.push({ x: canvas.width - 520, y: canvas.height - 220, w: 160, h: 90, forceX: -0.04, forceY: 0 });
                    windTunnels.push({ x: canvas.width - 240, y: canvas.height - 200, w: 140, h: 120, forceX: 0.02, forceY: -0.06 });
                    break;
            }
            levelHasPigObjective = (levelData.pigs && levelData.pigs.length > 0);
            levelHasTargetObjective = targetsTotal > 0;
            levelHasEscortObjective = safeZones.length > 0;
            createBird();
            gameRunning = true;
            updateHUD();
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('levelSelection').style.display = 'none';
            restartBtn.style.display = 'inline-block';
            pauseBtn.style.display = 'inline-block';
            settingsBtn.style.display = 'inline-block';
            statsBtn.style.display = 'inline-block';
            skillsBtn.style.display = 'inline-block';
            if (levelHasPigObjective) {
                introFocusFrames = 90;
                introHintFrames = 180;
            } else if (levelHasTargetObjective) {
                introFocusFrames = 60;
                introHintFrames = 140;
            } else {
                introFocusFrames = 0;
                introHintFrames = 0;
            }
        }

        function getBirdQueueForLevel(level, count) {
            const pools = {
                1: ['red','yellow','blue','red','orange'],
                2: ['yellow','blue','white','red','red'],
                3: ['blue','yellow','red','green','red'],
                4: ['red','yellow','black','blue','white'],
                5: ['blue','yellow','red','orange','green']
            };
            const base = pools[level] || ['red'];
            const arr = [];
            for (let i = 0; i < count; i++) arr.push(base[i % base.length]);
            if (!arr.includes('green') && count > 0) { arr[Math.max(0, count - 1)] = 'green'; }
            return arr;
        }

        function getWindForLevel(level) {
            // Increased wind for higher difficulty as requested
            const winds = { 1: 0.00, 2: 0.09, 3: -0.12, 4: 0.15, 5: -0.18 };
            // Apply dynamic random offset
            return (winds[level] || 0) + (windRandomOffset || 0);
        }

        function seededRandom(seed) {
            let x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function getDailyWind() {
            const daySeed = Math.floor(Date.now() / 86400000);
            const r = seededRandom(daySeed);
            // Boosted daily wind
            return (r * 0.24) - 0.12;
        }

        function getDefaultCameraScale(level) {
            const map = { 1: 1.0, 2: 0.96, 3: 0.94, 4: 0.9, 5: 0.86 };
            return map[level] || 1.0;
        }
        function clampCamera() {
            const s = cameraScale || 1;
            const worldW = canvas.width, worldH = canvas.height;
            const viewportW = worldW / s, viewportH = worldH / s;
            if (viewportW >= worldW) {
                cameraX = (worldW - viewportW) / 2;
            } else {
                cameraX = Math.max(0, Math.min(cameraX, worldW - viewportW));
            }
            if (viewportH >= worldH) {
                cameraY = (worldH - viewportH) / 2;
            } else {
                cameraY = Math.max(0, Math.min(cameraY, worldH - viewportH));
            }
        }

        function updateThemeFromStars() {
            ringTheme = totalStars >= 9 ? 'pixel' : totalStars >= 6 ? 'space' : totalStars >= 3 ? 'festival' : null;
        }

        function getLevelTime(level) {
            const times = { 1: 60, 2: 70, 3: 80, 4: 90, 5: 110 };
            return times[level] || 60;
        }

        function playImpactSound(intensity){
            try { if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){}
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = 220 + 220 * intensity;
            const t0 = audioCtx.currentTime;
            gain.gain.setValueAtTime(0.001, t0);
            gain.gain.linearRampToValueAtTime(0.08, t0 + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.15);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(t0 + 0.18);
        }

        function playImpactSoundMaterial(material, intensity){
            try { if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){}
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            let base = 200 + 280 * intensity;
            let peak = 0.08;
            if (material === 'metal') { osc.type = 'square'; base += 80; peak = 0.09; }
            else if (material === 'glass') { osc.type = 'triangle'; base += 140; peak = 0.07; }
            else if (material === 'rubber') { osc.type = 'sine'; base -= 40; peak = 0.06; }
            else if (material === 'barrel') { osc.type = 'sawtooth'; base += 60; peak = 0.09; }
            else if (material === 'ice') { osc.type = 'triangle'; base += 120; peak = 0.07; }
            else if (material === 'flammable') { osc.type = 'sawtooth'; base += 40; peak = 0.08; }
            else { osc.type = 'sine'; }
            const t0 = audioCtx.currentTime;
            osc.frequency.value = base;
            gain.gain.setValueAtTime(0.001, t0);
            gain.gain.linearRampToValueAtTime(peak, t0 + 0.012);
            gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.16);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(t0 + 0.18);
        }

        function playLaunchSound(intensity){
            try { if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){}
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            const t0 = audioCtx.currentTime;
            osc.frequency.setValueAtTime(340 + 260*intensity, t0);
            osc.frequency.exponentialRampToValueAtTime(180 + 90*intensity, t0 + 0.08);
            gain.gain.setValueAtTime(0.001, t0);
            gain.gain.linearRampToValueAtTime(0.08 + 0.06*intensity, t0 + 0.015);
            gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.14);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(t0 + 0.16);
        }

        function playBossIntroSound(intensity){
            try { if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){}
            if (!audioCtx) return;
            const t0 = audioCtx.currentTime;
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc1.type = 'sine';
            osc2.type = 'sawtooth';
            osc1.frequency.setValueAtTime(120, t0);
            osc1.frequency.exponentialRampToValueAtTime(40, t0 + 0.6);
            osc2.frequency.setValueAtTime(220, t0);
            osc2.frequency.exponentialRampToValueAtTime(90, t0 + 0.4);
            gain.gain.setValueAtTime(0.0001, t0);
            gain.gain.linearRampToValueAtTime(0.22 * intensity, t0 + 0.08);
            gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.8);
            osc1.connect(gain);
            osc2.connect(gain);
            gain.connect(audioCtx.destination);
            osc1.start();
            osc2.start();
            osc1.stop(t0 + 0.9);
            osc2.stop(t0 + 0.7);
        }

        function updateHUD() {
            scoreElement.textContent = score;
            const ld = document.getElementById('levelDisplay');
            if (ld) ld.textContent = currentLevel;
            const lnd = document.getElementById('levelNameDisplay');
            if (lnd) { const t = levelThemes[currentLevel] || levelThemes[1]; lnd.textContent = t.name; }
            const rb = document.getElementById('remainingBirds');
            if (rb) rb.textContent = remainingBirds;
            const tb = document.getElementById('totalBirds');
            if (tb) tb.textContent = totalBirds;
            const wd = document.getElementById('windDisplay');
            if (wd) wd.textContent = windX.toFixed(3);
            const tl = document.getElementById('timeLeft');
            if (tl) tl.textContent = Math.max(0, Math.ceil(timeLeft));
            const cd = document.getElementById('comboDisplay');
            if (cd) cd.textContent = `${comboMultiplier.toFixed(2)}x`;
            const pd = document.getElementById('powerupsDisplay');
            if (pd) {
                const ab = activeBird;
                const tags = [];
                if (ab && ab.shield) tags.push('ç›¾');
                if (ab && ab.blast) tags.push('çˆ†');
                if (ab && ab.magnet) tags.push('ç£');
                pd.textContent = tags.length ? tags.join(',') : 'æ— ';
            }
            const df = document.getElementById('dailyFlag');
            if (df) df.textContent = dailyMode ? 'å¼€' : 'å…³';
            const dp = document.getElementById('dailyPreview');
            if (dp) {
                const w = getDailyWind();
                const tcount = Math.max(1, Math.floor((levels[4]?.blocks?.length || 20) * 0.1));
                dp.textContent = `æ¯æ—¥é£åŠ›: ${w.toFixed(3)} | ä»Šæ—¥ç›®æ ‡æ•°: ${tcount}`;
            }
            drawWindPreview();
            drawMaterialLegend();
        }

        // é¡¶éƒ¨ä¿¡æ¯æ å¯äº¤äº’
        document.getElementById('dailyFlag').style.cursor = 'pointer';
        document.getElementById('dailyFlag').addEventListener('click', () => {
            dailyMode = !dailyMode;
            initGame(currentLevel);
            startLoop();
        });

        function drawRoutePreview() {
            const c = document.getElementById('routePreview');
            if (!c) return;
            const cx = c.getContext('2d');
            cx.clearRect(0,0,c.width,c.height);
            cx.fillStyle = '#e0f7fa';
            cx.fillRect(0,0,c.width,c.height);
            cx.strokeStyle = '#90caf9';
            cx.beginPath();
            cx.moveTo(0,c.height-20); cx.lineTo(c.width,c.height-20); cx.stroke();
            const lanes = [40, 180, 320];
            lanes.forEach((x,i) => {
                cx.fillStyle = '#00bcd4'; cx.fillRect(x-16, 20, 20, 26);
                cx.fillStyle = '#004d40'; cx.font = '10px sans-serif'; cx.fillText(`P${i+2}`, x-12, 32);
            });
            cx.fillStyle = '#7E57C2'; cx.fillRect(30, c.height-32, 60, 6);
            cx.fillRect(170, c.height-26, 80, 10);
            cx.fillRect(310, c.height-34, 70, 14);
            cx.fillStyle = '#CFD8DC';
            cx.beginPath(); cx.arc(120, c.height-30, 10, 0, Math.PI*2); cx.fill();
            cx.beginPath(); cx.arc(140, c.height-48, 8, 0, Math.PI*2); cx.fill();
            cx.beginPath(); cx.arc(260, c.height-38, 9, 0, Math.PI*2); cx.fill();
            cx.strokeStyle = '#1E88E5';
            cx.beginPath(); cx.moveTo(60, 60); cx.lineTo(110, 40); cx.stroke();
            cx.beginPath(); cx.moveTo(200, 50); cx.lineTo(150, 45); cx.stroke();
            cx.beginPath(); cx.moveTo(330, 80); cx.lineTo(330, 40); cx.stroke();
            cx.fillStyle = '#B85C00'; cx.fillRect(330, c.height-50, 14, 14);
            cx.fillStyle = '#f44336'; cx.font = '10px sans-serif'; cx.fillText('æ¡¶', 330, c.height-52);
            cx.fillStyle = '#ffffff'; cx.font = '12px sans-serif';
            cx.fillText('è·¯çº¿A', 20, 14); cx.fillText('è·¯çº¿B', 160, 14); cx.fillText('è·¯çº¿C', 300, 14);

            const lc = ringTheme === 'festival' ? '#ffe4ef' : ringTheme === 'space' ? '#e0f7fa' : ringTheme === 'pixel' ? '#fff8e1' : '#ffffff';
            cx.fillStyle = lc; cx.fillRect(6, c.height-18, 140, 14);
            cx.strokeStyle = '#004d40'; cx.strokeRect(6, c.height-18, 140, 14);
            cx.fillStyle = '#004d40'; cx.font = '10px sans-serif';
            cx.fillText('å›¾ä¾‹: è½®=ç°åœ† å¼¹=ç´«æ¡ é£=è“ç®­ æ¡¶=çº¢æ–¹', 10, c.height-8);
        }

        function drawWindPreview() {
            const c = document.getElementById('windPreview');
            if (!c) return;
            const cx = c.getContext('2d');
            cx.clearRect(0,0,c.width,c.height);
            cx.fillStyle = '#e0f7fa';
            cx.fillRect(0,0,c.width,c.height);
            const w = getDailyWind();
            const len = Math.max(10, Math.min(100, Math.abs(w) * 3000));
            const midY = c.height/2;
            const startX = w >= 0 ? 10 : c.width-10-len;
            const endX = startX + len;
            cx.strokeStyle = '#1E88E5'; cx.lineWidth = 3;
            cx.beginPath(); cx.moveTo(startX, midY); cx.lineTo(endX, midY); cx.stroke();
            const ang = w >= 0 ? 0 : Math.PI;
            cx.fillStyle = '#1E88E5';
            cx.beginPath();
            cx.moveTo(endX, midY);
            cx.lineTo(endX - Math.cos(ang - 0.6) * 8, midY - Math.sin(ang - 0.6) * 8);
            cx.lineTo(endX - Math.cos(ang + 0.6) * 8, midY - Math.sin(ang + 0.6) * 8);
            cx.closePath(); cx.fill();
        }

        function drawMaterialLegend() {
            const c = document.getElementById('materialLegend');
            if (!c) return;
            const cx = c.getContext('2d');
            cx.clearRect(0,0,c.width,c.height);
            const bg = ringTheme === 'festival' ? '#ffe4ef' : ringTheme === 'space' ? '#e0f7fa' : ringTheme === 'pixel' ? '#fff8e1' : '#ffffff';
            cx.fillStyle = bg; cx.fillRect(0,0,c.width,c.height);
            const items = [
                { k:'æœ¨', c:'#A0522D' },
                { k:'ç»', c:'#BDE1FF' },
                { k:'é‡‘', c:'#B0BEC5' },
                { k:'æ©¡', c:'#7E57C2' },
                { k:'æ˜“', c:'#FF8F00' },
                { k:'æ¡¶', c:'#B85C00' },
                { k:'å†°', c:'#90CAF9' }
            ];
            let x = 8; const y = 6;
            cx.font = '12px sans-serif';
            items.forEach(it => {
                cx.fillStyle = it.c; cx.fillRect(x, y, 20, 12);
                cx.strokeStyle = '#004d40'; cx.strokeRect(x, y, 20, 12);
                cx.fillStyle = '#004d40'; cx.fillText(it.k, x+24, y+11);
                x += 56;
            });
        }

        function awardScore(base) {
            const gained = Math.round(base * (comboMultiplier + 0.2));
            score += gained;
            highestSingleHit = Math.max(highestSingleHit, gained);
            comboMultiplier = Math.min(7, comboMultiplier + 0.35);
            comboTimer = 120;
            bestCombo = Math.max(bestCombo, comboMultiplier);
            shakeFrames = 8;
            floatScores.push({ x: slingshot.x + 20, y: slingshot.y - 20, text: `+${gained}`, life: 40 });
            updateHUD();
        }

        function awardTargetBonus(base) {
            const gained = Math.round(base * (comboMultiplier + 0.2));
            precisionBonusAccum += gained;
            score += gained;
            highestSingleHit = Math.max(highestSingleHit, gained);
            comboMultiplier = Math.min(7, comboMultiplier + 0.35);
            comboTimer = 120;
            bestCombo = Math.max(bestCombo, comboMultiplier);
            shakeFrames = 8;
            floatScores.push({ x: slingshot.x + 20, y: slingshot.y - 20, text: `+${gained}`, life: 40 });
            updateHUD();
        }

        function updateBossBehavior(pig) {
            const time = Date.now();
            const qFx = fxQ;
            const heavyFx = qFx >= 0.75;

            // åˆå§‹åŒ–è‡ªå®šä¹‰çŠ¶æ€
            if (!pig.customState) {
                pig.customState = {
                    stormTimer: 0,
                    chargeTimer: 0,
                    isCharging: false
                };
            }
            
            // 1. éšæœºç¯å¢ƒç‰¹æ•ˆï¼šäº”æ¯’æ¯’é›¨ (Five Poisons Rain)
            if (Math.random() < (0.08 + 0.18 * qFx)) { // é¢‘ç‡æå‡
                const ang = Math.random() * Math.PI * 2;
                const dist = pig.radius * (1.5 + Math.random() * 3.0);
                const lx = pig.x + Math.cos(ang) * dist;
                const ly = pig.y + Math.sin(ang) * dist;
                
                // ç”Ÿæˆæ¯’æ¶²æ»´
                spawnParticles(lx, ly, 1, Math.random() < 0.5 ? '#8A2BE2' : '#7FFF00', { 
                    style: 'melt', 
                    r: 4 + Math.random()*4,
                    life: 40 + Math.random()*20,
                    speed: 2 + Math.random()*2,
                    dir: {x: 0, y: 1} // å‘ä¸‹æ»´è½
                });
                // ç§»é™¤éœ‡åŠ¨ä»¥ç¨³å®šè§†è§’ (Removed shake for stable camera)
            }

            // 2. å‘¨æœŸæ€§å¨å‹ï¼šæ¯’æ°”çˆ†å‘ (Toxic Burst)
            if (!pig.lastPulse || time - pig.lastPulse > 1200) { 
                pig.lastPulse = time;
                bossShockwaves.push({ x: pig.x, y: pig.y, r: pig.radius*1.2, alpha: 0.6, thick: 15, growth: 8, color: 'rgba(138,43,226,0.5)' });
                if (heavyFx) bossShockwaves.push({ x: pig.x, y: pig.y, r: pig.radius*1.6, alpha: 0.7, thick: 18, growth: 10, color: 'rgba(0,255,255,0.35)' });
                
                // çˆ†å‘ä¸€åœˆæ¯’åˆº
                const burstCount = 12;
                for(let i=0; i<burstCount; i++){
                    const ang = i*(Math.PI*2/burstCount) + (time/1000);
                    spawnParticles(pig.x, pig.y, 1, '#0f0', {
                        style: 'shard',
                        angle: ang,
                        speed: 6,
                        life: 60,
                        w: 4, h: 12
                    });
                }
            }

            // 3. è“„åŠ›çˆ†å‘æœºåˆ¶ (Venom Nova)
            if (!pig.customState.isCharging) {
                if (Math.random() < (0.003 + 0.007 * qFx)) { // è§¦å‘è“„åŠ›
                    pig.customState.isCharging = true;
                    pig.customState.chargeTimer = time;
                    // æ’­æ”¾éŸ³æ•ˆæˆ–è§†è§‰æç¤º
                    if(typeof screenShake !== 'undefined') screenShake = 5;
                }
            } else {
                // è“„åŠ›ä¸­
                const chargeDuration = 1500;
                const progress = (time - pig.customState.chargeTimer) / chargeDuration;
                
                // å±å¹•å˜è‰²é¢„è­¦
                if (Math.random() < (0.15 + 0.25 * qFx)) {
                    // Add warning tint (implementation dependent on draw loop, but we can spawn particles)
                     const ang = Math.random() * Math.PI * 2;
                     const dist = pig.radius * (3 + Math.random()*2);
                     particles.push({
                        x: pig.x + Math.cos(ang)*dist,
                        y: pig.y + Math.sin(ang)*dist,
                        vx: -Math.cos(ang)*6,
                        vy: -Math.sin(ang)*6,
                        life: 30,
                        color: 'rgba(75,0,130,0.8)',
                        shape: 'streak',
                        len: 25
                     });
                }
                
                if (progress >= 1) {
                    // çˆ†å‘ï¼
                    pig.customState.isCharging = false;
                    shakeFrames = 8; // å†æ¬¡å‡å¼±éœ‡åŠ¨ (Reduced from 15)
                    bossShockwaves.push({ x: pig.x, y: pig.y, r: pig.radius, alpha: 1, thick: 60, growth: 30, color: 'rgba(0,255,0,0.6)' });
                    
                    // å…¨å±æ¯’é›¾
                    const fogN = Math.max(14, Math.round(18 + 42 * qFx));
                    for(let k=0; k<fogN; k++){
                        const tx = Math.random() * canvas.width;
                        const ty = Math.random() * canvas.height;
                        spawnParticles(pig.x, pig.y, 1, Math.random()<0.5?'#8A2BE2':'#7FFF00', {
                            style: 'smoke',
                            life: 100 + Math.random()*50,
                            r: 10 + Math.random()*20,
                            speed: 5 + Math.random()*10,
                            ang: Math.atan2(ty-pig.y, tx-pig.x)
                        });
                    }
                }
            }

            // 4. å‡è§†æ•ˆæœï¼šæ¯’è›‡å‡è§†
            if (activeBird && activeBird.launched && !activeBird.dead) {
                if (Math.random() < (0.18 + 0.30 * qFx)) { 
                    const dx = activeBird.x - pig.x;
                    const dy = activeBird.y - pig.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 1000) {
                        // äº§ç”Ÿè¿æ¥æ¯’ä¸
                        if(Math.random() < (0.10 + 0.18 * qFx)) {
                            spawnParticles(pig.x, pig.y, 1, 'rgba(148,0,211,0.6)', {
                                style: 'streak', // Simplified from void_lightning for performance and style
                                vx: (dx/dist)*15,
                                vy: (dy/dist)*15,
                                life: 20,
                                len: dist/2
                            });
                        }
                    }
                }
            }

            // 5. ä¸‡è›Šèšé›†
            if (Math.random() < (0.10 + 0.22 * qFx)) {
                const ang = Math.random() * Math.PI * 2;
                const r = pig.radius * (2.5 + Math.random());
                const px = pig.x + Math.cos(ang) * r;
                const py = pig.y + Math.sin(ang) * r;
                // å‘å†…å¸å…¥çš„ç²’å­
                const spd = 4 + Math.random()*3;
                particles.push({
                    x: px, y: py,
                    vx: -Math.cos(ang) * spd,
                    vy: -Math.sin(ang) * spd,
                    life: 30,
                    color: Math.random() < 0.5 ? 'rgba(75,0,130,0.9)' : 'rgba(0,255,0,0.9)',
                    shape: 'melt',
                    r: 5 + Math.random()*4,
                    alpha: 0.95,
                    taper: 0.95,
                    decay: 0.02,
                    grav: 0
                });
            }

            if (heavyFx && Math.random() < 0.12) {
                spawnParticles(pig.x, pig.y, 2, 'rgba(80,255,255,0.55)', { style: 'orbit_blade', cx: pig.x, cy: pig.y, rad: pig.radius * (2.6 + Math.random()*1.8), w: 22 + Math.random()*18, slow: true });
                if (Math.random() < 0.45) spawnParticles(pig.x, pig.y, 1, 'rgba(255,0,180,0.45)', { style: 'orbit_blade', cx: pig.x, cy: pig.y, rad: pig.radius * (1.8 + Math.random()*1.4), w: 16 + Math.random()*12, slow: true });
                if (Math.random() < 0.22) spawnParticles(pig.x, pig.y, 1, 'rgba(255,255,255,0.55)', { style: 'eclipse', life: 32, rad: pig.radius*0.9, len: pig.radius*(4.5 + Math.random()*2.5), alpha: 0.55, growth: 7 + Math.random()*4, spikes: 18 });
            }
        }

        function onBossDamaged(pig, amount) {
            bossUi.flash = Math.max(bossUi.flash || 0, 12);
            bossUi.pulse = Math.max(bossUi.pulse || 0, 10);
            if (typeof playBossHitSound === 'function') { try { playBossHitSound(); } catch(e){} }
            
            // å¢å¼ºå—ä¼¤åé¦ˆï¼šé»‘è‰²å†²å‡»æ³¢
            bossShockwaves.push({ x: pig.x, y: pig.y, r: Math.max(10, pig.radius*1.1), alpha: 0.95, thick: 16, growth: 12 });
            if (fxQ >= 0.75) {
                bossShockwaves.push({ x: pig.x, y: pig.y, r: Math.max(60, pig.radius*1.7), alpha: 0.65, thick: 20, growth: 16, color: 'rgba(0,255,255,0.35)' });
                bossShockwaves.push({ x: pig.x, y: pig.y, r: Math.max(90, pig.radius*2.3), alpha: 0.50, thick: 16, growth: 14, color: 'rgba(255,0,180,0.25)' });
            }
            
            // é¢å¤–çš„é»‘è‰²ç²’å­çˆ†å‘
            const pCount = Math.min(14, Math.ceil(amount * (2 + 10 * fxQ)));
            for(let i=0; i<pCount; i++){
                const ang = Math.random() * Math.PI * 2;
                spawnParticles(pig.x, pig.y, 1, 'rgba(0,0,0,0.95)', { style: 'black_flame', ang, len: 28 + Math.random()*22, w: 14 + Math.random()*12, speed: 0.7 + Math.random()*0.6, slow: true });
            }
            if (fxQ >= 0.75) {
                spawnParticles(pig.x, pig.y, 2, 'rgba(80,255,255,0.55)', { style: 'orbit_blade', cx: pig.x, cy: pig.y, rad: pig.radius * (2.3 + Math.random()*1.4), w: 20 + Math.random()*16, slow: true });
                spawnParticles(pig.x, pig.y, 1, 'rgba(255,0,180,0.45)', { style: 'orbit_blade', cx: pig.x, cy: pig.y, rad: pig.radius * (1.6 + Math.random()*1.2), w: 14 + Math.random()*12, slow: true });
            }
            
            // å±å¹•éœ‡åŠ¨ï¼ˆå¦‚æœæœ‰å…¨å±€éœ‡åŠ¨å˜é‡ï¼Œè¿™é‡Œå¯ä»¥å¢åŠ ï¼Œå‡è®¾æœ‰ï¼‰
            if(typeof screenShake !== 'undefined') screenShake += 5;
        }

        function onBossDeath() {
            victoryFrames = Math.max(victoryFrames || 0, 160);
            if (typeof playVictorySound === 'function') { try { playVictorySound(); } catch(e){} }
            const bp = pigs.find(p=>p.isBoss);
            if (bp) {
                shakeFrames = Math.max(shakeFrames || 0, 32);
                spawnBudget += 180;
                introInkRings.push({ x: bp.x, y: bp.y, r: Math.max(100, bp.radius*2.2), maxR: Math.max(canvas.width, canvas.height)*0.65, alpha: 0.95, growth: 5, thickness: 14, flashAlpha: 0, emitInterval: 1, emitCooldown: 0, edgeFreq: 0.22, noiseAmp: 7, phase: 0, phaseSpeed: 0.16 });
                inkDissolve = { x: bp.x, y: bp.y, rad: 0, prevRad: 0, maxR: Math.max(180, bp.radius*4.0), phase: 0, noiseAmp: 7, theta: 0, prog: 0 };
                spawnParticles(bp.x, bp.y, 12, 'rgba(33,33,33,0.95)', { style: 'shard' });
                spawnParticles(bp.x, bp.y, 10, 'rgba(0,0,0,0.9)', { style: 'smoke_ring', cx: bp.x, cy: bp.y, rad: Math.max(200, bp.radius*4.2), slow: true });
                bossShockwaves.push({ x: bp.x, y: bp.y, r: Math.max(60, bp.radius*1.6), alpha: 0.95, thick: 22, growth: 16 });
                bossShockwaves.push({ x: bp.x, y: bp.y, r: Math.max(120, bp.radius*2.2), alpha: 0.75, thick: 16, growth: 14 });
                bossShockwaves.push({ x: bp.x, y: bp.y, r: Math.max(180, bp.radius*2.8), alpha: 0.55, thick: 12, growth: 12 });
                bossDeathFx = { x: bp.x, y: bp.y, frames: 120, flash: 18 };
                bossFinale = { x: bp.x, y: bp.y, frames: 160 };
                timeSlowFrames = 70;
                const baseScale = (settings.cameraScale || getDefaultCameraScale(currentLevel));
                targetCameraScale = Math.min(1.5, baseScale * 1.35);
                const s = targetCameraScale || 1;
                targetCameraX = Math.max(0, bp.x - canvas.width/(2*s));
                targetCameraY = Math.max(0, bp.y - canvas.height/(2*s));
                cameraScale = targetCameraScale; // Instant zoom for dramatic effect
                cameraX = targetCameraX; cameraY = targetCameraY; cameraUserFrames = 90; clampCamera();
                bp.deathFrames = Math.max(bp.deathFrames||0, 90);
                bp.deathStartR = bp.radius;
                bp._removeOnDeath = true;
                try { if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){}
                if (audioCtx) {
                    const t0 = audioCtx.currentTime;
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc1.type = 'sine'; osc2.type = 'square';
                    osc1.frequency.setValueAtTime(180, t0);
                    osc1.frequency.exponentialRampToValueAtTime(40, t0 + 0.6);
                    osc2.frequency.setValueAtTime(90, t0);
                    osc2.frequency.exponentialRampToValueAtTime(30, t0 + 0.5);
                    gain.gain.setValueAtTime(0.0001, t0);
                    gain.gain.linearRampToValueAtTime(0.22, t0 + 0.06);
                    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.7);
                    osc1.connect(gain); osc2.connect(gain); gain.connect(audioCtx.destination);
                    osc1.start(); osc2.start(); osc1.stop(t0 + 0.72); osc2.stop(t0 + 0.6);
                }
            }
        }

        function getMaterialBonus(material, phase, dmg){
            const d = Math.max(0, Math.floor(dmg||0));
            if (phase === 'hit') {
                if (material === 'metal') return Math.min(8, 3 + Math.floor(d*0.5));
                if (material === 'glass') return Math.min(5, 2 + Math.floor(d*0.3));
                if (material === 'flammable') return Math.min(6, 2 + Math.floor(d*0.4));
                if (material === 'ice') return Math.min(4, 1 + Math.floor(d*0.3));
                if (material === 'rubber') return 2;
                if (material === 'barrel') return Math.min(7, 3 + Math.floor(d*0.4));
                return 1;
            } else if (phase === 'break') {
                if (material === 'metal') return 16;
                if (material === 'glass') return 12;
                if (material === 'flammable') return 14;
                if (material === 'ice') return 10;
                if (material === 'rubber') return 8;
                if (material === 'barrel') return 18;
                return 6;
            } else if (phase === 'ignite') {
                return Math.min(10, 4 + Math.floor(d*0.4));
            }
            return 0;
        }

        function setWeatherForLevel(lvl){
            if (lvl === 2) return 'rain';
            if (lvl === 3) return 'snow';
            if (lvl === 4) return 'fog';
            if (lvl === 5) return 'snow_fog';
            return null;
        }

        function spawnParticles(x, y, count, color, opt) {
            const style = opt && opt.style ? opt.style : 'default';
            const dir = opt && opt.dir ? opt.dir : { x: (Math.random()-0.5), y: (Math.random()-0.5) };
            const angOpt = opt && typeof opt.ang === 'number' ? opt.ang : null;
            const cxOpt = opt && typeof opt.cx === 'number' ? opt.cx : null;
            const cyOpt = opt && typeof opt.cy === 'number' ? opt.cy : null;
            const slow = !!(opt && opt.slow);
            const noGrav = !!(opt && opt.nograv);
            const radOpt = opt && typeof opt.rad === 'number' ? opt.rad : null;
            const lenOpt = opt && typeof opt.len === 'number' ? opt.len : null;
            const wOpt = opt && typeof opt.w === 'number' ? opt.w : null;
            const spOpt = opt && typeof opt.speed === 'number' ? opt.speed : null;
            const q = (typeof fxQ === 'number') ? fxQ : 1;
            const isHeavyStyle = (style === 'eclipse' || style === 'orbit_blade' || style === 'lightning' || style === 'void_lightning' || style === 'black_flame' || style === 'dark_tendril' || style === 'shadow_fissure');
            const c0 = Math.max(0, (typeof count === 'number' ? count : 0));
            let c = Math.round(c0 * (0.25 + 0.75 * q));
            if (isHeavyStyle) c = Math.round(c * q);
            if (q < 0.55 && isHeavyStyle && Math.random() > q) return;
            if (c <= 0) return;
            if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
            for (let i = 0; i < c; i++) {
                if (particles.length >= MAX_PARTICLES || spawnBudget <= 0) break;
                if (style === 'streak') {
                    const ang = Math.atan2(dir.y, dir.x) + (Math.random()-0.5) * 0.3;
                    const sp = 3 + Math.random()*2.5;
                    particles.push({ x: x, y: y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, life: 24, color, shape: 'streak', len: 6 + Math.random()*6 }); spawnBudget--;
                } else if (style === 'ring' && false) {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = 2 + Math.random()*2;
                    particles.push({ x: x + Math.cos(ang)*6, y: y + Math.sin(ang)*6, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, life: 26, color, shape: 'ring', r: 3, alpha: 0.9 }); spawnBudget--;
                } else if (style === 'shard') {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = 2 + Math.random()*2.5;
                    particles.push({ x: x + (Math.random()-0.5)*6, y: y + (Math.random()-0.5)*6, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, life: 30, color, shape: 'shard', angle: ang, omega: (Math.random()-0.5)*0.2, w: 6 + Math.random()*4, h: 2 + Math.random()*2 }); spawnBudget--;
                } else if (style === 'smoke') {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = 0.6 + Math.random()*0.6;
                    const rv = -0.8 + Math.random()*0.6;
                    particles.push({ x: x + (Math.random()-0.5)*8, y: y + (Math.random()-0.5)*8, vx: Math.cos(ang)*sp, vy: rv, life: 36 + Math.floor(Math.random()*12), color, shape: 'smoke', r: 6 + Math.random()*6, alpha: 0.8, growth: 0.08 + Math.random()*0.06 }); spawnBudget--;
                } else if (style === 'amaterasu') {
                    const sp = 0.4 + Math.random()*0.5;
                    const rv = -1.0 + Math.random()*0.5;
                    const spikes = (opt && typeof opt.spikes === 'number') ? opt.spikes : (8 + Math.floor(Math.random()*6));
                    const life = (opt && typeof opt.life === 'number') ? opt.life : (40 + Math.floor(Math.random()*14));
                    const r0 = (opt && typeof opt.r0 === 'number') ? opt.r0 : (8 + Math.random()*8);
                    const alpha0 = (opt && typeof opt.alpha === 'number') ? opt.alpha : 0.9;
                    const growth = (opt && typeof opt.growth === 'number') ? opt.growth : (0.14 + Math.random()*0.08);
                    particles.push({ x: x + (Math.random()-0.5)*6, y: y + (Math.random()-0.5)*6, vx: (Math.random()-0.5)*sp, vy: rv, life, color, shape: 'amaterasu', r: r0, alpha: alpha0, growth, rot: Math.random()*Math.PI*2, spikes }); spawnBudget--;
                } else if (style === 'melt') {
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const ox = (Math.random()-0.5) * 4;
                    const vy = slow ? (0.25 + Math.random()*0.35) : (0.7 + Math.random()*0.8);
                    const vx = Math.cos(ang + Math.PI/2) * (slow ? (0.25 + Math.random()*0.25) : (0.5 + Math.random()*0.4)) + ox*0.06;
                    const r = 3 + Math.random()*3;
                    const life = slow ? (72 + Math.floor(Math.random()*24)) : (42 + Math.floor(Math.random()*14));
                    const alpha = slow ? 0.92 : 0.95;
                    const taper = slow ? 0.995 : 0.98;
                    const decay = slow ? 0.008 : 0.02;
                    const grav = slow ? 0.008 : 0.02;
                    particles.push({ x: x + ox, y: y, vx, vy, life, color, shape: 'melt', r, alpha, taper, decay, grav, nog: noGrav }); spawnBudget--;
                } else if (style === 'ember') {
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const sp = slow ? (0.5 + Math.random()*0.4) : (0.8 + Math.random()*0.6);
                    const vx = Math.cos(ang) * sp;
                    const vy = Math.sin(ang) * sp - (slow ? 0.1 : 0.2);
                    const r = 2 + Math.random()*1.5;
                    const life = slow ? (48 + Math.floor(Math.random()*16)) : (30 + Math.floor(Math.random()*12));
                    const alpha = slow ? 0.8 : 0.9;
                    const decay = slow ? 0.012 : 0.02;
                    const rGrow = slow ? 0.012 : 0.02;
                    particles.push({ x: x, y: y, vx, vy, life, color: color || 'rgba(255,215,0,0.9)', shape: 'ember', r, alpha, decay, rGrow, nog: noGrav }); spawnBudget--;
                } else if (style === 'rune') {
                    const str = 'áš áš¢áš¦áš¨áš±áš²áš·áš¹ášºáš¾á›á›ƒá›‡á›’á›–á›—á›š';
                    const ch = str[Math.floor(Math.random()*str.length)] || 'áš ';
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const sp = 0.6 + Math.random()*0.4;
                    const vx = Math.cos(ang) * sp * 0.6;
                    const vy = Math.sin(ang) * sp * 0.6 + 0.05;
                    particles.push({ x, y, vx, vy, life: 34 + Math.floor(Math.random()*12), color: color || 'rgba(180,220,255,0.9)', shape: 'rune', alpha: 0.85, rot: Math.random()*Math.PI*2, omega: (Math.random()-0.5)*0.02, size: 14 + Math.random()*8, ch, nog: noGrav }); spawnBudget--;
                } else if (style === 'black_flame') {
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const len = lenOpt !== null ? lenOpt : (slow ? 42 + Math.random()*16 : 30 + Math.random()*12);
                    const w = wOpt !== null ? wOpt : (slow ? 11 + Math.random()*5 : 9 + Math.random()*4);
                    const spd = spOpt !== null ? spOpt : (slow ? 0.38 + Math.random()*0.18 : 0.55 + Math.random()*0.25);
                    const vx = Math.cos(ang) * spd;
                    const vy = Math.sin(ang) * spd;
                    const alpha0 = slow ? 0.92 : 0.88;
                    const decay = slow ? 0.010 : 0.018;
                    const flicker = 0.10 + Math.random()*0.10;
                    particles.push({ x, y, vx, vy, life: 80 + Math.floor(Math.random()*30), color: color || 'rgba(0,0,0,0.95)', shape: 'black_flame', theta: ang, len, w, alpha: alpha0, decay, nog: true, flicker }); spawnBudget--;
                } else if (style === 'swirl') {
                    const cx = cxOpt !== null ? cxOpt : x;
                    const cy = cyOpt !== null ? cyOpt : y;
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const rad0 = Math.max(8, Math.hypot(x - cx, y - cy));
                    const omega = slow ? (0.04 + Math.random()*0.03) : (0.06 + Math.random()*0.04);
                    const rv = slow ? (0.25 + Math.random()*0.25) : (1.2 + Math.random()*0.8);
                    const life = slow ? (64 + Math.floor(Math.random()*20)) : (46 + Math.floor(Math.random()*14));
                    const alpha = slow ? 0.85 : 0.9;
                    const decay = slow ? 0.010 : 0.02;
                    particles.push({ x, y, cx, cy, life, color: color || 'rgba(120,180,255,0.9)', shape: 'swirl', theta: ang, rad: rad0, radv: rv, alpha, width: 2 + Math.random()*2, decay, omega, nog: noGrav }); spawnBudget--;
                } else if (style === 'smoke_ring' && false) {
                    const cx = cxOpt !== null ? cxOpt : x;
                    const cy = cyOpt !== null ? cyOpt : y;
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const rad0 = radOpt !== null ? radOpt : Math.max(40, Math.hypot(x - cx, y - cy));
                    const life = slow ? (80 + Math.floor(Math.random()*30)) : (50 + Math.floor(Math.random()*20));
                    const alpha = slow ? 0.85 : 0.9;
                    const omega = slow ? 0.03 : 0.05;
                    const r = 6 + Math.random()*4;
                    particles.push({ cx, cy, theta: ang, rad: rad0, omega, life, color: color || 'rgba(0,0,0,0.6)', shape: 'smoke_ring', r, alpha, nog: true }); spawnBudget--;
                } else if (style === 'dark_tendril') {
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const len = lenOpt !== null ? lenOpt : (slow ? 48 + Math.random()*20 : 36 + Math.random()*16);
                    const w = wOpt !== null ? wOpt : (slow ? 14 + Math.random()*6 : 12 + Math.random()*5);
                    const spd = spOpt !== null ? spOpt : (slow ? 0.32 + Math.random()*0.18 : 0.46 + Math.random()*0.24);
                    const vx = Math.cos(ang) * spd * 0.4;
                    const vy = Math.sin(ang) * spd * 0.4;
                    const alpha0 = slow ? 0.88 : 0.84;
                    const decay = slow ? 0.010 : 0.016;
                    const curl = 0.015 + Math.random()*0.015;
                    particles.push({ x, y, vx, vy, life: 90 + Math.floor(Math.random()*30), color: color || 'rgba(0,0,0,0.9)', shape: 'dark_tendril', theta: ang, len, w, alpha: alpha0, decay, curl, nog: true }); spawnBudget--;
                } else if (style === 'shadow_fissure') {
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const len = lenOpt !== null ? lenOpt : (slow ? 60 + Math.random()*24 : 40 + Math.random()*18);
                    const w = wOpt !== null ? wOpt : (slow ? 8 + Math.random()*4 : 7 + Math.random()*3);
                    const vx = Math.cos(ang) * 0.2;
                    const vy = Math.sin(ang) * 0.2;
                    const alpha0 = slow ? 0.9 : 0.85;
                    const decay = slow ? 0.012 : 0.018;
                    const jitter = 0.02 + Math.random()*0.02;
                    particles.push({ x, y, vx, vy, life: 70 + Math.floor(Math.random()*30), color: color || 'rgba(0,0,0,0.9)', shape: 'shadow_fissure', theta: ang, len, w, alpha: alpha0, decay, jitter, nog: true }); spawnBudget--;
                } else if (style === 'orbit_blade') {
                    const cx = cxOpt !== null ? cxOpt : x;
                    const cy = cyOpt !== null ? cyOpt : y;
                    const ang = angOpt !== null ? angOpt : Math.random()*Math.PI*2;
                    const rad0 = radOpt !== null ? radOpt : Math.max(30, Math.hypot(x - cx, y - cy));
                    const omega = 0.02 + Math.random()*0.02;
                    const size = wOpt !== null ? wOpt : (slow ? 18 + Math.random()*10 : 16 + Math.random()*8);
                    const alpha0 = slow ? 0.85 : 0.8;
                    particles.push({ cx, cy, theta: ang, rad: rad0, omega, life: 90 + Math.floor(Math.random()*30), color: color || 'rgba(0,0,0,0.9)', shape: 'orbit_blade', size, alpha: alpha0, nog: true }); spawnBudget--;
                } else if (style === 'eclipse') {
                    const r0 = radOpt !== null ? radOpt : (20 + Math.random()*10);
                    const r1 = r0 + (lenOpt !== null ? lenOpt : (80 + Math.random()*40));
                    const spikes = (opt && typeof opt.spikes === 'number') ? opt.spikes : (14 + Math.floor(Math.random()*6));
                    const growth = (opt && typeof opt.growth === 'number') ? opt.growth : (1.8 + Math.random()*0.8);
                    const life = (opt && typeof opt.life === 'number') ? opt.life : (70 + Math.floor(Math.random()*30));
                    const alpha0 = (opt && typeof opt.alpha === 'number') ? opt.alpha : 0.95;
                    particles.push({ x, y, life, color: color || 'rgba(0,0,0,0.95)', shape: 'eclipse', r0, r1, alpha: alpha0, growth, rot: Math.random()*Math.PI*2, spikes }); spawnBudget--;
                } else if (style === 'fachao_text') {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = (spOpt || 1) * (0.5 + Math.random()*0.5);
                    particles.push({ 
                        x: x, y: y, 
                        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp - 1.5, 
                        life: opt.life || 60, 
                        color: color || '#fff', 
                        shape: 'fachao_text', 
                        text: opt.text || 'ç½šæŠ„',
                        alpha: 1,
                        nograv: true
                    }); 
                    spawnBudget--;
                } else if (style === 'lightning') {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = 1 + Math.random()*2;
                    particles.push({ 
                        x: x + (Math.random()-0.5)*10, y: y + (Math.random()-0.5)*10, 
                        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, 
                        life: 20 + Math.random()*15, 
                        color: color || '#FFEB3B', 
                        shape: 'lightning_bolt', 
                        segments: 3 + Math.floor(Math.random()*3),
                        len: 10 + Math.random()*10,
                        width: 2 + Math.random()*2
                    }); spawnBudget--;
                } else if (style === 'feather') {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = 0.5 + Math.random()*1.5;
                    particles.push({ 
                        x: x, y: y, 
                        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp * 0.5 + 0.5, // Tend to fall
                        life: 60 + Math.random()*30, 
                        color: color || 'rgba(255,255,255,0.9)', 
                        shape: 'feather', 
                        angle: Math.random()*Math.PI*2,
                        vang: (Math.random()-0.5)*0.1,
                        size: 8 + Math.random()*6
                    }); spawnBudget--;
                } else if (style === 'matrix') {
                    particles.push({ 
                        x: x, y: y, 
                        vx: 0, vy: 0, 
                        life: 30 + Math.random()*15, 
                        color: color || '#00FF00', 
                        shape: 'matrix_char', 
                        char: String.fromCharCode(0x30A0 + Math.random()*96), // Katakana
                        size: 10 + Math.random()*6
                    }); spawnBudget--;
                } else if (style === 'spark') {
                     const ang = Math.random() * Math.PI * 2;
                     const sp = 2 + Math.random()*4;
                     particles.push({
                         x: x, y: y,
                         vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp,
                         life: 30 + Math.random()*20,
                         color: color || '#FF5722',
                         shape: 'spark',
                         len: 5 + Math.random()*10
                     }); spawnBudget--;
                } else {
                    particles.push({ x: x + (Math.random()-0.5)*10, y: y + (Math.random()-0.5)*10, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 30, color }); spawnBudget--;
                }
            }
        }

        function spawnPickup(x, y) {
            const types = ['speed','size','ammo','shield','blast','magnet'];
            const t = types[Math.floor(Math.random()*types.length)];
            pickups.push({ x, y, vy: -1, type: t, life: 600 });
        }

        // åˆ›å»ºå°é¸Ÿ
        function createBird() {
            if (remainingBirds > 0) {
                if (birds.some(b => b && b.inSlingshot && !b.launched && !b.dead)) return;
                const type = birdQueue[nextBirdIndex] || 'red';
                nextBirdIndex++;
                const rByType = type === 'blue' ? 20 : type === 'black' ? 27 : 25;
                birds.push({
                    x: slingshot.x,
                    y: slingshot.y,
                    radius: rByType,
                    baseRadius: rByType,
                    color: 'red',
                    velocity: { x: 0, y: 0 },
                    inSlingshot: true,
                    launched: false,
                    type,
                    abilityUsed: false,
                    bossHit: false
                });
            }
        }

        // åˆ›å»ºå…³å¡
        function createLevel(level) {
            const levelData = levels[level-1];
            
            // åˆ›å»ºæœ¨å—
            levelData.blocks.forEach(block => {
                blocks.push({
                    x: block.x,
                    y: block.y,
                    baseX: block.x,
                    baseY: block.y,
                    width: block.width,
                    height: block.height,
                    color: block.color,
                    health: block.health,
                    fallen: false,
                    rotation: 0,
                    material: block.material || 'wood',
                    isTarget: !!block.target
                });
            });

            if (dailyMode) {
                const ds = Math.floor(Date.now() / 86400000);
                const count = Math.max(1, Math.floor(blocks.length * 0.1));
                for (let i = 0; i < count; i++) {
                    const idx = (i * 7 + ds) % blocks.length;
                    blocks[idx].isTarget = true;
                }
            }
            targetLabelCounter = 0;
            blocks.forEach(b => { if (b.isTarget) b.label = b.label || ('T' + (++targetLabelCounter)); });
            targetsTotal = blocks.filter(b => b.isTarget).length;
            targetsDestroyed = 0;
            precisionBonusAccum = 0;
            completedTargets = [];

            // åˆ›å»ºçŒª
            levelData.pigs.forEach(pig => {
                pigs.push({
                    x: pig.x,
                    y: pig.y,
                    baseY: pig.y,
                    wigglePhase: Math.random() * Math.PI * 2,
                    radius: pig.radius,
                    color: pig.color,
                    health: pig.health,
                    supportGrace: 180
                });
            });
            if (level === 2) {
                let bx = Math.max(180, Math.min(canvas.width - 220, canvas.width - 300 - Math.random()*260));
                let by = Math.max(140, Math.min(canvas.height - 220, canvas.height - 240 - Math.random()*80));
                for (let k=0;k<12;k++) {
                    const d = Math.hypot(bx - slingshot.x, by - slingshot.y);
                    if (d >= 300) break;
                    bx = Math.max(180, Math.min(canvas.width - 220, canvas.width - 300 - Math.random()*260));
                    by = Math.max(140, Math.min(canvas.height - 220, canvas.height - 240 - Math.random()*80));
                }
                bossPending = { x: bx, y: by, baseY: by, wigglePhase: Math.random()*Math.PI*2, radius: 45, color: '#202020', health: 2, maxHealth: 2, isBoss: true, bossType: 'boss1', summonTimer: 300, summonInterval: 300 };
                bossSpawnPortal = { x: bx, y: by, w: 140, h: 180, openProgress: 0, phase: 'opening', alpha: 1, done: false };
                const fenceColor = '#795548';
                const fc = 'boss_fence';
                const offset = 84;
                blocks.push({ x: bx - offset, y: by + 14, width: 12, height: 130, color: fenceColor, health: 20, fallen: false, rotation: 0, material: fc });
                blocks.push({ x: bx + offset, y: by + 14, width: 12, height: 130, color: fenceColor, health: 20, fallen: false, rotation: 0, material: fc });
                blocks.push({ x: bx, y: by - offset, width: offset*2, height: 14, color: fenceColor, health: 20, fallen: false, rotation: 0, material: fc });
                blocks.push({ x: bx, y: by + offset, width: offset*2, height: 14, color: fenceColor, health: 20, fallen: false, rotation: 0, material: fc });
            }
            if (level === 3) {
                let bx = Math.max(140, Math.min(canvas.width - 140, 140 + Math.random()*(canvas.width - 280)));
                let by = Math.max(120, Math.min(canvas.height - 240, 120 + Math.random()*(canvas.height - 360)));
                for (let k=0;k<12;k++) {
                    const d = Math.hypot(bx - slingshot.x, by - slingshot.y);
                    if (d >= 300) break;
                    bx = Math.max(140, Math.min(canvas.width - 140, 140 + Math.random()*(canvas.width - 280)));
                    by = Math.max(120, Math.min(canvas.height - 240, 120 + Math.random()*(canvas.height - 360)));
                }
                bossPending = { x: bx, y: by, baseY: by, wigglePhase: Math.random()*Math.PI*2, radius: 48, color: '#1a1a1a', health: 2, maxHealth: 2, isBoss: true, bossType: 'boss2', riftIntervalMs: 4200, riftLifeFrames: 270, riftRadius: 210 };
                bossSpawnPortal = { x: bx, y: by, w: 140, h: 180, openProgress: 0, phase: 'opening', alpha: 1, done: false };
                const fenceColor = '#795548';
                const fc = 'boss_fence';
                const offset = 84;
                blocks.push({ x: bx - offset, y: by + 14, width: 12, height: 130, color: fenceColor, health: 20, fallen: false, rotation: 0, material: fc });
                blocks.push({ x: bx + offset, y: by + 14, width: 12, height: 130, color: fenceColor, health: 20, fallen: false, rotation: 0, material: fc });
                blocks.push({ x: bx, y: by - offset, width: offset*2, height: 14, color: fenceColor, health: 20, fallen: false, rotation: 0, material: fc });
                blocks.push({ x: bx, y: by + offset, width: offset*2, height: 14, color: fenceColor, health: 20, fallen: false, rotation: 0, material: fc });
            }
            if (level === 4) {
                let bx = Math.max(160, Math.min(canvas.width - 160, 160 + Math.random()*(canvas.width - 320)));
                let by = Math.max(120, Math.min(canvas.height - 240, 120 + Math.random()*(canvas.height - 360)));
                for (let k=0;k<12;k++) {
                    const d = Math.hypot(bx - slingshot.x, by - slingshot.y);
                    if (d >= 320) break;
                    bx = Math.max(160, Math.min(canvas.width - 160, 160 + Math.random()*(canvas.width - 320)));
                    by = Math.max(120, Math.min(canvas.height - 240, 120 + Math.random()*(canvas.height - 360)));
                }
                const bossId = Math.floor(Date.now() + Math.random()*1000);
                bossPending = { x: bx, y: by, baseY: by, wigglePhase: Math.random()*Math.PI*2, radius: 52, color: '#1a1a1a', health: 2, maxHealth: 2, isBoss: true, bossType: 'boss3', teleportIntervalMs: 5000, bossId };
                bossSpawnPortal = { x: bx, y: by, w: 150, h: 190, openProgress: 0, phase: 'opening', alpha: 1, done: false };
                const fc = 'boss_fence';
                const offset = Math.max(100, 1.7 * 52);
                blocks.push({ x: bx - offset, y: by + 16, width: 12, height: 140, color: '#795548', health: 20, fallen: false, rotation: 0, material: fc, bossId, dx: -offset, dy: 16 });
                blocks.push({ x: bx + offset, y: by + 16, width: 12, height: 140, color: '#795548', health: 20, fallen: false, rotation: 0, material: fc, bossId, dx: offset, dy: 16 });
                blocks.push({ x: bx, y: by - offset, width: offset*2, height: 14, color: '#795548', health: 20, fallen: false, rotation: 0, material: fc, bossId, dx: 0, dy: -offset });
                blocks.push({ x: bx, y: by + offset, width: offset*2, height: 14, color: '#795548', health: 20, fallen: false, rotation: 0, material: fc, bossId, dx: 0, dy: offset });
            }
        }

        pigs = pigs.filter(p => !(p.isBoss && p._removeOnDeath && p._readyRemove));

        // ç»˜åˆ¶æ¸¸æˆå…ƒç´ 
        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            const theme = getLevelThemeColors(currentLevel);
            ctx.fillStyle = theme.sky;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Bosså­˜åœ¨æ—¶ç¯å¢ƒå˜æš— (å‹è¿«æ„Ÿå¢å¼ºï¼šæš—è§’ + è„‰å†² + å¿ƒè·³)
            if (pigs.some(p => p.isBoss && p.health > 0)) {
                const t = Date.now() / 1000;
                const pulse = (Math.sin(t * 2) + 1) * 0.5; // 0 to 1

                // 1. åŠ¨æ€æš—è§’ (Dynamic Vignette)
                const r0 = canvas.height * (0.3 - pulse * 0.05);
                const r1 = canvas.height * (0.9 + pulse * 0.1);
                const grd = ctx.createRadialGradient(canvas.width/2, canvas.height/2, r0, canvas.width/2, canvas.height/2, r1);
                grd.addColorStop(0, 'rgba(0,0,0,0.1)');
                grd.addColorStop(1, `rgba(0,0,0,${0.6 + pulse * 0.2})`);
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 2. æ•´ä½“è‰²è°ƒå‹æŠ‘ä¸å¿ƒè·³çº¢å…‰ (Global Tint & Heartbeat)
                ctx.fillStyle = `rgba(${20 + pulse * 30}, 0, 0, ${0.15 + pulse * 0.1})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }


            ctx.save();
            const si = (shakeIntensity + (shakeKick || 0)) * (((bossDeathFx && bossDeathFx.frames>0) || (bossFinale && bossFinale.frames>0) || (bossFinaleBurst && bossFinaleBurst.frames>0)) ? 4.6 : 1);
            if (shakeFrames > 0 && cameraUserFrames <= 0) {
                const shakeX = (Math.random()-0.5)*si/(cameraScale||1);
                const shakeY = (Math.random()-0.5)*si/(cameraScale||1);
                lastDrawShakeX = shakeX;
                lastDrawShakeY = shakeY;
                ctx.translate(shakeX, shakeY);
                // å‰§çƒˆéœ‡åŠ¨æ—¶çš„æ—‹è½¬å’Œç¼©æ”¾å¹²æ‰° (å·²ç§»é™¤)
                /*
                if (shakeFrames > 10) {
                     const rotJitter = (Math.random()-0.5) * 0.02;
                     ctx.rotate(rotJitter);
                }
                */
            } else {
                lastDrawShakeX = 0;
                lastDrawShakeY = 0;
            }
            const s = cameraScale || 1;
            ctx.scale(s, s);
            ctx.translate(-cameraX, -cameraY);

            // åœ°é¢ (Ground) - ä¿®æ­£ä¸ºè·Ÿéšæ‘„åƒæœº (Fixed: Follow Camera)
            ctx.fillStyle = theme.ground;
            // ç»˜åˆ¶è¶…å¤§åœ°é¢ä»¥è¦†ç›–ç¼©æ”¾å’Œç§»åŠ¨åçš„ç©ºç™½ (Draw large ground to cover zoom/pan gaps)
            ctx.fillRect(-10000, canvas.height - 50, 20000, 2000);

            windTunnels.forEach(t => {
                ctx.fillStyle = 'rgba(135,206,250,0.25)';
                ctx.fillRect(t.x, t.y, t.w, t.h);
                ctx.strokeStyle = 'rgba(30,144,255,0.6)';
                ctx.lineWidth = uiSize(2);
                ctx.beginPath();
                ctx.moveTo(t.x + 10, t.y + t.h/2);
                ctx.lineTo(t.x + t.w - 10, t.y + t.h/2);
                ctx.stroke();
            });

            bouncers.forEach(b => {
                ctx.fillStyle = '#455A64';
                ctx.fillRect(b.x, b.y, b.w, b.h);
            });

            // ç»˜åˆ¶æœ¨æ¿ï¼ˆç½®äºåŠ¨æ•ˆä¹‹å‰ï¼Œç¡®ä¿åŠ¨æ•ˆè¦†ç›–æ …æ ï¼‰
            blocks.forEach(block => {
                if (block.health > 0 || block.fallen) {
                    ctx.save();
                    if (block.fallen) {
                        ctx.translate(block.x, block.y);
                        ctx.rotate(block.rotation || Math.PI / 4);
                        const woodGradient = ctx.createLinearGradient(-block.width/2, 0, block.width/2, 0);
                        woodGradient.addColorStop(0, block.color);
                        woodGradient.addColorStop(0.5, '#A0522D');
                        woodGradient.addColorStop(1, block.color);
                        ctx.fillStyle = woodGradient;
                        ctx.fillRect(-block.width/2, -block.height/2, block.width, block.height);
                        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                        ctx.lineWidth = 1;
                        for (let i = -block.width/2 + 5; i < block.width/2; i += 10) { ctx.beginPath(); ctx.moveTo(i, -block.height/2); ctx.lineTo(i, block.height/2); ctx.stroke(); }
                    } else {
                        ctx.translate(block.x, block.y);
                        if (block.material === 'fence' && block.rotation) { ctx.rotate(block.rotation); }
                        const woodGradient = ctx.createLinearGradient(-block.width/2, 0, block.width/2, 0);
                        woodGradient.addColorStop(0, block.color);
                        woodGradient.addColorStop(0.5, '#A0522D');
                        woodGradient.addColorStop(1, block.color);
                        ctx.fillStyle = woodGradient;
                        ctx.fillRect(-block.width/2, -block.height/2, block.width, block.height);
                        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                        ctx.lineWidth = 1;
                        for (let i = -block.width/2 + 5; i < block.width/2; i += 10) { ctx.beginPath(); ctx.moveTo(i, -block.height/2); ctx.lineTo(i, block.height/2); ctx.stroke(); }
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.lineWidth = uiSize(2);
                        ctx.strokeRect(-block.width/2, -block.height/2, block.width, block.height);
                        if (block.isTarget) { ctx.strokeStyle = 'rgba(255,193,7,0.9)'; ctx.lineWidth = uiSize(3); ctx.strokeRect(-block.width/2-2, -block.height/2-2, block.width+4, block.height+4); }
                    }
                    ctx.restore();
                }
            });

            portals.forEach(p => {
                // --- æ·±æ¸Šä¹‹é—¨ (Abyssal Gate) - ç»´åº¦åå™¬è€… ---
                const cx = p.x + p.w/2, cy = p.y + p.h/2;
                const t = Date.now()/1000;
                const maxDim = Math.max(p.w, p.h);
                const qFx = getFxQuality();
                
                ctx.save();
                ctx.translate(cx, cy);

                const litePortal = (currentLevel === 3) || qFx <= 0.55;
                if (litePortal) {
                    const r = maxDim * 0.62;
                    const g = ctx.createRadialGradient(0, 0, r*0.15, 0, 0, r*1.25);
                    g.addColorStop(0, 'rgba(0,0,0,1)');
                    g.addColorStop(0.65, 'rgba(0,0,0,0.85)');
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(0, 0, r*1.25, 0, Math.PI*2); ctx.fill();

                    const ringR = r*0.82 + Math.sin(t*6)*1.5;
                    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                    ctx.lineWidth = uiSize(2.5);
                    ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI*2); ctx.stroke();

                    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                    ctx.lineWidth = uiSize(1.6);
                    for (let k=0;k<4;k++){
                        const a0 = t*0.9 + k*(Math.PI*0.5);
                        ctx.beginPath();
                        ctx.arc(0, 0, ringR*0.72, a0, a0 + Math.PI*0.6);
                        ctx.stroke();
                    }

                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(0, 0, ringR - uiSize(2), 0, Math.PI*2); ctx.fill();

                    ctx.restore();

                    const ex = p.exitX, ey = p.exitY;
                    const angle = Math.atan2(ey - cy, ex - cx);

                    ctx.save();
                    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
                    ctx.lineWidth = uiSize(4);
                    ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(ex, ey); ctx.stroke();
                    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                    ctx.lineWidth = uiSize(2);
                    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(ex, ey); ctx.stroke();
                    ctx.restore();

                    const ah = uiSize(12);
                    ctx.save();
                    ctx.translate(ex, ey);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-ah, -ah*0.6);
                    ctx.lineTo(-ah, ah*0.6);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(255,255,255,0.85)';
                    ctx.fill();
                    ctx.restore();

                    if (p.id) {
                        ctx.fillStyle = '#fff';
                        ctx.font = `900 ${Math.round(uiSize(16))}px "Arial Black"`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'rgba(0,0,0,0.75)';
                        ctx.strokeText(`P${p.id}`, cx, cy);
                        ctx.fillText(`P${p.id}`, cx, cy);
                    }
                    return;
                }
                
                // 1. å¼•åŠ›é€é•œåœº (Gravitational Lens Field)
                const lensR = maxDim * (1.6 + 0.9 * qFx);
                const gradLens = ctx.createRadialGradient(0, 0, maxDim*0.8, 0, 0, lensR);
                gradLens.addColorStop(0, 'rgba(0,0,0,0.2)'); 
                gradLens.addColorStop(0.5, 'rgba(255,255,255,0.05)'); 
                gradLens.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gradLens;
                ctx.beginPath(); ctx.arc(0, 0, lensR, 0, Math.PI*2); ctx.fill();

                // 2. ç‰©è´¨å¸ç§¯æµ (Matter Accretion Stream)
                const streamCount = Math.max(4, Math.floor(12 * qFx)); 
                ctx.rotate(t * 0.5); 
                
                for(let i=0; i<streamCount; i++) {
                    const angleOffset = (i / streamCount) * Math.PI * 2;
                    const streamTime = (t * 2 + i * 0.5) % 2; 
                    
                    ctx.save();
                    ctx.rotate(angleOffset);
                    
                    ctx.beginPath();
                    const startR = maxDim * 2.5;
                    const endR = maxDim * 0.4;
                    
                    ctx.moveTo(startR, 0);
                    const cp1x = startR * 0.6, cp1y = startR * 0.4;
                    const cp2x = endR * 1.5, cp2y = endR * 0.8;
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endR, 0);
                    
                    const gradStream = ctx.createLinearGradient(startR, 0, endR, 0);
                    gradStream.addColorStop(0, 'rgba(0,0,0,0)');
                    gradStream.addColorStop(0.5, `rgba(255,255,255,${0.5 * (1-Math.abs(streamTime-1))})`); 
                    gradStream.addColorStop(1, 'rgba(0,0,0,1)'); 
                    
                    ctx.strokeStyle = gradStream;
                    ctx.lineWidth = 2 + Math.sin(t*5 + i)*1;
                    if (qFx >= 0.6) {
                        ctx.setLineDash([10, 15]); 
                        ctx.lineDashOffset = -t * 50; 
                    } else {
                        ctx.setLineDash([]);
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // 3. è§†ç•Œå…‰ç¯ (Event Horizon Ring)
                ctx.rotate(-t * 0.5); 
                const horizonR = maxDim * 0.6 + Math.sin(t*8)*2;
                
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 20 * qFx;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0, 0, horizonR, 0, Math.PI*2); ctx.stroke();
                ctx.shadowBlur = 0;

                // 4. å¥‡ç‚¹æ ¸å¿ƒ (Singularity Core)
                ctx.beginPath();
                ctx.arc(0, 0, horizonR - 2, 0, Math.PI*2);
                ctx.fillStyle = '#000';
                ctx.fill();
                
                ctx.save();
                ctx.clip();
                ctx.translate(-maxDim, -maxDim);
                const gradVoid = ctx.createRadialGradient(maxDim, maxDim, 0, maxDim, maxDim, maxDim);
                gradVoid.addColorStop(0, 'rgba(20,20,20,1)');
                gradVoid.addColorStop(1, 'rgba(0,0,0,1)');
                ctx.fillStyle = gradVoid;
                ctx.fillRect(0, 0, maxDim*2, maxDim*2);
                
                if(qFx >= 0.6 && Math.random() < 0.3) {
                     ctx.fillStyle = '#fff';
                     const sx = (Math.random()-0.5) * horizonR;
                     const sy = (Math.random()-0.5) * horizonR;
                     ctx.fillRect(maxDim+sx, maxDim+sy, 2, 2);
                }
                ctx.restore();

                ctx.restore();

                // 5. ç»´åº¦è£‚ç¼è¿æ¥çº¿ (Dimensional Rift Link)
                const ex = p.exitX, ey = p.exitY;
                const dist = Math.hypot(ex - cx, ey - cy);
                const angle = Math.atan2(ey - cy, ex - cx);
                
                ctx.save();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = uiSize(6);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowColor = 'rgba(255,255,255,0.5)'; 
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                
                let lx = cx, ly = cy;
                const segments = Math.max(6, Math.floor(12 * qFx));
                const amp = 20 * qFx; 
                
                for(let i=1; i<segments; i++) {
                    const rt = i/segments;
                    const tx = cx + (ex-cx)*rt;
                    const ty = cy + (ey-cy)*rt;
                    
                    const jitterX = (Math.random()-0.5) * amp * Math.sin(rt * Math.PI);
                    const jitterY = (Math.random()-0.5) * amp * Math.sin(rt * Math.PI);
                    
                    ctx.lineTo(tx + jitterX, ty + jitterY);
                }
                ctx.lineTo(ex, ey);
                ctx.stroke();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 0;
                ctx.globalCompositeOperation = 'overlay';
                ctx.stroke();
                
                ctx.restore();

                // 6. ç®­å¤´æŒ‡ç¤º
                const ah = uiSize(12);
                
                ctx.save();
                ctx.translate(ex, ey);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-ah, -ah*0.6);
                ctx.lineTo(-ah, ah*0.6);
                ctx.closePath();
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.restore();
                
                // ID æ ‡è®°
                if (p.id) {
                    ctx.fillStyle = '#fff';
                    ctx.font = `900 ${Math.round(uiSize(16))}px "Arial Black"`; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 8;
                    ctx.lineWidth = 3;
                    ctx.strokeText(`P${p.id}`, cx, cy); 
                    ctx.fillText(`P${p.id}`, cx, cy);
                }
            });

            if (bossSpawnPortal) {
                // --- ç»ˆæBOSSé™ä¸´ä¹‹é—¨ (Abyssal Spawn Gate) ---
                const cx = bossSpawnPortal.x, cy = bossSpawnPortal.y;
                const w = bossSpawnPortal.w, h = bossSpawnPortal.h;
                const prog = Math.max(0, Math.min(1, bossSpawnPortal.openProgress||0));
                ctx.save();
                ctx.globalAlpha = Math.max(0, Math.min(1, bossSpawnPortal.alpha||1));
                const r = Math.min(w, h) * 0.85; 
                const t = Date.now() / 1000;
                const qFx = getFxQuality();

                // 1. ç»´åº¦åç¼©åœº
                const gradCollapse = ctx.createRadialGradient(cx, cy, r*0.1, cx, cy, r*2.0);
                gradCollapse.addColorStop(0, 'rgba(0,0,0,1)');
                gradCollapse.addColorStop(0.4, 'rgba(10,10,10,0.95)');
                gradCollapse.addColorStop(0.8, 'rgba(0,0,0,0.8)');
                gradCollapse.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gradCollapse;
                ctx.beginPath(); ctx.arc(cx, cy, r*2.0, 0, Math.PI*2); ctx.fill();

                // 2. è™šç©ºé£æš´
                ctx.translate(cx, cy);
                ctx.rotate(t * 0.2);
                
                const stormCount = Math.max(6, Math.floor(15 * qFx));
                for(let i=0; i<stormCount; i++) {
                    ctx.save();
                    ctx.rotate(i * (Math.PI*2/stormCount));
                    ctx.beginPath();
                    ctx.arc(r*0.8, 0, r*0.5, 0, Math.PI*2);
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.shadowBlur = 30 * qFx;
                    ctx.shadowColor = '#000';
                    ctx.fill();
                    ctx.restore();
                }
                
                // 3. æ ¸å¿ƒå¥‡ç‚¹
                ctx.rotate(-t * 0.4); 
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI*2);
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 50;
                ctx.shadowColor = '#fff'; 
                ctx.fill();
                
                // 4. é—ªç”µé£æš´
                const lightningCount = Math.max(8, Math.floor(20 * qFx));
                for(let i=0; i<lightningCount; i++) {
                    // Removed random skip to ensure more lightning
                    const ang = i * (Math.PI*2/lightningCount) + t + Math.random()*0.5;
                    const len = r * 1.2;
                    
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(ang)*r*0.9, Math.sin(ang)*r*0.9);
                    ctx.lineTo(Math.cos(ang)*len, Math.sin(ang)*len);
                    ctx.strokeStyle = Math.random() < 0.5 ? '#fff' : '#aaa';
                    ctx.lineWidth = Math.random() * 3 + 1;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#fff';
                    ctx.stroke();
                }

                // 5. ç©ºé—´è£‚çº¹
                ctx.rotate(t * 0.1);
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const crackCount = Math.max(8, Math.floor(16 * qFx));
                for(let i=0; i<crackCount; i++) {
                    const ang = i * (Math.PI*2/crackCount);
                    ctx.moveTo(Math.cos(ang)*r*0.2, Math.sin(ang)*r*0.2);
                    const maxR = r * 0.9;
                    let currR = r * 0.2;
                    let currAng = ang;
                    const steps = Math.max(4, Math.floor(9 * qFx));
                    for (let s=0; s<steps; s++) {
                        currR += ((maxR - r*0.2) / steps) * (0.7 + 0.6*Math.random());
                        currAng += (Math.random() - 0.5) * 0.5 * qFx;
                        const rr = Math.min(maxR, currR);
                        ctx.lineTo(Math.cos(currAng)*rr, Math.sin(currAng)*rr);
                    }
                }
                ctx.stroke();

                ctx.restore();
            }


            wheels.forEach(w => {
                ctx.save();
                ctx.translate(w.x, w.y);
                ctx.rotate(w.angle);
                ctx.fillStyle = '#455A64';
                ctx.beginPath();
                ctx.arc(0, 0, w.r, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = '#CFD8DC';
                ctx.lineWidth = uiSize(3);
                for (let i=0;i<6;i++){ ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(w.r,0); ctx.stroke(); ctx.rotate(Math.PI/3); }
                ctx.restore();
            });

            rotorBars.forEach(rb => {
                ctx.save();
                ctx.translate(rb.cx, rb.cy);
                ctx.rotate(rb.angle);
                ctx.fillStyle = '#607D8B';
                ctx.fillRect(0, -rb.width/2, rb.length, rb.width);
                ctx.restore();
            });

            explosions.forEach(e => {
                const alpha = Math.max(0, 1 - e.age / 30);
                const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.r);
                grad.addColorStop(0, `rgba(255,200,0,${alpha})`);
                grad.addColorStop(0.6, `rgba(255,80,0,${alpha*0.7})`);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
                ctx.fill();
            });
            const qFxRing = fxQ;
            impactRings.forEach(rg => {
                const a = Math.max(0, rg.alpha);
                ctx.strokeStyle = rg.rgb ? `rgba(${rg.rgb},${a})` : `rgba(255,255,255,${a})`;
                ctx.lineWidth = uiSize((typeof rg.w === 'number' ? rg.w : 2));
                if (rg.spiky && (fxHeavy || qFxRing >= 0.62)) {
                    const steps = FX_OVERDRIVE ? Math.max(54, Math.round(58 + 84 * fxQ)) : Math.max(18, Math.floor(52 * qFxRing));
                    const phase = rg.phase || 0;
                    const noise = Math.max(0, rg.noise || 0);
                    const ef1 = 0.18 + noise * 0.002;
                    const ef2 = ef1 * 2.7;
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    for (let i = 0; i <= steps; i++) {
                        const ang = i * (Math.PI * 2 / steps);
                        const j = (Math.sin(i * ef1 + phase) * noise) + (Math.sin(i * ef2 + phase * 1.3) * noise * 0.35);
                        const rr = rg.r + j;
                        const x = rg.x + Math.cos(ang) * rr;
                        const y = rg.y + Math.sin(ang) * rr;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.shadowBlur = uiSize(FX_OVERDRIVE ? (16 + 14 * fxQ) : (10 + 8 * qFxRing));
                    ctx.shadowColor = rg.rgb ? `rgba(${rg.rgb},${Math.min(1, a * 0.9)})` : `rgba(255,255,255,${Math.min(1, a * 0.9)})`;
                    ctx.stroke();
                    ctx.restore();
                    rg.phase = phase + 0.22 + 0.08 * qFxRing;
                    rg.noise = noise * (rg.nDecay || 0.94);
                } else {
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.r, 0, Math.PI*2);
                    ctx.stroke();
                }
                rg.r += (typeof rg.growth === 'number' ? rg.growth : 2);
                rg.alpha -= (typeof rg.decay === 'number' ? rg.decay : 0.03);
            });
            impactRings = impactRings.filter(rg => rg.alpha > 0 && rg.r < rg.maxR);

            // ç»˜åˆ¶æ°´å¹³å¼¹å¼“ï¼ˆæ„¤æ€’çš„å°é¸Ÿé£æ ¼ï¼‰
            ctx.save();
            let jx = 0, jy = 0;
            if (slingJitterFrames > 0) {
                const ph = (8 - slingJitterFrames);
                jx = Math.sin(ph * 1.8) * uiSize(1.5);
                jy = Math.cos(ph * 1.6) * uiSize(1.2);
                slingJitterFrames--;
            }
            ctx.translate(slingshot.x + jx, slingshot.y + jy);
            
            // ç»˜åˆ¶å¼¹å¼“åº•åº§ - çŸ³å¤´è´¨æ„Ÿ
            const stoneGradient = ctx.createRadialGradient(0, 20, 0, 0, 20, 40);
            stoneGradient.addColorStop(0, '#8B7D6B');
            stoneGradient.addColorStop(0.5, '#A0958B');
            stoneGradient.addColorStop(1, '#6B5B47');
            ctx.fillStyle = stoneGradient;
            
            ctx.beginPath();
            ctx.ellipse(0, 20, 35, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // åº•åº§é˜´å½±
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 25, 35, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶å¼¹å¼“ä¸»å¹² - æ°´å¹³Yå½¢çŠ¶
            const trunkGradient = ctx.createLinearGradient(-80, -30, -80, 30);
            trunkGradient.addColorStop(0, '#8B4513');
            trunkGradient.addColorStop(0.3, '#A0522D');
            trunkGradient.addColorStop(0.7, '#8B4513');
            trunkGradient.addColorStop(1, '#654321');
            ctx.fillStyle = trunkGradient;
            
            // å¼¹å¼“ä¸»å¹² - æ°´å¹³Yå½¢çŠ¶
            // ä¸‹åˆ†æ”¯
            ctx.beginPath();
            ctx.moveTo(0, 15);
            ctx.lineTo(-60, 10);
            ctx.lineTo(-80, -20);
            ctx.lineTo(-75, -25);
            ctx.lineTo(-55, 5);
            ctx.lineTo(0, 10);
            ctx.closePath();
            ctx.fill();
            
            // ä¸Šåˆ†æ”¯
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(-60, -10);
            ctx.lineTo(-80, 20);
            ctx.lineTo(-75, 25);
            ctx.lineTo(-55, -5);
            ctx.lineTo(0, -10);
            ctx.closePath();
            ctx.fill();
            
            // æ·»åŠ æœ¨è´¨çº¹ç†
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = uiSize(1);
            for(let i = -70; i <= 0; i += 8) {
                ctx.beginPath();
                ctx.moveTo(i, -18);
                ctx.lineTo(i * 0.8, 18);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶å¼¹å¼“åˆ†å‰å¤„çš„åŠ å›ºå¸¦
            ctx.fillStyle = '#654321';
            ctx.fillRect(-8, -18, 8, 36);
            ctx.fillRect(-18, -15, 8, 30);
            
            // ç»˜åˆ¶å¼¹å¼“é¡¶éƒ¨çš„é‡‘å±åŠ å›ºä»¶
            const metalGradient = ctx.createLinearGradient(-80, -25, -80, 25);
            metalGradient.addColorStop(0, '#C0C0C0');
            metalGradient.addColorStop(0.5, '#E6E6FA');
            metalGradient.addColorStop(1, '#C0C0C0');
            ctx.fillStyle = metalGradient;
            
            // ä¸Šæ–¹é‡‘å±ä»¶
            ctx.beginPath();
            ctx.arc(-77, 22, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸‹æ–¹é‡‘å±ä»¶  
            ctx.beginPath();
            ctx.arc(-77, -22, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ©¡çš®ç­‹
            const currentBird = birds.find(bird => bird.inSlingshot);
            if (currentBird) {
                // è½¬æ¢é¸Ÿçš„åæ ‡åˆ°å¼¹å¼“åæ ‡ç³»
                const birdLocalX = currentBird.x - slingshot.x;
                const birdLocalY = currentBird.y - slingshot.y;
                
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = uiSize(4);
                ctx.lineCap = 'round';
                
                // ä¸Šä¾§æ©¡çš®ç­‹
                ctx.beginPath();
                ctx.moveTo(-77, 22);
                ctx.lineTo(birdLocalX, birdLocalY);
                ctx.stroke();
                
                // ä¸‹ä¾§æ©¡çš®ç­‹
                ctx.beginPath();
                ctx.moveTo(-77, -22);
                ctx.lineTo(birdLocalX, birdLocalY);
                ctx.stroke();
                
                // æ©¡çš®ç­‹é«˜å…‰æ•ˆæœ
                ctx.strokeStyle = 'rgba(139,69,19,0.5)';
                ctx.lineWidth = uiSize(2);
                ctx.beginPath();
                ctx.moveTo(-77, 22);
                ctx.lineTo(birdLocalX, birdLocalY);
                ctx.moveTo(-77, -22);
                ctx.lineTo(birdLocalX, birdLocalY);
                ctx.stroke();
                if ((8 - slingJitterFrames) <= 3 && slingJitterFrames > 0) {
                    ctx.strokeStyle = 'rgba(255,220,150,0.85)';
                    ctx.lineWidth = uiSize(1.6);
                    ctx.beginPath();
                    ctx.moveTo(-77, 22);
                    ctx.lineTo(birdLocalX, birdLocalY);
                    ctx.moveTo(-77, -22);
                    ctx.lineTo(birdLocalX, birdLocalY);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
            ctx.save();
            if (weather === 'rain' || weather === 'snow' || weather === 'snow_fog') {
                if (weather === 'rain') {
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 2;
                    for (let i=0;i<weatherDrops.length;i++) { const d = weatherDrops[i]; ctx.beginPath(); ctx.moveTo(d.x, d.y); ctx.lineTo(d.x + 10, d.y + 20); ctx.stroke(); }
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.85)';
                    for (let i=0;i<weatherSnow.length;i++) { const s = weatherSnow[i]; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); }
                }
            }
            if (weather === 'fog' || weather === 'snow_fog') {
                ctx.fillStyle = `rgba(255,255,255,${Math.max(0, Math.min(0.32, fogAlpha||0.26))})`;
                ctx.fillRect(0,0,canvas.width,canvas.height);
            }
            ctx.restore();
            const uiBird = birds.find(b => b.inSlingshot);
            if (uiBird) {
                const t = uiBird.type || 'red';
                const text = `${typeNames[t]||t}ï¼š${skillDescriptions[t]||''}`;
                const bx = slingshot.x + uiSize(30);
                const by = slingshot.y - uiSize(60);
                const boxH = t !== 'red' ? uiSize(40) : uiSize(28);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(bx, by, uiSize(180), boxH);
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = uiSize(1);
                ctx.strokeRect(bx, by, uiSize(180), boxH);
                ctx.save();
                const ix = bx + uiSize(8);
                const iy = by + uiSize(14);
                const ph = Date.now() / 220;
                const pull = Math.min(1, Math.hypot(uiBird.x - slingshot.x, uiBird.y - slingshot.y) / 120);
                const glowBlur = uiSize(4 + 6*pull + 3*Math.abs(Math.sin(ph)));
                const glowColors = { yellow:'#FF7043', black:'#F44336', blue:'#1E88E5', white:'#FDD835', orange:'#FFC107', green:'#4CAF50' };
                const glow = glowColors[t];
                if (glow) { ctx.shadowColor = glow; ctx.shadowBlur = glowBlur; }
                if (t === 'yellow') {
                    const w = uiSize(32 + 6*Math.sin(ph));
                    const g = ctx.createLinearGradient(ix, 0, ix + w, 0);
                    g.addColorStop(0, '#FFA726'); g.addColorStop(1, '#FB8C00');
                    ctx.fillStyle = g;
                    ctx.fillRect(ix, iy - uiSize(3), w, uiSize(6));
                } else if (t === 'black') {
                    ctx.strokeStyle = '#F44336';
                    ctx.lineWidth = uiSize(3);
                    const r = uiSize(8 + 2*Math.sin(ph));
                    ctx.beginPath();
                    ctx.arc(ix + uiSize(10), iy, r, 0, Math.PI*2);
                    ctx.stroke();
                } else if (t === 'blue') {
                    ctx.fillStyle = '#1E88E5';
                    for (let i=0;i<5;i++) {
                        const dx = uiSize(6 + i*6) + uiSize(2*Math.sin(ph + i));
                        const dy = uiSize(((i%2)?-3:3)) + uiSize(1.5*Math.cos(ph*1.2 + i));
                        ctx.beginPath();
                        ctx.arc(ix + dx, iy + dy, uiSize(2), 0, Math.PI*2);
                        ctx.fill();
                    }
                } else if (t === 'white') {
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.ellipse(ix + uiSize(10), iy, uiSize(8), uiSize(10), 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#FDD835';
                    ctx.beginPath();
                    ctx.arc(ix + uiSize(10), iy - uiSize(4 + 1.5*Math.sin(ph)), uiSize(3), 0, Math.PI*2);
                    ctx.fill();
                } else if (t === 'orange') {
                    ctx.strokeStyle = '#FFC107';
                    ctx.lineWidth = uiSize(2 + Math.abs(Math.sin(ph))*1.2);
                    ctx.beginPath();
                    ctx.arc(ix + uiSize(10), iy, uiSize(9 + 2*Math.sin(ph*0.8)), 0, Math.PI*2);
                    ctx.stroke();
                } else if (t === 'green') {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = uiSize(2);
                    const wob = uiSize(2*Math.sin(ph*0.9));
                    ctx.beginPath();
                    ctx.moveTo(ix, iy + wob);
                    ctx.lineTo(ix + uiSize(18), iy + wob);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(ix + uiSize(18), iy + wob);
                    ctx.lineTo(ix + uiSize(14), iy - uiSize(4) + wob);
                    ctx.lineTo(ix + uiSize(14), iy + uiSize(4) + wob);
                    ctx.closePath();
                    ctx.fillStyle = '#4CAF50';
                    ctx.fill();
                }
                ctx.restore();
                ctx.fillStyle = '#FFD54F';
                ctx.font = `${Math.round(uiSize(14))}px sans-serif`;
                ctx.fillText(text, bx + uiSize(44), by + uiSize(20));
                if (t !== 'red') {
                    const hints = { blue:'å†æ¬¡ç‚¹å‡»åˆ†è£‚', yellow:'ç‚¹å‡»åŠ é€Ÿ', black:'ç‚¹å‡»çˆ†ç‚¸', white:'ç‚¹å‡»ä¸‹è›‹', orange:'ç‚¹å‡»è†¨èƒ€å…‰ç¯', green:'ç‚¹å‡»æ—‹è½¬â†’è¿½è¸ªåŒæ€' };
                    const hint = hints[t];
                    if (hint) {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `${Math.round(uiSize(11))}px sans-serif`;
                        ctx.fillText(hint, bx + uiSize(44), by + uiSize(34));
                    }
                }
            }
            if (draggedBird) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.font = `${Math.round(uiSize(12))}px sans-serif`;
                ctx.fillText('å³é”®/ESC å–æ¶ˆå‘å°„', slingshot.x + uiSize(10), slingshot.y - uiSize(40));
            }

            ctx.fillStyle = '#FFD54F';
            ctx.font = `${Math.round(uiSize(18))}px sans-serif`;
            floatScores.forEach(fs => { ctx.globalAlpha = Math.max(0, fs.life/40); ctx.fillText(fs.text, fs.x, fs.y); ctx.globalAlpha = 1; });
            safeZones.forEach(sz => { ctx.strokeStyle = 'rgba(76,175,80,0.8)'; ctx.lineWidth = uiSize(2); ctx.strokeRect(sz.x, sz.y, sz.w, sz.h); });

            let trajectoryBird = birds.find(bird => bird.inSlingshot);
            if (trajectoryBird && draggedBird && settings.showTrajectory) {
                const dist = Math.hypot(slingshot.x - trajectoryBird.x, slingshot.y - trajectoryBird.y);
                const power = launchPower(dist);
                const velocityX = (slingshot.x - trajectoryBird.x) * power;
                const velocityY = (slingshot.y - trajectoryBird.y) * power;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = uiSize(2);
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                let trajX = trajectoryBird.x;
                let trajY = trajectoryBird.y;
                let trajVelX = velocityX;
                let trajVelY = velocityY;
                for (let i = 0; i < 24; i++) {
                    ctx.lineTo(trajX, trajY);
                    trajVelY += gravity;
                    trajX += trajVelX;
                    trajY += trajVelY;
                    if (trajX > canvas.width || trajY > canvas.height - 50) break;
                }
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                trajX = trajectoryBird.x;
                trajY = trajectoryBird.y;
                trajVelX = velocityX;
                trajVelY = velocityY;
                for (let i = 0; i < 24; i += 3) {
                    ctx.beginPath();
                    ctx.arc(trajX, trajY, 3, 0, Math.PI * 2);
                    ctx.fill();
                    for (let j = 0; j < 3; j++) {
                        trajVelY += gravity;
                        trajX += trajVelX;
                        trajY += trajVelY;
                        if (trajX > canvas.width || trajY > canvas.height - 50) break;
                    }
                    if (trajX > canvas.width || trajY > canvas.height - 50) break;
                }
            }

            const sVis = cameraScale || 1;
            const vxVis = cameraX, vyVis = cameraY, vwVis = canvas.width / sVis, vhVis = canvas.height / sVis;
            const mVis = 80;
                    const qFxDraw = fxQ;
            const drawStride = (qFxDraw >= 0.75) ? 1 : (qFxDraw >= 0.55 ? 2 : 3);
            particles.forEach((p, pi) => {
                if (drawStride > 1 && (pi % drawStride !== 0)) return;
                if (p.x < vxVis - mVis || p.x > vxVis + vwVis + mVis || p.y < vyVis - mVis || p.y > vyVis + vhVis + mVis) return;
                if (p.shape === 'ring') {
                    ctx.strokeStyle = p.color;
                    ctx.globalAlpha = Math.max(0, p.alpha || 1);
                    ctx.lineWidth = uiSize(2);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r || 4, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else if (p.shape === 'streak') {
                    const ang = Math.atan2(p.vy, p.vx);
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(ang);
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = uiSize(2);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(p.len || 8, 0);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.shape === 'smoke') {
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.6);
                    ctx.fillStyle = p.color || 'rgba(0,0,0,1)';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r || 6, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                } else if (p.shape === 'afterimage') {
                    ctx.save();
                    const a = Math.max(0, p.alpha || 0.45);
                    const rr = p.r || 20;
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = a;
                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, rr * 1.8);
                    if (p.tint === 'green') {
                        g.addColorStop(0, 'rgba(105,240,174,0.45)');
                        g.addColorStop(0.55, 'rgba(0,200,120,0.20)');
                        g.addColorStop(1, 'rgba(0,255,180,0)');
                    } else {
                        g.addColorStop(0, 'rgba(255,120,60,0.55)');
                        g.addColorStop(0.5, 'rgba(255,60,0,0.25)');
                        g.addColorStop(1, 'rgba(255,0,0,0)');
                    }
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, rr * 1.6, 0, Math.PI * 2);
                    ctx.fill();
                    if (imageLoaded && (fxHeavy || qFxDraw >= 0.78)) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, rr, 0, Math.PI * 2);
                        ctx.clip();
                        ctx.globalAlpha = a * (fxHeavy ? 0.85 : 0.7);
                        const sz = rr * 2;
                        ctx.drawImage(headImage, p.x - rr, p.y - rr, sz, sz);
                        ctx.restore();
                    }
                    ctx.restore();
                } else if (p.shape === 'impact_slash') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.theta || 0);
                    const a = Math.max(0, p.alpha || 0.9);
                    const len = p.len || 40;
                    const w = p.w || 10;
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = a;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.shadowBlur = uiSize(FX_OVERDRIVE ? (12 + 18 * fxQ) : 18);
                    ctx.shadowColor = 'rgba(255,40,0,0.95)';
                    ctx.strokeStyle = 'rgba(255,110,30,0.65)';
                    ctx.lineWidth = uiSize(FX_OVERDRIVE ? (w * (1.02 + 0.18 * fxQ)) : w);
                    ctx.beginPath();
                    ctx.moveTo(-len * 0.25, 0);
                    ctx.lineTo(len, 0);
                    ctx.stroke();
                    if (FX_OVERDRIVE && fxHeavy) {
                        const off = uiSize(3);
                        ctx.shadowBlur = uiSize(24);
                        ctx.shadowColor = 'rgba(0,220,255,0.85)';
                        ctx.strokeStyle = 'rgba(80,255,255,0.28)';
                        ctx.lineWidth = uiSize(w * 0.78);
                        ctx.beginPath();
                        ctx.moveTo(-len * 0.22, off);
                        ctx.lineTo(len * 0.92, off);
                        ctx.stroke();
                        ctx.shadowColor = 'rgba(255,0,90,0.85)';
                        ctx.strokeStyle = 'rgba(255,70,140,0.22)';
                        ctx.beginPath();
                        ctx.moveTo(-len * 0.22, -off);
                        ctx.lineTo(len * 0.92, -off);
                        ctx.stroke();
                    }
                    ctx.shadowBlur = uiSize(10);
                    ctx.shadowColor = 'rgba(255,255,255,0.8)';
                    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
                    ctx.lineWidth = uiSize(Math.max(1.2, w * 0.28));
                    ctx.beginPath();
                    ctx.moveTo(-len * 0.18, 0);
                    ctx.lineTo(len * 0.85, 0);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.shape === 'melt') {
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.9);
                    ctx.fillStyle = p.color || 'rgba(0,0,0,1)';
                    const rr = p.r || 4;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, rr, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = Math.max(0, (p.alpha||0.9) * 0.6);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y+rr*0.4);
                    ctx.lineTo(p.x-rr*0.4, p.y+rr*1.6);
                    ctx.lineTo(p.x+rr*0.4, p.y+rr*1.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (p.shape === 'ember') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.9);
                    ctx.fillStyle = p.color || 'rgba(255,215,0,0.9)';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r || 2.2, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.restore();
                } else if (p.shape === 'rune') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rot || 0);
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.8);
                    ctx.fillStyle = p.color || 'rgba(180,220,255,0.9)';
                    ctx.font = `${Math.round(p.size || 16)}px serif`;
                    ctx.fillText(p.ch || 'áš ', 0, 0);
                    ctx.restore();
                } else if (p.shape === 'black_flame') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.theta || 0);
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.9);
                    
                    // å¢å¼ºçš„é»‘è‰²ç«ç„°ï¼šæ›´é•¿ã€æ›´åŠ¨æ€
                    const w = (p.w || 12) * (1 + Math.random()*0.2);
                    const len = (p.len || 28) * (1 + Math.random()*0.3);
                    const flick = (p.flicker || 0.12) * 2.0; // æ›´å¼ºé—ªçƒ
                    
                    const t = Date.now() * 0.003; // æ›´å¿«
                    const jitter = Math.sin(t + (p.theta||0)*132) * flick * w;
                    
                    // æ ¸å¿ƒé»‘
                    const g = ctx.createLinearGradient(0, 0, 0, len);
                    g.addColorStop(0, p.color || 'rgba(0,0,0,1)');
                    g.addColorStop(0.4, 'rgba(10,10,10,0.9)');
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g;
                    
                    ctx.beginPath();
                    ctx.moveTo(-w/2, 0);
                    ctx.quadraticCurveTo(-w*0.1 + jitter, len*0.4, 0, len);
                    ctx.quadraticCurveTo(w*0.1 + jitter, len*0.4, w/2, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // è¾¹ç¼˜é«˜å…‰ï¼ˆè‹ç™½è¾¹ï¼‰
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(100,100,100,0.4)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    ctx.restore();
                } else if (p.shape === 'void_lightning') {
                    // æ–°å¢ï¼šè™šç©ºé—ªç”µç²’å­ - å‡çº§ç‰ˆ (å¤šå±‚æ¸²æŸ“ - çº¯é»‘ç™½)
                    ctx.save();
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = Math.max(0, p.alpha || 1);
                    
                    const segs = p.segs || 6;
                    const len = p.len || 40;
                    const ang = p.theta || 0;
                    const mainW = p.w || 3;
                    
                    // ç”Ÿæˆè·¯å¾„ç‚¹
                    const points = [{x: p.x, y: p.y}];
                    const ex = p.x + Math.cos(ang) * len;
                    const ey = p.y + Math.sin(ang) * len;
                    
                    for(let k=1; k<=segs; k++){
                        const t = k/segs;
                        const tx = p.x + (ex - p.x)*t;
                        const ty = p.y + (ey - p.y)*t;
                        const jit = (Math.random()-0.5) * (p.jitter || 15);
                        let px, py;
                        if (k===segs) { px = tx; py = ty; }
                        else { 
                            px = tx + Math.cos(ang + Math.PI/2)*jit; 
                            py = ty + Math.sin(ang + Math.PI/2)*jit; 
                        }
                        points.push({x: px, y: py});
                    }

                    // 1. å¤–å±‚å…‰æ™• (ç™½è‰²/æ·±ç° - å¢åŠ å¯¹æ¯”åº¦)
                    ctx.beginPath();
                    points.forEach((pt, i) => { if(i===0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y); });
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)'; // ç™½è‰²è¾‰å…‰
                    ctx.strokeStyle = 'rgba(50, 50, 50, 0.4)';
                    ctx.lineWidth = mainW * 3.5;
                    ctx.stroke();

                    // 2. ä¸»ä½“ (çº¯é»‘)
                    ctx.beginPath();
                    points.forEach((pt, i) => { if(i===0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y); });
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = p.color || 'rgba(0,0,0,1)';
                    ctx.lineWidth = mainW;
                    ctx.stroke();

                    // 3. æ ¸å¿ƒ (äº®ç™½) - å¢åŠ ç”µæµæ„Ÿ
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    points.forEach((pt, i) => { if(i===0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y); });
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.lineWidth = Math.max(1, mainW * 0.3);
                    ctx.stroke();
                    ctx.globalCompositeOperation = 'source-over';

                    ctx.restore();
                } else if (p.shape === 'dark_tendril') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.theta || 0);
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.85);
                    const w = p.w || 14;
                    const len = p.len || 40;
                    const g = ctx.createLinearGradient(0, 0, 0, len);
                    g.addColorStop(0, p.color || 'rgba(0,0,0,0.9)');
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.moveTo(-w*0.4, 0);
                    ctx.quadraticCurveTo(-w*0.2, len*0.5, 0, len);
                    ctx.quadraticCurveTo(w*0.2, len*0.5, w*0.4, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (p.shape === 'shadow_fissure') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.theta || 0);
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.85);
                    ctx.strokeStyle = p.color || 'rgba(0,0,0,0.9)';
                    ctx.lineWidth = p.w || 8;
                    const len = p.len || 60;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(-ctx.lineWidth*0.3, len*0.5, 0, len);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.shape === 'orbit_blade') {
                    ctx.save();
                    const th = p.theta || 0;
                    const rad = p.rad || 40;
                    const x = (p.cx||0) + Math.cos(th) * rad;
                    const y = (p.cy||0) + Math.sin(th) * rad;
                    ctx.translate(x, y);
                    ctx.rotate(th + Math.PI/2);
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.8);
                    ctx.fillStyle = p.color || 'rgba(0,0,0,0.9)';
                    const s = p.size || 18;
                    ctx.beginPath();
                    ctx.moveTo(0, -s*0.8);
                    ctx.lineTo(-s*0.5, s*0.6);
                    ctx.lineTo(s*0.5, s*0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (p.shape === 'eclipse') {
                    ctx.save();
                    const x0 = Number.isFinite(p.x) ? p.x : 0;
                    const y0 = Number.isFinite(p.y) ? p.y : 0;
                    const r0 = Math.max(1, Math.min(1000, (Number.isFinite(p.r0) ? p.r0 : 30)));
                    let r1 = Number.isFinite(p.r1) ? p.r1 : 120;
                    r1 = Math.max(r0 + 1, Math.min(2000, r1));
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.95);
                    const g = ctx.createRadialGradient(x0, y0, r0*0.6, x0, y0, r1);
                    g.addColorStop(0, p.color || 'rgba(0,0,0,1)');
                    g.addColorStop(0.6, 'rgba(0,0,0,0.9)');
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(x0, y0, r1, 0, Math.PI*2); ctx.fill();
                    ctx.translate(x0, y0);
                    ctx.rotate(p.rot || 0);
                    ctx.strokeStyle = p.color || 'rgba(0,0,0,0.95)';
                    ctx.lineWidth = uiSize(4);
                    const spikes = p.spikes || 16;
                    const rad = Math.max(r0*1.4, r1*0.7);
                    for (let i=0;i<spikes;i++){
                        const ang = i*(Math.PI*2/spikes);
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(ang)*rad*0.8, Math.sin(ang)*rad*0.8);
                        ctx.lineTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (p.shape === 'lightning_bolt') {
                    ctx.save();
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = Math.max(0, p.life / 20);
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = p.width || 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = p.color;
                    const segs = p.segments || 3;
                    const len = p.len || 10;
                    const ang = Math.atan2(p.vy, p.vx);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    let cx = p.x, cy = p.y;
                    for(let k=0; k<segs; k++) {
                        cx += Math.cos(ang) * (len/segs) + (Math.random()-0.5)*5;
                        cy += Math.sin(ang) * (len/segs) + (Math.random()-0.5)*5;
                        ctx.lineTo(cx, cy);
                    }
                    ctx.stroke();
                    ctx.restore();
                } else if (p.shape === 'feather') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle || 0);
                    ctx.globalAlpha = Math.max(0, p.life / 60);
                    ctx.fillStyle = p.color;
                    const sz = p.size || 10;
                    ctx.beginPath();
                    ctx.moveTo(0, -sz/2);
                    ctx.quadraticCurveTo(sz/3, -sz/4, 0, sz/2);
                    ctx.quadraticCurveTo(-sz/3, -sz/4, 0, -sz/2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -sz/2);
                    ctx.lineTo(0, sz/2);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.shape === 'matrix_char') {
                    ctx.save();
                    ctx.font = `${p.size || 12}px monospace`;
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = Math.max(0, p.life / 30);
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = p.color;
                    ctx.fillText(p.char, p.x, p.y);
                    ctx.restore();
                } else if (p.shape === 'spark') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    const ang = Math.atan2(p.vy, p.vx);
                    ctx.rotate(ang);
                    ctx.globalAlpha = Math.max(0, p.life / 30);
                    ctx.fillStyle = p.color;
                    const len = p.len || 10;
                    ctx.beginPath();
                    ctx.moveTo(-len/2, 0);
                    ctx.quadraticCurveTo(0, 2, len/2, 0);
                    ctx.quadraticCurveTo(0, -2, -len/2, 0);
                    ctx.fill();
                    ctx.restore();
                } else if (p.shape === 'swirl') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.9);
                    ctx.strokeStyle = p.color || 'rgba(120,180,255,0.9)';
                    ctx.lineWidth = p.width || uiSize(2);
                    const th1 = p.theta, th2 = p.theta + 0.25;
                    ctx.beginPath();
                    ctx.arc(p.cx, p.cy, p.rad || 20, th1, th2);
                    ctx.stroke();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.restore();
                } else if (p.shape === 'smoke_ring') {
                    ctx.save();
                    const th = p.theta || 0;
                    const rad = p.rad || 60;
                    const x = (p.cx||0) + Math.cos(th) * rad;
                    const y = (p.cy||0) + Math.sin(th) * rad;
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.8);
                    const g = ctx.createRadialGradient(x, y, 0, x, y, p.r || 8);
                    g.addColorStop(0, p.color || 'rgba(0,0,0,0.8)');
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(x, y, p.r || 8, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                } else if (p.shape === 'amaterasu') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rot || 0);
                    ctx.globalAlpha = Math.max(0, p.alpha || 0.8);
                    ctx.fillStyle = p.color || 'rgba(0,0,0,1)';
                    const R = p.r || 10;
                    const inner = R * 0.55;
                    const spikes = p.spikes || 10;
                    ctx.beginPath();
                    for (let i=0;i<spikes;i++){
                        const ang = i * (Math.PI*2/spikes);
                        const x1 = Math.cos(ang) * inner;
                        const y1 = Math.sin(ang) * inner;
                        const x2 = Math.cos(ang + 0.08) * R;
                        const y2 = Math.sin(ang + 0.08) * R;
                        const x3 = Math.cos(ang - 0.08) * R;
                        const y3 = Math.sin(ang - 0.08) * R;
                        ctx.moveTo(x1,y1);
                        ctx.lineTo(x2,y2);
                        ctx.lineTo(x3,y3);
                        ctx.lineTo(x1,y1);
                    }
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                } else if (p.shape === 'shard') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle || 0);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-(p.w||6)/2, -(p.h||2)/2, (p.w||6), (p.h||2));
                    ctx.restore();
                } else if (p.shape === 'fachao_text') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.globalAlpha = Math.max(0, p.alpha || 1);
                    
                    // ç¼©æ”¾è„‰å†² - è®©æ–‡å­—æ„Ÿè§‰æ›´æœ‰ç”Ÿå‘½åŠ›
                    const pulse = 1 + Math.sin(Date.now()/100 + p.x)*0.15;
                    ctx.scale(pulse, pulse);
                    
                    ctx.fillStyle = p.color || '#fff';
                    // åŠ å¤§å­—ä½“ï¼Œå°è¯•ä½¿ç”¨æ¥·ä½“å¢åŠ ä¹¦å†™æ„Ÿ
                    ctx.font = `bold ${Math.round(uiSize(24))}px "KaiTi", "æ¥·ä½“", serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // æ—‹è½¬åŠ¨æ•ˆ (å‡æ…¢)
                    const rot = (Date.now()/400) % (Math.PI*2);
                    ctx.rotate(rot + (p.vx * 0.1));
                    
                    // å¼ºé˜´å½± - å¢åŠ ç«‹ä½“æ„Ÿ
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(0,0,0,0.8)';
                    ctx.fillText(p.text || 'ç½šæŠ„', 0, 0);
                    
                    // é»‘è‰²æè¾¹ - åŠ ç²—
                    ctx.shadowBlur = 0; 
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeText(p.text || 'ç½šæŠ„', 0, 0);
                    
                    ctx.restore();
                } else {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 3, 3);
                }
            });

            // ç»˜åˆ¶å°é¸Ÿï¼ˆç°åœ¨æ˜¯äººç‰©å¤´åƒï¼‰
            // (Moved to render after boss for layering)

            

            

            // ç»˜åˆ¶çŒª/Boss
            pigs.forEach(pig => {
                if (pig.health > 0 || (pig.isBoss && pig.deathFrames && pig.deathFrames > 0)) {
                    ctx.save();
                    
                    if (pig.isBoss && pig.bossType === 'boss2' && boss2ImageLoaded) {
                        const size = pig.radius * 2.6;
                        if (!pig.deathFrames) drawBossBlackFX(pig); else drawBossDeathInk(pig);
                        ctx.save();
                        ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius, 0, Math.PI*2); ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = uiSize(4); ctx.stroke();
                        const ag = ctx.createRadialGradient(pig.x, pig.y, pig.radius*0.6, pig.x, pig.y, pig.radius*2.2);
                        ag.addColorStop(0, 'rgba(0,0,0,0.5)');
                        ag.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = ag; ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius*2.2, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                        ctx.globalAlpha = pig.deathFrames ? Math.max(0.2, Math.min(1, pig.deathFrames/90)) : 1;
                         ctx.save();
                        ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius, 0, Math.PI*2); ctx.clip();
                        ctx.drawImage(boss2Image, pig.x - pig.radius*1.3, pig.y - pig.radius*1.3, size, size);
                        ctx.restore();
                        const ph = Date.now()/400;
                        const R = pig.radius*1.6 + Math.sin(ph)*4;
                        
                        
                    } else if (pig.isBoss && pig.bossType === 'boss3' && boss3ImageLoaded) {
                        const size = pig.radius * 2.6;
                        if (!pig.deathFrames) drawBossBlackFX(pig); else drawBossDeathInk(pig);
                        ctx.save();
                        ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius, 0, Math.PI*2); ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = uiSize(4); ctx.stroke();
                        const ag = ctx.createRadialGradient(pig.x, pig.y, pig.radius*0.6, pig.x, pig.y, pig.radius*2.2);
                        ag.addColorStop(0, 'rgba(0,0,0,0.5)');
                        ag.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = ag; ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius*2.2, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                        ctx.globalAlpha = pig.deathFrames ? Math.max(0.2, Math.min(1, pig.deathFrames/90)) : 1;
                        ctx.save();
                        ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius, 0, Math.PI*2); ctx.clip();
                        ctx.drawImage(boss3Image, pig.x - pig.radius*1.3, pig.y - pig.radius*1.3, size, size);
                        ctx.restore();
                        const ph = Date.now()/400;
                        const R = pig.radius*1.6 + Math.sin(ph)*4;
                        
                        
                    } else if (pig.isBoss && bossImageLoaded) {
                        const size = pig.radius * 2.5;
                        if (!pig.deathFrames) drawBossBlackFX(pig); else drawBossDeathInk(pig);
                        ctx.save();
                        ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius, 0, Math.PI*2); ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.lineWidth = uiSize(4); ctx.stroke();
                        const ag = ctx.createRadialGradient(pig.x, pig.y, pig.radius*0.6, pig.x, pig.y, pig.radius*2.2);
                        ag.addColorStop(0, 'rgba(0,0,0,0.5)');
                        ag.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = ag; ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius*2.2, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                        ctx.globalAlpha = pig.deathFrames ? Math.max(0.2, Math.min(1, pig.deathFrames/90)) : 1;
                        ctx.save();
                        ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius, 0, Math.PI*2); ctx.clip();
                        ctx.drawImage(bossImage, pig.x - pig.radius*1.25, pig.y - pig.radius*1.25, size, size);
                        ctx.restore();
                        const ph2 = Date.now()/400;
                        const R2 = pig.radius*1.6 + Math.sin(ph2)*4;
                        
                        
                    } else if (pigImageLoaded) {
                        // åˆ›å»ºä¸¥æ ¼çš„åœ†å½¢è£å‰ªåŒºåŸŸï¼Œåªæ˜¾ç¤ºçŒªçš„è½®å»“
                        if (pig.isBoss) { if (pig.deathFrames) drawBossDeathInk(pig); else drawBossBlackFX(pig); }
                        ctx.beginPath();
                        ctx.arc(pig.x, pig.y, pig.radius, 0, Math.PI * 2);
                        ctx.clip();
                        
                        // ç»˜åˆ¶çŒªå¤´åƒï¼Œè°ƒæ•´å°ºå¯¸å’Œä½ç½®ä»¥ç²¾ç¡®æ˜¾ç¤ºçŒªçš„è½®å»“
                        const size = pig.radius * 2.5; // è¿›ä¸€æ­¥æ”¾å¤§ä»¥æ›´å¥½åœ°è£å‰ª
                        ctx.drawImage(pigImage, 
                            pig.x - pig.radius * 1.25, 
                            pig.y - pig.radius * 1.25, 
                            size, 
                            size
                        );
                        
                        ctx.restore();
                        ctx.save();
                        
                        // æ·»åŠ åœ†å½¢è¾¹æ¡†ï¼Œçªå‡ºçŒªçš„è½®å»“
                        ctx.beginPath();
                        ctx.arc(pig.x, pig.y, pig.radius, 0, Math.PI * 2);
                        ctx.strokeStyle = '#4CAF50';
                        ctx.lineWidth = uiSize(3);
                        ctx.stroke();
                        if (pig.isBoss) {
                            const t = Date.now() / 1000;
                            const pulse = 1 + Math.sin(t * 3) * 0.1;
                            
                            // ç¡®ä¿ bossType å­˜åœ¨ï¼Œé»˜è®¤ä¸º boss1
                            const bType = pig.bossType || 'boss1';

                            if (bType === 'boss3') {
                                // --- Boss 3: è™šç©º/ç»ˆæ Boss (Void/Ultimate) ---
                                // é£æ ¼ï¼šæš—ç‰©è´¨ã€å¼•åŠ›æ‰­æ›²ã€ç´«é»‘è‰²è°ƒ
                                
                                // 1. è™šç©ºæ ¸å¿ƒ (Void Core) - é»‘è‰²å‘å…‰çƒä½“
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const voidG = ctx.createRadialGradient(pig.x, pig.y, pig.radius*0.8, pig.x, pig.y, pig.radius*2.5);
                                voidG.addColorStop(0, 'rgba(0,0,0,1)');
                                voidG.addColorStop(0.4, 'rgba(80,0,120,0.6)');
                                voidG.addColorStop(1, 'rgba(0,0,0,0)');
                                ctx.fillStyle = voidG;
                                ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius*2.5, 0, Math.PI*2); ctx.fill();
                                ctx.restore();

                                // 2. ç©ºé—´è£‚éš™ç²’å­ (Rift Particles) - æ±‡èšæ•ˆæœ
                                if (Math.random() < 0.6) {
                                     const ang = Math.random() * Math.PI * 2;
                                     const dist = pig.radius * (2.0 + Math.random());
                                     // å‘ä¸­å¿ƒæ±‡èšçš„ç²’å­
                                     spawnParticles(
                                         pig.x + Math.cos(ang)*dist, 
                                         pig.y + Math.sin(ang)*dist, 
                                         1, 
                                         'rgba(180,50,255,0.8)', 
                                         { style: 'streak', life: 30, w: 3, vx: -Math.cos(ang)*2, vy: -Math.sin(ang)*2 } 
                                     );
                                }

                                // 3. ä¸è§„åˆ™æš—é»‘é—ªç”µ (Dark Lightning)
                                if (Math.random() < 0.3) {
                                    ctx.save();
                                    ctx.strokeStyle = 'rgba(200,0,255,0.7)';
                                    ctx.lineWidth = 2;
                                    ctx.shadowColor = '#d0f';
                                    ctx.shadowBlur = 10;
                                    ctx.beginPath();
                                    const startAng = Math.random() * Math.PI * 2;
                                    let lx = pig.x + Math.cos(startAng) * pig.radius;
                                    let ly = pig.y + Math.sin(startAng) * pig.radius;
                                    ctx.moveTo(lx, ly);
                                    for(let i=0; i<5; i++) {
                                        lx += (Math.random()-0.5) * 40;
                                        ly += (Math.random()-0.5) * 40;
                                        ctx.lineTo(lx, ly);
                                    }
                                    ctx.stroke();
                                    ctx.restore();
                                }

                            } else if (bType === 'boss2') {
                                // --- Boss 2: æœºæ¢°/ç§‘æŠ€ Boss (Mecha/Tech) ---
                                // é£æ ¼ï¼šèµ›åšæœ‹å…‹ã€æ•…éšœè‰ºæœ¯ã€é’è‰²/çº¢è‰²è°ƒ

                                // 1. å…¨æ¯æŠ¤ç›¾ç½‘æ ¼ (Holo Grid)
                                ctx.save();
                                ctx.translate(pig.x, pig.y);
                                ctx.rotate(t * 0.2);
                                ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + Math.sin(t*10)*0.1})`;
                                ctx.lineWidth = 2;
                                const hexR = pig.radius * 1.8;
                                for (let i=0; i<6; i++) {
                                    const ang = i * Math.PI / 3;
                                    // ç»˜åˆ¶å…­è¾¹å½¢ç‰‡æ®µ
                                    ctx.beginPath();
                                    ctx.moveTo(Math.cos(ang)*hexR, Math.sin(ang)*hexR);
                                    ctx.lineTo(Math.cos(ang+Math.PI/3)*hexR, Math.sin(ang+Math.PI/3)*hexR);
                                    ctx.stroke();
                                    // è¿æ¥çº¿
                                    if (i%2===0) {
                                         ctx.beginPath();
                                         ctx.moveTo(Math.cos(ang)*hexR*0.8, Math.sin(ang)*hexR*0.8);
                                         ctx.lineTo(Math.cos(ang)*hexR, Math.sin(ang)*hexR);
                                         ctx.stroke();
                                    }
                                }
                                ctx.restore();

                                // 2. æ ¸å¿ƒè¿‡è½½è¾‰å…‰ (Core Overload)
                                ctx.save();
                                ctx.globalCompositeOperation = 'screen';
                                ctx.shadowColor = '#0ff';
                                ctx.shadowBlur = 20 * pulse;
                                ctx.strokeStyle = 'rgba(0,255,255,0.8)';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.arc(pig.x, pig.y, pig.radius * 1.1, 0, Math.PI*2);
                                ctx.stroke();
                                ctx.restore();

                                // 3. æ•…éšœç«èŠ± (Glitch Sparks)
                                if (Math.random() < 0.2) {
                                     const ang = Math.random() * Math.PI * 2;
                                     const dist = pig.radius * 1.2;
                                     spawnParticles(
                                         pig.x + Math.cos(ang)*dist, 
                                         pig.y + Math.sin(ang)*dist, 
                                         1, 
                                         Math.random() < 0.5 ? '#0ff' : '#fff', 
                                         { style: 'spark', life: 10, r: 2 } 
                                     );
                                }

                            } else {
                                // --- Boss 1: æš´åŠ›/ç¥åœ£ Boss (Divine/Power) ---
                                // é£æ ¼ï¼šé‡‘è‰²å…‰èŠ’ã€ç«ç„°ã€å¨ä¸¥

                                // 1. åœ£å…‰æ•£å°„ (God Rays)
                                ctx.save();
                                ctx.translate(pig.x, pig.y);
                                ctx.rotate(t * 0.5);
                                ctx.globalCompositeOperation = 'overlay';
                                ctx.fillStyle = 'rgba(255, 215, 0, 0.2)'; // Gold
                                for (let i=0; i<8; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    ctx.arc(0, 0, pig.radius * 4, -0.1, 0.1);
                                    ctx.fill();
                                    ctx.rotate(Math.PI / 4);
                                }
                                ctx.restore();

                                // 2. ç‡ƒçƒ§å…‰ç¯ (Burning Aura)
                                const fireG = ctx.createRadialGradient(pig.x, pig.y, pig.radius, pig.x, pig.y, pig.radius * 1.6);
                                fireG.addColorStop(0, 'rgba(255, 100, 0, 0.6)');
                                fireG.addColorStop(1, 'rgba(255, 0, 0, 0)');
                                ctx.fillStyle = fireG;
                                ctx.beginPath(); ctx.arc(pig.x, pig.y, pig.radius*1.6, 0, Math.PI*2); ctx.fill();

                                // 3. ä¸Šå‡å…‰å°˜ (Rising Embers)
                                if (Math.random() < 0.4) {
                                     const x = pig.x + (Math.random()-0.5) * pig.radius * 2;
                                     const y = pig.y + pig.radius;
                                     spawnParticles(
                                         x, y, 
                                         1, 
                                         'rgba(255, 200, 50, 0.8)', 
                                         { style: 'smoke', life: 40, r: 2 + Math.random()*3, vy: -2 - Math.random(), growth: -0.05 }
                                     );
                                }
                            }
                        }
                        
                    } else {
                        // å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œç»˜åˆ¶é»˜è®¤çš„çŒª
                        ctx.translate(pig.x, pig.y);
                        
                        // èº«ä½“ - ç»¿è‰²æ¸å˜
                        const bodyGradient = ctx.createRadialGradient(
                            0, 0, 0,
                            0, 0, pig.radius
                        );
                        bodyGradient.addColorStop(0, '#A5D6A7');
                        bodyGradient.addColorStop(1, '#4CAF50');
                        ctx.fillStyle = bodyGradient;
                        
                        ctx.beginPath();
                        ctx.arc(0, 0, pig.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // çœ¼ç›
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(-10, -5, 6, 0, Math.PI * 2);
                        ctx.arc(10, -5, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#212121';
                        ctx.beginPath();
                        ctx.arc(-10, -5, 3, 0, Math.PI * 2);
                        ctx.arc(10, -5, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // é¼»å­
                        ctx.fillStyle = '#FF8A80';
                        ctx.beginPath();
                        ctx.arc(0, 8, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }
            });

            bossTrails.forEach(t => {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = Math.max(0, t.alpha || 0.8);
                if (t.type === 'stamp') {
                    const rr = t.r || 80;
                    const g = ctx.createRadialGradient(t.x, t.y, rr*0.4, t.x, t.y, rr);
                    g.addColorStop(0, 'rgba(0,0,0,0.6)');
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(t.x, t.y, rr, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                    ctx.lineWidth = uiSize(3);
                    ctx.beginPath(); ctx.arc(t.x, t.y, rr*0.7, 0, Math.PI*2); ctx.stroke();
                } else {
                    const dx = (t.ex - t.x), dy = (t.ey - t.y);
                    const ang = Math.atan2(dy, dx);
                    const len = Math.max(10, Math.hypot(dx, dy));
                    const w = t.w || 22;
                    ctx.translate(t.x, t.y);
                    ctx.rotate(ang);
                    const darkG = ctx.createLinearGradient(0, 0, len, 0);
                    darkG.addColorStop(0, 'rgba(0,0,0,0.0)');
                    darkG.addColorStop(0.2, 'rgba(0,0,0,0.45)');
                    darkG.addColorStop(1, 'rgba(0,0,0,0.0)');
                    ctx.fillStyle = darkG;
                    ctx.beginPath();
                    ctx.moveTo(0, -w*0.5);
                    ctx.lineTo(len, -w*0.2);
                    ctx.lineTo(len, w*0.2);
                    ctx.lineTo(0, w*0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(len, 0);
                    ctx.lineTo(len - w*0.4, -w*0.3);
                    ctx.lineTo(len - w*0.4, w*0.3);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fill();
                }
                ctx.restore();
            });

            if (shadowRifts.length) {
                ctx.save();
                for (let i=0;i<shadowRifts.length;i++) {
                    const rf = shadowRifts[i];
                    const lifeRatio = Math.max(0, (rf.life || 0) / (rf.total || 1));
                    // æ·¡å…¥æ·¡å‡º
                    const alpha = Math.min(1, lifeRatio * 3) * Math.min(1, (rf.total - rf.life)*0.1); 
                    if (alpha <= 0.01) continue;

                    const rr = Math.max(40, (rf.r || 120));
                    const t = Date.now() / 1000;
                    
                    ctx.save();
                    ctx.translate(rf.x, rf.y);
                    
                    // 1. å¸ç§¯ç›˜ (Accretion Disk) - å¹½æš—çš„æµä½“
                    const layers = 4;
                    for(let L=0; L<layers; L++) {
                        ctx.save();
                        // ç¼“æ…¢æ—‹è½¬ï¼Œåˆ¶é€ æ·±é‚ƒæ„Ÿ
                        const rot = t * (0.15 + L*0.05) + (rf.seed||0) + L;
                        ctx.rotate(rot);
                        
                        // å‹æ‰æˆæ¤­åœ†
                        ctx.scale(1, 0.4 + L*0.12); 
                        
                        ctx.globalCompositeOperation = 'source-over'; // æ”¹ä¸ºè¦†ç›–ï¼Œæ›´åšé‡
                        const grad = ctx.createRadialGradient(0, 0, rr*(0.4+L*0.2), 0, 0, rr*(1.6+L*0.4));
                        const op = (0.4 - L*0.08) * alpha;
                        grad.addColorStop(0, 'rgba(0,0,0,0)');
                        grad.addColorStop(0.3, `rgba(10, 5, 15, ${op})`); // æ·±é»‘
                        grad.addColorStop(0.6, `rgba(40, 10, 60, ${op*0.5})`); // æš—ç´«å¾®å…‰
                        grad.addColorStop(1, 'rgba(0,0,0,0)');
                        
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(0, 0, rr*(2.0+L*0.5), 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    // 2. å¼•åŠ›é€é•œ (Gravitational Lensing) - å¾®å¦™çš„æ‰­æ›²å…‰åœˆ
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = `rgba(100, 80, 120, ${0.1 * alpha})`; // æš—æ·¡çš„ç´«ç°
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, rr * 1.8 + Math.sin(t*3)*3, 0, Math.PI*2);
                    ctx.stroke();

                    // 3. äº‹ä»¶è§†ç•Œ (Event Horizon) - ç»å¯¹çº¯é»‘æ ¸å¿ƒ
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.fillStyle = '#000000';
                    // åªæœ‰éå¸¸å¾®å¼±çš„æš—ç´«èƒŒå…‰
                    ctx.shadowColor = 'rgba(60, 0, 100, 0.6)';
                    ctx.shadowBlur = 20 * alpha;
                    ctx.beginPath();
                    ctx.arc(0, 0, rr * 0.42, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0; 
                    
                    // 4. å…‰å­ç¯ (Photon Ring) - æå…¶çº¤ç»†çš„æš—çº¢/æš—é‡‘å…‰åœˆ
                    ctx.strokeStyle = `rgba(180, 140, 120, ${0.6 * alpha})`; // ç±»ä¼¼æ˜Ÿé™…ç©¿è¶Šçš„é¢œè‰²
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, rr * 0.43, 0, Math.PI*2);
                    ctx.stroke();

                    // 5. åå™¬æ•ˆæœ - å¶å°”æœ‰æš—å½±è§¦é¡»è¢«å¸å…¥
                    if (frameCounter % 5 === 0) {
                         // åœ¨ draw é‡Œä¸€èˆ¬ä¸æ›´æ–°é€»è¾‘ï¼Œè¿™é‡Œåªè´Ÿè´£ç”»
                         // å¯ä»¥åœ¨ update é‡Œç”Ÿæˆè¢«å¸å…¥çš„ç²’å­
                    }

                    ctx.restore();
                }
                ctx.restore();
            }

            // ç§»é™¤ bossShockwaves æ¸²æŸ“é€»è¾‘
            // if (bossShockwaves.length) { ... }

            // --- MOVED BIRDS/EGGS/PICKUPS RENDERING HERE ---
            // ç»˜åˆ¶å°é¸Ÿï¼ˆç°åœ¨æ˜¯äººç‰©å¤´åƒï¼‰
        birds.forEach(bird => {
            if (bird.dead) return;
            if (FX_OVERDRIVE && bird.type === 'red' && bird.launched && bird.trail && bird.trail.length > 2 && fxQ >= 0.45) {
                const pts = bird.trail;
                const n = pts.length;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowBlur = uiSize(10 + 18 * fxQ);
                ctx.shadowColor = 'rgba(255,40,0,0.9)';
                const t0 = Date.now() / 90;
                const stride = fxHeavy ? 1 : (fxQ >= 0.55 ? 2 : 3);
                for (let i = 1; i < n; i += stride) {
                    const p0 = pts[i - 1], p1 = pts[i];
                    const tt = i / (n - 1);
                    const dx = p1.x - p0.x, dy = p1.y - p0.y;
                    const dl = Math.hypot(dx, dy) || 1;
                    const nx = -dy / dl, ny = dx / dl;
                    const wob = Math.sin(t0 + i * 0.55) * (uiSize((3 + 3 * fxQ) * (1 - tt)));
                    const x0 = p0.x + nx * wob, y0 = p0.y + ny * wob;
                    const x1 = p1.x + nx * wob, y1 = p1.y + ny * wob;
                    ctx.globalAlpha = (0.05 + 0.22 * (1 - tt)) * fxQ;
                    ctx.strokeStyle = `rgba(255,${90 + Math.floor(120 * tt)},${10 + Math.floor(40 * tt)},1)`;
                    ctx.lineWidth = uiSize((9 * (1 - tt) + 2) * (0.8 + 0.2 * fxQ));
                    ctx.beginPath();
                    ctx.moveTo(x0, y0);
                    ctx.lineTo(x1, y1);
                    ctx.stroke();
                    if (fxHeavy) {
                        ctx.globalAlpha = (0.05 + 0.14 * (1 - tt)) * fxQ;
                        ctx.shadowColor = 'rgba(0,220,255,0.8)';
                        ctx.strokeStyle = 'rgba(80,255,255,0.55)';
                        ctx.lineWidth = uiSize(5 * (1 - tt) + 1.2);
                        ctx.beginPath();
                        ctx.moveTo(x0 + nx * uiSize(2.2), y0 + ny * uiSize(2.2));
                        ctx.lineTo(x1 + nx * uiSize(2.2), y1 + ny * uiSize(2.2));
                        ctx.stroke();
                        ctx.shadowColor = 'rgba(255,0,120,0.8)';
                        ctx.strokeStyle = 'rgba(255,70,160,0.4)';
                        ctx.beginPath();
                        ctx.moveTo(x0 - nx * uiSize(2.2), y0 - ny * uiSize(2.2));
                        ctx.lineTo(x1 - nx * uiSize(2.2), y1 - ny * uiSize(2.2));
                        ctx.stroke();
                    }
                }
                ctx.restore();
            }
                
                // --- ç»ˆæÂ·å¼‘ç¥çº§å­å¼¹åŠ¨æ•ˆ (God-Slayer Projectile FX) - 2.0 Enhanced ---
                if (bird.launched && Math.hypot(bird.velocity.x, bird.velocity.y) > 1) {
                    const spd = Math.hypot(bird.velocity.x, bird.velocity.y);
                    const ang = Math.atan2(bird.velocity.y, bird.velocity.x);
                    
                    ctx.save();
                    ctx.translate(bird.x, bird.y);
                    ctx.rotate(ang);
                    
                    // 1. ç©ºé—´æ‰­æ›²åœº (Distortion Field) - å¢å¼ºç‰ˆ
                    const warpLen = Math.min(180, spd * 7); 
                    const warpW = bird.radius * 2.8;
                    
                    // å¤–éƒ¨æ¿€æ³¢ (Shockwave Cone)
                    const gradShock = ctx.createLinearGradient(0, 0, -warpLen, 0);
                    gradShock.addColorStop(0, 'rgba(255,255,255,0.9)');
                    gradShock.addColorStop(0.1, 'rgba(255,255,255,0.4)');
                    gradShock.addColorStop(1, 'rgba(255,255,255,0)');
                    
                    ctx.fillStyle = gradShock;
                    ctx.beginPath();
                    ctx.moveTo(bird.radius, 0);
                    ctx.lineTo(-warpLen, -warpW);
                    ctx.quadraticCurveTo(-warpLen - 20, 0, -warpLen, warpW);
                    ctx.lineTo(bird.radius, 0);
                    ctx.closePath();
                    ctx.globalCompositeOperation = 'overlay';
                    ctx.fill();

                    // 2. æ ¸å¿ƒé«˜èƒ½ç²’å­æµ (High Energy Particle Stream)
                    ctx.globalCompositeOperation = 'lighter'; // å‘å…‰å åŠ æ¨¡å¼
                    
                    // å·®å¼‚åŒ–çš„é«˜èƒ½ç²’å­æµ (Type-Specific Particle Stream)
                    if (bird.type === 'yellow') {
                        // é»„é¸Ÿ (Chuck): æé€Ÿé›·éœ† (Velocity Thunder)
                        
                        // 1. é›·åˆ‡å…‰æŸ (Laser Cutter)
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(bird.radius, 0);
                        ctx.lineTo(-warpLen * 1.2, -2);
                        ctx.lineTo(-warpLen * 1.2, 2);
                        ctx.fill();

                        // 2. ç‹‚æš´ç”µå¼§ (Wild Arcs)
                        ctx.strokeStyle = '#FFF59D';
                        ctx.lineWidth = 3;
                        ctx.shadowColor = '#FFEB3B';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        for (let j=0; j<3; j++) {
                             ctx.moveTo(0, 0);
                             let lx = 0, ly = 0;
                             for (let i = 0; i < 8; i++) {
                                 lx -= 15 + Math.random() * 20;
                                 ly += (Math.random() - 0.5) * 20;
                                 ctx.lineTo(lx, ly);
                             }
                        }
                        ctx.stroke();
                        
                        // 3. éŸ³çˆ†ç¯ (Sonic Rings)
                        if (frameCounter % 5 === 0) {
                            ctx.beginPath();
                            ctx.ellipse(-20, 0, 10, 30, 0, 0, Math.PI*2);
                            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }

                    } else if (bird.type === 'black') {
                        // é»‘é¸Ÿ (Bomb): æ¯ç­å¥‡ç‚¹ (Doom Singularity) - ç»ˆæé‡åš
                        const time = Date.now() / 1000;
                        const scale = 1.0 + Math.sin(time * 3) * 0.1;
                        
                        // 1. å¼•åŠ›é€é•œæ‰­æ›²åœº (Gravitational Lensing Distortion Field)
                        // æ¨¡æ‹Ÿå…‰çº¿è¢«å¼•åŠ›å¼¯æ›²
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.lineWidth = 2;
                        for(let i=0; i<3; i++) {
                            const r = bird.radius * (2.5 + i*0.8) + Math.sin(time*5 + i)*5;
                            ctx.strokeStyle = `rgba(100, 100, 120, ${0.15 - i*0.04})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, r, 0, Math.PI*2);
                            ctx.stroke();
                        }
                        ctx.restore();

                        // 2. æ¹æµå¸ç§¯ç›˜ (Turbulent Accretion Disk)
                        // ä½¿ç”¨é«˜é¢‘å™ªç‚¹çº¿æ¡æ¨¡æ‹Ÿç‰©è´¨æµ
                        ctx.save();
                        const diskR = bird.radius * 3.5;
                        const segments = 40;
                        for(let i=0; i<segments; i++) {
                            const ang = time * 2 + i * (Math.PI*2/segments);
                            const dist = bird.radius * (1.2 + Math.random() * 2.0);
                            const len = 10 + Math.random() * 30;
                            
                            // å¤šæ™®å‹’æ•ˆåº”æ¨¡æ‹Ÿï¼šé è¿‘è§‚å¯Ÿè€…(å‡è®¾å³ä¾§)æ›´äº®ï¼Œè¿œç¦»æ›´æš—
                            // ç®€åŒ–ä¸ºæ—‹è½¬è§’åº¦ç›¸å…³çš„äº®åº¦
                            const brightness = 0.3 + 0.7 * Math.abs(Math.cos(ang)); 
                            
                            ctx.strokeStyle = `rgba(50, 20, 80, ${0.6 * brightness})`;
                            ctx.lineWidth = 2 + Math.random()*2;
                            ctx.beginPath();
                            ctx.arc(0, 0, dist, ang, ang + len/dist); // ç”¨å¼§çº¿ä»£æ›¿ç›´çº¿
                            ctx.stroke();
                        }
                        ctx.restore();

                        // 3. ç›¸å¯¹è®ºæ€§å–·æµ (Relativistic Jets)
                        // å‚ç›´äºè¿åŠ¨æ–¹å‘ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºå‘åæ‹–å°¾ï¼Œå› ä¸ºè¿™æ˜¯æŠ›å°„ç‰©ï¼‰
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        const jetLen = 120;
                        const gradJet = ctx.createLinearGradient(0, 0, -jetLen, 0);
                        gradJet.addColorStop(0, 'rgba(0, 0, 0, 0.9)'); // å–·æµæ ¹éƒ¨æ˜¯é»‘è‰²çš„
                        gradJet.addColorStop(0.2, 'rgba(80, 0, 120, 0.6)'); // ä¸­æ®µæš—ç´«
                        gradJet.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        
                        // ä¸»å–·æµ
                        ctx.fillStyle = gradJet;
                        ctx.beginPath();
                        ctx.moveTo(0, -5);
                        ctx.lineTo(-jetLen, -15);
                        ctx.lineTo(-jetLen, 15);
                        ctx.lineTo(0, 5);
                        ctx.fill();
                        
                        // å–·æµæ¿€æ³¢
                        ctx.strokeStyle = 'rgba(150, 50, 200, 0.4)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-jetLen * 0.8, -10);
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-jetLen * 0.8, 10);
                        ctx.stroke();
                        ctx.restore();

                        // 4. äº‹ä»¶è§†ç•Œ (Event Horizon) - ç»å¯¹é»‘ä½“
                        ctx.save();
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.fillStyle = '#000000';
                        ctx.shadowColor = 'rgba(100, 0, 150, 0.8)'; // æš—ç´«å¾®å…‰èƒŒå…‰
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(0, 0, bird.radius * 0.95 * scale, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 5. å…‰å­çƒ (Photon Sphere) - è§†ç•Œè¾¹ç¼˜çš„é”åˆ©å…‰åœˆ
                        ctx.shadowBlur = 0;
                        ctx.strokeStyle = 'rgba(200, 150, 100, 0.7)'; // ç»å…¸çš„æ˜Ÿé™…ç©¿è¶Šæ©™é‡‘è‰²
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, bird.radius * 0.98 * scale, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                        
                        // 6. éœé‡‘è¾å°„/é‡å­è’¸å‘ (Hawking Radiation)
                        // å¶å°”é€¸å‡ºçš„å¾®å°ç²’å­
                        if (Math.random() < 0.3) {
                             // è¿™é‡Œåªæ˜¯è£…é¥°æ€§ç»˜åˆ¶ï¼Œä¸äº§ç”ŸæŒä¹…ç²’å­å¯¹è±¡
                             ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                             const rAngle = Math.random() * Math.PI * 2;
                             const rDist = bird.radius * 1.1;
                             ctx.fillRect(Math.cos(rAngle)*rDist, Math.sin(rAngle)*rDist, 1.5, 1.5);
                        }

                    } else if (bird.type === 'blue') {
                        // è“é¸Ÿ (Blues): ç»å¯¹é›¶åº¦ (Absolute Zero)
                        const time = Date.now() / 300;
                        
                        // 1. å†°æ™¶å°¾è¿¹ (Crystal Trail)
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                        for(let i=0; i<5; i++) {
                            const lag = i * 20;
                            const w = bird.radius * (1 - i/5);
                            ctx.fillRect(-lag*2, -w, lag, w*2);
                        }

                        // 2. æ—‹è½¬é›ªèŠ± (Rotating Snowflakes)
                        ctx.strokeStyle = '#E0F7FA';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const sides = 6;
                        const r = bird.radius * 1.8;
                        for (let i = 0; i <= sides; i++) {
                            const ang = i * (Math.PI * 2 / sides) + time;
                            const x = Math.cos(ang) * r;
                            const y = Math.sin(ang) * r;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        
                        // 3. å¯’æ°” (Frost Mist)
                        const gradMist = ctx.createRadialGradient(0,0,0, 0,0,bird.radius*4);
                        gradMist.addColorStop(0, 'rgba(200,255,255,0.4)');
                        gradMist.addColorStop(1, 'rgba(0,0,255,0)');
                        ctx.fillStyle = gradMist;
                        ctx.fill();

                    } else if (bird.type === 'green') {
                        const tq = fxQ;
                        const time = Date.now() / 1000;
                        const step = tq >= 0.75 ? 6 : (tq >= 0.55 ? 8 : 12);
                        const layers = tq >= 0.75 ? 3 : 2;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.shadowBlur = uiSize(10 + 12 * tq);
                        for (let k = 0; k < layers; k++) {
                            const tt = time * (3.2 + k * 0.9);
                            const amp0 = bird.radius * (1.1 + 0.9 * tq) * (1 + k * 0.22);
                            ctx.beginPath();
                            for (let x = 0; x <= warpLen; x += step) {
                                const t1 = x / Math.max(1, warpLen);
                                const env = (0.25 + 0.85 * t1);
                                const wob = Math.sin(tt - x * (0.10 + 0.02 * k)) * amp0 * env;
                                const wob2 = Math.sin(tt * 0.65 + x * 0.16) * amp0 * env * 0.35;
                                ctx.lineTo(-x, wob + wob2);
                            }
                            ctx.strokeStyle = k === 0 ? 'rgba(105,240,174,0.85)' : (k === 1 ? 'rgba(185,246,202,0.55)' : 'rgba(80,255,210,0.35)');
                            ctx.shadowColor = k === 0 ? 'rgba(0,200,120,0.75)' : 'rgba(0,255,180,0.45)';
                            ctx.lineWidth = uiSize((3.2 - k * 0.7) * (0.9 + 0.4 * tq));
                            ctx.stroke();
                        }
                        if (tq >= 0.55) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'screen';
                            const br = bird.radius * (2.4 + 0.9 * tq);
                            ctx.globalAlpha = 0.20 + 0.18 * tq;
                            const gB = ctx.createRadialGradient(-bird.radius*0.2, 0, 0, -bird.radius*0.2, 0, br);
                            gB.addColorStop(0, 'rgba(255,255,255,0.20)');
                            gB.addColorStop(0.35, 'rgba(105,240,174,0.35)');
                            gB.addColorStop(0.7, 'rgba(0,200,120,0.20)');
                            gB.addColorStop(1, 'rgba(0,255,180,0)');
                            ctx.fillStyle = gB;
                            ctx.beginPath();
                            ctx.ellipse(-bird.radius*0.25, 0, br * 0.75, br * 0.35, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }

                    } else if (bird.type === 'white') {
                        // ç™½é¸Ÿ (Matilda): å¤©å›½é™ä¸´ (Heaven's Descent)
                        const time = Date.now() / 200;
                        
                        // 1. ç‚½å¤©ä½¿ä¹‹ç¿¼ (Seraphim Wings)
                        ctx.fillStyle = 'rgba(255, 255, 220, 0.5)';
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 15;
                        
                        const wingLen = bird.radius * 4;
                        const wingW = bird.radius * 2;
                        
                        // Top Wing
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(-wingLen/2, -wingW*1.5, -wingLen, -wingW);
                        ctx.quadraticCurveTo(-wingLen*0.8, 0, 0, 0);
                        ctx.fill();
                        
                        // Bottom Wing
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(-wingLen/2, wingW*1.5, -wingLen, wingW);
                        ctx.quadraticCurveTo(-wingLen*0.8, 0, 0, 0);
                        ctx.fill();

                        // 2. åœ£å…‰å…‰æ™• (Holy Halo)
                        const gradHalo = ctx.createRadialGradient(0,0,0, 0,0,bird.radius*2.5);
                        gradHalo.addColorStop(0, 'rgba(255,255,255,0.8)');
                        gradHalo.addColorStop(1, 'rgba(255,215,0,0)');
                        ctx.fillStyle = gradHalo;
                        ctx.beginPath();
                        ctx.arc(0,0, bird.radius*2.5, 0, Math.PI*2);
                        ctx.fill();

                    } else {
                        // çº¢é¸Ÿ (Red): æ„¤æ€’ä¹‹ç« (Rage Fire) - Reverted & Enhanced
                        // èºæ—‹èƒ½é‡æµ (Spiral Energy Stream) - é‡åˆ¶åŠ å¼ºç‰ˆ
                        const qFxRed = fxQ;
                        const streamCount = FX_OVERDRIVE ? Math.max(5, Math.round(6 + 4 * fxQ)) : (qFxRed >= 0.8 ? 6 : (qFxRed >= 0.62 ? 5 : 4));
                        const tc = '#FF3333';
                        for(let k=0; k<streamCount; k++) {
                            const phase = Date.now()/1000 * 4 + k * (Math.PI*2/streamCount);
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            
                            const waveLen = warpLen * 1.2;
                            for(let x=0; x<waveLen; x+=5) {
                                // å¢åŠ æŒ¯å¹…å’Œé¢‘ç‡ï¼Œä½¿çº¿æ¡æ›´å…·åŠ¨æ„Ÿ
                                const amp = (x/waveLen) * bird.radius * (3.5 + Math.sin(phase)*1.5) * Math.sin(x*0.15 - Date.now()/1000*5 + phase);
                                ctx.lineTo(-x, amp);
                            }
                            
                            ctx.strokeStyle = tc;
                            ctx.lineWidth = 4.5 - k*0.5; // åŠ ç²—çº¿æ¡
                            ctx.shadowBlur = 20; // å¢å¼ºå‘å…‰
                            ctx.shadowColor = '#FF0000';
                            ctx.stroke();
                        }
                        // æ ¸å¿ƒæ€’ç« (Core Rage)
                        ctx.fillStyle = 'rgba(255, 50, 0, 0.35)';
                        ctx.beginPath();
                        ctx.arc(0, 0, bird.radius * 2.2, 0, Math.PI*2);
                        ctx.fill();
                        if (fxHeavy || qFxRed >= 0.72) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            const tt = Date.now() / 1000;
                            const crown = FX_OVERDRIVE ? Math.max(10, Math.round(10 + 8 * fxQ)) : Math.max(6, Math.round(10 * qFxRed));
                            for (let i = 0; i < crown; i++) {
                                const a = tt * 2.2 + i * (Math.PI * 2 / crown);
                                const rr = bird.radius * (2.2 + 0.25 * Math.sin(tt * 6 + i));
                                const w = bird.radius * (0.55 + 0.15 * Math.sin(tt * 7 + i * 1.3));
                                ctx.beginPath();
                                ctx.moveTo(Math.cos(a) * rr, Math.sin(a) * rr);
                                ctx.quadraticCurveTo(
                                    Math.cos(a) * (rr + w * 0.9),
                                    Math.sin(a) * (rr + w * 0.9),
                                    Math.cos(a) * (rr + w * 1.8),
                                    Math.sin(a) * (rr + w * 1.8)
                                );
                                ctx.strokeStyle = `rgba(255,${120 + Math.floor(80 * Math.sin(tt * 2 + i))},0,${FX_OVERDRIVE ? 0.55 : 0.35})`;
                                ctx.lineWidth = FX_OVERDRIVE ? 3.0 : 2.2;
                                ctx.shadowBlur = FX_OVERDRIVE ? 34 : 24;
                                ctx.shadowColor = 'rgba(255,40,0,0.95)';
                                ctx.stroke();
                            }
                            ctx.restore();
                        }
                    }

                    // 3. é€šç”¨æ¿€æ³¢ç¯ (Universal Shock Ring) - å¢å¼ºç‰ˆ
                    const ringR = bird.radius * 1.4;
                    ctx.strokeStyle = 'rgba(255,255,255,0.95)';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringR, -0.6, 0.6);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, 0, ringR, Math.PI-0.6, Math.PI+0.6);
                    ctx.stroke();
                    
                    // 4. å…¨å±€ç²’å­æ‹–å°¾å¢å¼º (Global Heavy Particle Trail)
                    if (Math.random() < 0.8) { // High frequency
                        ctx.fillStyle = '#FFF';
                        const px = -Math.random() * warpLen * 0.5;
                        const py = (Math.random() - 0.5) * bird.radius * 2;
                        const ps = Math.random() * 3 + 1;
                        ctx.globalAlpha = Math.random() * 0.8;
                        ctx.beginPath();
                        ctx.arc(px, py, ps, 0, Math.PI*2);
                        ctx.fill();
                    }

                    ctx.restore();
                }

                // åŸå§‹è½¨è¿¹ç‚¹ (ä¿ç•™ä½†ç¾åŒ–)
                if (bird.trail && bird.trail.length) {
                    if (bird.type === 'red' && bird.trail.length > 3) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        ctx.moveTo(bird.trail[0].x, bird.trail[0].y);
                        for (let i = 1; i < bird.trail.length; i += 2) {
                            const pt = bird.trail[i];
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.strokeStyle = 'rgba(255,60,0,0.25)';
                        ctx.lineWidth = uiSize(14);
                        ctx.shadowBlur = uiSize(18);
                        ctx.shadowColor = 'rgba(255,40,0,0.9)';
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(bird.trail[0].x, bird.trail[0].y);
                        for (let i = 1; i < bird.trail.length; i += 2) {
                            const pt = bird.trail[i];
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.strokeStyle = 'rgba(255,210,120,0.18)';
                        ctx.lineWidth = uiSize(7);
                        ctx.shadowBlur = uiSize(12);
                        ctx.shadowColor = 'rgba(255,180,80,0.9)';
                        ctx.stroke();
                        ctx.restore();
                    }
                    const typeColor = bird.type === 'blue' ? 'rgba(30,144,255,0.8)' : bird.type === 'yellow' ? 'rgba(255,215,0,0.8)' : bird.type === 'black' ? 'rgba(100,100,100,0.8)' : bird.type === 'green' ? 'rgba(50,205,50,0.8)' : 'rgba(255,80,80,0.8)';
                    ctx.fillStyle = typeColor;
                    for (let i = 0; i < bird.trail.length; i += 2) {
                        const t = bird.trail[i];
                        const age = (bird.trail.length - i) / bird.trail.length; // 1 at head, 0 at tail
                        const r = 3 * age;
                        ctx.globalAlpha = age * 0.6;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, r, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                }
                // ... ä¿æŒåŸæœ‰æ‹–æ‹½çº¿é€»è¾‘ ...
                if (bird.dragging && bird.dragPath && bird.dragPath.length) {
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    for (let i = 0; i < bird.dragPath.length; i += 2) {
                        const p = bird.dragPath[i];
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
                        ctx.fill();
                    }
                    const pull = Math.min(1, Math.hypot(bird.x - slingshot.x, bird.y - slingshot.y) / 120);
                    ctx.strokeStyle = `rgba(255,213,79,${0.4 + 0.4 * pull})`;
                    ctx.lineWidth = uiSize(2 + 3 * pull);
                    ctx.beginPath();
                    ctx.arc(bird.x, bird.y, (bird.radius || 20) + 6 * pull, 0, Math.PI * 2);
                    ctx.stroke();
                }
                if (bird.type === 'yellow' && bird.launched) {
                    const ang = Math.atan2(bird.velocity.y, bird.velocity.x);
                    const fx = bird.x - Math.cos(ang) * (bird.radius + 6);
                    const fy = bird.y - Math.sin(ang) * (bird.radius + 6);
                    const rr = uiSize(12);
                    const grad = ctx.createRadialGradient(fx, fy, 0, fx, fy, rr);
                    grad.addColorStop(0,'rgba(255,200,0,0.9)');
                    grad.addColorStop(1,'rgba(255,69,0,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(fx, fy, rr, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.save();
                
                if (imageLoaded) {
                    // --- å¢å¼ºç‰ˆå°é¸Ÿå‘å…‰ç‰¹æ•ˆ (Super Glow) ---
                    ctx.save();
                    const speed = Math.hypot(bird.velocity.x, bird.velocity.y);
                    const isMoving = speed > 1;
                    const glowColors = { yellow:'#FFD700', black:'#FF0000', blue:'#00BFFF', white:'#FFFFFF', orange:'#FFA500', green:'#32CD32', red:'#FF4500' };
                    const glowColor = glowColors[bird.type] || '#FF4500';
                    
                    if (isMoving || bird.inSlingshot) {
                        ctx.shadowBlur = uiSize(20 + (speed));
                        ctx.shadowColor = glowColor;
                        // é¢å¤–çš„å…‰æ™•å±‚
                        ctx.fillStyle = glowColor;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(bird.x, bird.y, bird.radius * 1.5, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // é«˜é€Ÿæ—¶çš„â€œéŸ³çˆ†â€æ•ˆæœ (Mach Cone)
                    if (speed > 12) {
                         const ang = Math.atan2(bird.velocity.y, bird.velocity.x);
                         ctx.save();
                         ctx.translate(bird.x, bird.y);
                         ctx.rotate(ang);
                         // å†²å‡»æ³¢
                         ctx.fillStyle = `rgba(255,255,255,${Math.min(0.5, speed/40)})`;
                         ctx.beginPath();
                         ctx.moveTo(0, -bird.radius);
                         ctx.quadraticCurveTo(-bird.radius*6, 0, 0, bird.radius);
                         ctx.fill();
                         // ä¾§ç¿¼æµå…‰
                         ctx.strokeStyle = glowColor;
                         ctx.lineWidth = 2;
                         ctx.beginPath();
                         ctx.moveTo(0, -bird.radius);
                         ctx.lineTo(-bird.radius*4, -bird.radius*2);
                         ctx.moveTo(0, bird.radius);
                         ctx.lineTo(-bird.radius*4, bird.radius*2);
                         ctx.stroke();
                         ctx.restore();
                    }
                    ctx.restore();

                    // ç»˜åˆ¶äººç‰©å¤´åƒ
                    ctx.beginPath();
                    ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2);
                    ctx.clip(); // åˆ›å»ºåœ†å½¢è£å‰ªåŒºåŸŸ
                    
                    // ç»˜åˆ¶å¤´åƒå›¾ç‰‡ï¼Œä¿æŒåœ†å½¢
                    const size = bird.radius * 2;
                    ctx.drawImage(headImage, 
                        bird.x - bird.radius, 
                        bird.y - bird.radius, 
                        size, 
                        size
                    );
                    
                    ctx.restore();
                    ctx.save();
                    
                    
                    ctx.beginPath();
                    ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2);
                    const borderMap = { red: '#8B4513', blue: '#1E88E5', yellow: '#FBC02D', black: '#212121', green: '#4CAF50' };
                    const borderColor = borderMap[bird.type || 'red'] || '#8B4513';
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = uiSize(3);
                    ctx.stroke();

                    if (ringTheme) {
                        const rc = ringTheme === 'festival' ? '#FF4081' : ringTheme === 'space' ? '#00BCD4' : '#FFD54F';
                        ctx.strokeStyle = rc;
                        if (ringTheme === 'pixel') ctx.setLineDash([6,4]); else ctx.setLineDash([]);
                        ctx.lineWidth = uiSize(6);
                        ctx.beginPath();
                        ctx.arc(bird.x, bird.y, bird.radius + 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = uiSize(4);
                    ctx.beginPath();
                    ctx.moveTo(bird.x - bird.radius*0.8, bird.y - bird.radius*0.6);
                    ctx.lineTo(bird.x - bird.radius*0.2, bird.y - bird.radius*0.8);
                    ctx.moveTo(bird.x + bird.radius*0.8, bird.y - bird.radius*0.6);
                    ctx.lineTo(bird.x + bird.radius*0.2, bird.y - bird.radius*0.8);
                    ctx.stroke();

                    const effects = [
                        { key: 'shield', color: '#00BCD4', label: 'D', max: 600 },
                        { key: 'blast', color: '#F44336', label: 'B', max: 600 },
                        { key: 'magnet', color: '#FFC107', label: 'M', max: 600 },
                        { key: 'spinDriveFrames', color: '#4CAF50', label: 'S', max: 240 }
                    ];
                    let offsetY = -bird.radius - 20;
                    effects.forEach(eff => {
                        if (bird[eff.key]) {
                            const frac = Math.max(0, Math.min(1, bird[eff.key] / eff.max));
                            ctx.fillStyle = eff.color;
                            ctx.fillRect(bird.x + bird.radius + 8, bird.y + offsetY, 40 * frac, 6);
                            ctx.strokeStyle = '#333';
                            ctx.strokeRect(bird.x + bird.radius + 8, bird.y + offsetY, 40, 6);
                            ctx.fillStyle = '#fff';
                            ctx.font = '10px sans-serif';
                            ctx.fillText(eff.label, bird.x + bird.radius + 52, bird.y + offsetY + 6);
                            offsetY += 10;
                        }
                    });
                
                } else {
                    // å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œç»˜åˆ¶é»˜è®¤çš„å°é¸Ÿ
                    ctx.translate(bird.x, bird.y);
                    
                    const typeColor = bird.type === 'blue' ? ['#33A1FF','#0069C0'] : bird.type === 'yellow' ? ['#FFD54F','#FBC02D'] : bird.type === 'black' ? ['#616161','#212121'] : bird.type === 'green' ? ['#4CAF50','#2E7D32'] : ['#FF3333','#CC0000'];
                    const bodyGradient = ctx.createRadialGradient(
                        0, 0, 0,
                        0, 0, bird.radius
                    );
                    bodyGradient.addColorStop(0, typeColor[0]);
                    bodyGradient.addColorStop(1, typeColor[1]);
                    ctx.fillStyle = bodyGradient;
                    
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bird.radius, bird.radius*0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // çœ¼ç›
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-8, -8, 5, 0, Math.PI * 2);
                    ctx.arc(8, -8, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-8, -8, 2, 0, Math.PI * 2);
                    ctx.arc(8, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // çœ‰æ¯›
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-12, -12);
                    ctx.quadraticCurveTo(0, -15, 12, -12);
                    ctx.stroke();
                    
                    // é¸Ÿå˜´
                    ctx.fillStyle = '#FF9900';
                    ctx.beginPath();
                    ctx.moveTo(0, 5);
                    ctx.lineTo(15, 0);
                    ctx.lineTo(0, -5);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            });

            eggs.forEach(egg => {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(egg.x, egg.y, egg.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#FDD835';
                ctx.beginPath();
                ctx.arc(egg.x, egg.y-egg.radius/2, egg.radius/3, 0, Math.PI*2);
                ctx.fill();
            });

            pickups.forEach(pk => {
                ctx.save();
                ctx.translate(pk.x, pk.y);
                ctx.fillStyle = pk.type === 'speed' ? '#FF7043' : pk.type === 'size' ? '#42A5F5' : pk.type === 'ammo' ? '#66BB6A' : pk.type === 'shield' ? '#00BCD4' : pk.type === 'blast' ? '#F44336' : '#FFC107';
                ctx.beginPath();
                ctx.arc(0,0,10,0,Math.PI*2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = '12px sans-serif';
                const label = pk.type === 'speed' ? 'S' : pk.type === 'size' ? 'R' : pk.type === 'ammo' ? '+' : pk.type === 'shield' ? 'D' : pk.type === 'blast' ? 'B' : 'M';
                ctx.fillText(label, -4, 4);
                ctx.restore();
            });

        ctx.restore();
        ctx.save();
        const bossPig = pigs.find(p=>p.isBoss);
        if (bossPig) {
            const mh = bossPig.maxHealth || 2;
            const targetFrac = Math.max(0, Math.min(1, (bossPig.health||mh) / mh));
            bossUi.displayFrac = (bossUi.displayFrac===undefined ? targetFrac : bossUi.displayFrac);
            bossUi.displayFrac += (targetFrac - bossUi.displayFrac) * 0.25;
            const barW = Math.round(canvas.width * 0.6);
            const barH = Math.max(18, Math.round(canvas.height * 0.03));
            const bx = Math.round((canvas.width - barW) / 2);
            const by = 16;
            const pulseK = bossUi.pulse && bossUi.pulse > 0 ? (1 + Math.min(0.12, bossUi.pulse * 0.01)) : 1;
            const drawH = Math.round(barH * pulseK);
            const y0 = by - Math.round((drawH - barH) / 2);
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(bx, y0, barW, drawH);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(bx, y0, barW, drawH);
            const fillC = (bossUi.flash && bossUi.flash % 2 === 1) ? '#FF5252' : '#D32F2F';
            ctx.fillStyle = fillC;
            ctx.fillRect(bx, y0, Math.round(barW * bossUi.displayFrac), drawH);
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `${Math.round(Math.max(16, barH*0.6))}px sans-serif`;
            ctx.fillText(`${Math.round(targetFrac*100)}%`, bx + barW/2, y0 + drawH/2);
            if (bossUi.flash && bossUi.flash > 0) bossUi.flash--;
            if (bossUi.pulse && bossUi.pulse > 0) bossUi.pulse--;
        }
        if (summonLabels && summonLabels.length) {
            const s = cameraScale || 1;
            const vx = cameraX, vy = cameraY;
            summonLabels.forEach(sl => {
                const alpha = Math.max(0, sl.life / (sl.total || sl.life || 24));
                const size = Math.round(Math.max(uiSize(28), sl.size || uiSize(34)));
                const sx = (sl.x - vx) * s;
                const sy = (sl.y - vy) * s;
                ctx.save();
                ctx.translate(sx, sy);
                ctx.globalAlpha = Math.max(0, 0.70 * alpha);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${size}px Microsoft YaHei, system-ui, sans-serif`;
                ctx.strokeStyle = 'rgba(255,255,255,0.95)';
                ctx.lineWidth = Math.max(1, uiSize(2));
                ctx.strokeText('ç½šæŠ„', 0, 0);
                ctx.fillStyle = 'rgba(0,0,0,0.95)';
                ctx.fillText('ç½šæŠ„', 0, 0);
                ctx.restore();
            });
        }

        // riftLabels rendering removed (replaced by new integrated UI in shadowRifts)
        
        if (victoryFrames && victoryFrames > 0) {
            const vf = victoryFrames;
            const alpha = Math.max(0, Math.min(1, vf / 160));
            ctx.fillStyle = `rgba(0,0,0,${0.42 * alpha})`;
            ctx.fillRect(0,0,canvas.width,canvas.height);
            if (bossFinale && bossFinale.frames > 0) {
                const bx = Math.max(0, Math.min(canvas.width, (bossFinale.x - cameraX) * (cameraScale||1)));
                const by = Math.max(0, Math.min(canvas.height, (bossFinale.y - cameraY) * (cameraScale||1)));
                drawBossFinale(bx, by, alpha);
                if (bossDeathFx && bossDeathFx.flash && bossDeathFx.flash > 0) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'difference';
                    ctx.globalAlpha = Math.min(1, bossDeathFx.flash / 18);
                    ctx.fillStyle = 'rgba(255,255,255,1)';
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                    ctx.restore();
                    bossDeathFx.flash--;
                }
                bossFinale.frames--;
                if (bossFinale.frames <= 0) {
                    bossFinaleBurst = { x: bossFinale.x, y: bossFinale.y, frames: 36 };
                    bossFinale = null;
                }
            }
            if (bossFinaleBurst && bossFinaleBurst.frames > 0) {
                const bx = Math.max(0, Math.min(canvas.width, (bossFinaleBurst.x - cameraX) * (cameraScale||1)));
                const by = Math.max(0, Math.min(canvas.height, (bossFinaleBurst.y - cameraY) * (cameraScale||1)));
                drawBossFinaleBurst(bx, by, alpha);
                bossFinaleBurst.frames--;
                if (bossFinaleBurst.frames <= 0) { bossFinaleCollapse = { x: bossFinaleBurst.x, y: bossFinaleBurst.y, frames: 30 }; bossFinaleBurst = null; }
            }
            if (bossFinaleCollapse && bossFinaleCollapse.frames > 0) {
                const bx = Math.max(0, Math.min(canvas.width, (bossFinaleCollapse.x - cameraX) * (cameraScale||1)));
                const by = Math.max(0, Math.min(canvas.height, (bossFinaleCollapse.y - cameraY) * (cameraScale||1)));
                drawBossFinaleCollapse(bx, by, alpha);
                bossFinaleCollapse.frames--;
                if (bossFinaleCollapse.frames <= 0) bossFinaleCollapse = null;
            }
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `${Math.round(64)}px sans-serif`;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.shadowColor = 'rgba(213,0,0,0.7)';
            ctx.shadowBlur = 16;
            ctx.strokeText('bosså·²è¢«å‡»è´¥', canvas.width/2, canvas.height/2);
            ctx.fillStyle = '#D50000';
            ctx.fillText('bosså·²è¢«å‡»è´¥', canvas.width/2, canvas.height/2);
            ctx.restore();
            victoryFrames--;
        }
        ctx.restore();
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(20, 80, 140, 12);
            ctx.fillStyle = '#FFD54F';
            const cbw = Math.max(0, Math.min(140, (comboMultiplier - 1) / 6 * 140));
            ctx.fillRect(20, 80, cbw, 12);
            ctx.strokeStyle = '#ffffff';
            ctx.strokeRect(20, 80, 140, 12);
            ctx.font = `${Math.round(12)}px sans-serif`;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`Combo ${comboMultiplier.toFixed(2)}x`, 24, 74);
            ctx.restore();
            if (introHintFrames > 0) {
                introHintFrames--;
                const s = cameraScale || 1;
                const vx = cameraX, vy = cameraY, vw = canvas.width / s, vh = canvas.height / s;
                const pigsAlive = pigs.filter(p=>p.health>0);
                if (pigsAlive.length) {
                    const wcx = vx + vw/2, wcy = vy + vh/2;
                    pigsAlive.sort((a,b)=>Math.hypot(a.x-wcx,a.y-wcy)-Math.hypot(b.x-wcx,b.y-wcy));
                    const tp = pigsAlive[0];
                    const visible = (tp.x >= vx && tp.x <= vx+vw && tp.y >= vy && tp.y <= vy+vh);
                    if (!visible) {
                        const dx = tp.x - wcx, dy = tp.y - wcy;
                        ctx.save();
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.font = `${Math.round(14)}px sans-serif`;
                        let ax = canvas.width-24, ay = canvas.height/2; let ang = 0;
                        if (Math.abs(dx) > Math.abs(dy)) {
                            if (dx > 0) { ax = canvas.width-24; ay = canvas.height/2; ang = 0; }
                            else { ax = 24; ay = canvas.height/2; ang = Math.PI; }
                        } else {
                            if (dy > 0) { ax = canvas.width/2; ay = canvas.height-24; ang = Math.PI/2; }
                            else { ax = canvas.width/2; ay = 24; ang = -Math.PI/2; }
                        }
                        ctx.translate(ax, ay);
                        ctx.rotate(ang);
                        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-14,-8); ctx.lineTo(-14,8); ctx.closePath(); ctx.fill();
                        ctx.restore();
                    }
                }
            }
            if (bossIntroFrames > 0 && bossIntroInfo) {
                const total = 120;
                const prog = Math.max(0, Math.min(1, 1 - bossIntroFrames / total));
                const alpha = prog < 0.2 ? prog / 0.2 : prog > 0.85 ? (1 - (prog - 0.85) / 0.15) : 1;
                const lvl2 = currentLevel === 2;
                const lvl3 = currentLevel === 3;
                const theme = (currentLevel === 4) ? 'blue' : (currentLevel === 3 ? 'purple' : 'red');
                const blueTheme = theme === 'blue';
                ctx.save();
                ctx.setTransform(1,0,0,1,0,0);
                const cxw = canvas.width/2, cyw = canvas.height/2;
                const vg = ctx.createRadialGradient(cxw, cyw, 0, cxw, cyw, Math.max(canvas.width, canvas.height)*0.7);
                const bg0 = blueTheme ? `rgba(0,24,60,${0.65*alpha})` : (theme === 'purple' ? `rgba(72,0,96,${0.65*alpha})` : `rgba(90,0,0,${0.65*alpha})`);
                const bg1 = blueTheme ? `rgba(0,0,20,${0.92*alpha})` : (theme === 'purple' ? `rgba(10,0,18,${0.92*alpha})` : `rgba(0,0,0,${0.92*alpha})`);
                vg.addColorStop(0, bg0);
                vg.addColorStop(1, bg1);
                ctx.fillStyle = vg;
                ctx.fillRect(0,0,canvas.width,canvas.height);
                if (prog < 0.08) { const fa = (0.08 - prog)/0.08; ctx.fillStyle = `rgba(255,255,255,${0.7*fa})`; ctx.fillRect(0,0,canvas.width,canvas.height); }
                ctx.save();
                ctx.translate(cxw, cyw);
                
                const jitter = 0;
                ctx.translate(jitter, jitter);
                const rayCount = blueTheme ? 24 : (theme === 'purple' ? 24 : 22);
                for (let i=0;i<rayCount;i++) {
                    const ang = i * (Math.PI*2/rayCount);
                    ctx.save();
                    ctx.rotate(ang);
                    const len = (blueTheme ? 300 : (theme === 'purple' ? 292 : 280)) + Math.sin(Date.now()/140 + i) * (blueTheme ? 60 : (theme === 'purple' ? 56 : 50));
                    const w = (blueTheme ? 10 : (theme === 'purple' ? 11 : 12)) + Math.sin(Date.now()/220 + i) * (blueTheme ? 2.5 : (theme === 'purple' ? 2.8 : 3));
                    ctx.fillStyle = blueTheme ? `rgba(64,140,255,${0.85*alpha})` : (theme === 'purple' ? `rgba(186,104,200,${0.85*alpha})` : `rgba(255,60,40,${0.85*alpha})`);
                    ctx.fillRect(40, -w/2, len, w);
                    ctx.restore();
                }
                if (lvl2) {
                    for (let i=0;i<18;i++) { const ang = i*(Math.PI*2/18) + Date.now()/600; const r = 140 + 40*Math.sin(Date.now()/500+i); const rx = Math.cos(ang)*r, ry = Math.sin(ang)*r; ctx.save(); ctx.translate(rx, ry); ctx.rotate(ang + Math.sin(Date.now()/300+i)*0.3); ctx.fillStyle = `rgba(255,240,200,${0.6*alpha})`; const pw = 16 + 6*Math.sin(i+Date.now()/400); const ph = 10 + 4*Math.cos(i+Date.now()/420); ctx.fillRect(-pw/2, -ph/2, pw, ph); ctx.restore(); }
                }
                if (lvl3) { ctx.save(); ctx.rotate(Date.now()/500); for (let k=0;k<3;k++){ const rr = 130 + k*28; ctx.beginPath(); ctx.arc(0,0, rr, 0, Math.PI*2); ctx.strokeStyle = `rgba(186,104,200,${0.7*alpha})`; ctx.lineWidth = 4 - k; ctx.stroke(); } ctx.restore(); }
                const bounce = 0.95 + prog*0.25 + Math.sin(Date.now()/240)*0.06;
                const size = Math.min(canvas.width, canvas.height) * 0.42 * bounce;
                const r = size*0.40;
                const g = ctx.createRadialGradient(0, 0, r*0.15, 0, 0, r*1.20);
                g.addColorStop(0, 'rgba(160,120,255,0.85)');
                g.addColorStop(0.5, 'rgba(110,80,240,0.35)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = 'rgba(255,215,0,0.95)';
                ctx.lineWidth = uiSize(8);
                ctx.beginPath(); ctx.arc(0,0,r*0.98,0,Math.PI*2); ctx.stroke();
                const imgIntro = bossIntroInfo.img;
                const readyIntro = !!imgIntro && (imgIntro.complete || imgIntro.naturalWidth > 0);
                if (readyIntro) {
                    const sz = Math.min(canvas.width, canvas.height) * 0.46 * bounce;
                    const bg = ctx.createRadialGradient(0, 0, sz*0.10, 0, 0, sz*0.70);
                    bg.addColorStop(0, 'rgba(210,180,255,0.35)');
                    bg.addColorStop(1, 'rgba(210,180,255,0)');
                    ctx.save();
                    ctx.beginPath(); ctx.arc(0, 0, r*0.86, 0, Math.PI*2); ctx.clip();
                    ctx.globalAlpha = Math.max(0, 0.70*alpha);
                    ctx.drawImage(imgIntro, -sz/2, -sz/2, sz, sz);
                    ctx.globalAlpha = Math.max(0, 0.22*alpha);
                    ctx.drawImage(imgIntro, -sz/2-8, -sz/2-6, sz, sz);
                    ctx.drawImage(imgIntro, -sz/2+6, -sz/2+5, sz, sz);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = bg; ctx.beginPath(); ctx.arc(0,0, r*0.84, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = 'rgba(255,215,0,0.85)'; ctx.lineWidth = uiSize(5); ctx.beginPath(); ctx.arc(0,0, r*0.88, 0, Math.PI*2); ctx.stroke();
                    ctx.restore();
                    ctx.globalAlpha = 1;
                }
                const tHex = Date.now()/700;
                const sr = r*0.70;
                const rot1 = tHex*0.6;
                const rot2 = -tHex*0.7;
                const p1 = [
                    {x: Math.cos(rot1 - Math.PI/2)*sr, y: Math.sin(rot1 - Math.PI/2)*sr},
                    {x: Math.cos(rot1 + Math.PI/6)*sr, y: Math.sin(rot1 + Math.PI/6)*sr},
                    {x: Math.cos(rot1 + 5*Math.PI/6)*sr, y: Math.sin(rot1 + 5*Math.PI/6)*sr}
                ];
                const p2 = [
                    {x: Math.cos(rot2 + Math.PI/2)*sr, y: Math.sin(rot2 + Math.PI/2)*sr},
                    {x: Math.cos(rot2 - Math.PI/6)*sr, y: Math.sin(rot2 - Math.PI/6)*sr},
                    {x: Math.cos(rot2 - 5*Math.PI/6)*sr, y: Math.sin(rot2 - 5*Math.PI/6)*sr}
                ];
                ctx.strokeStyle = 'rgba(255,215,0,0.9)';
                ctx.lineWidth = uiSize(6);
                ctx.globalAlpha = Math.max(0, 0.9*(prog));
                ctx.beginPath(); ctx.moveTo(p1[0].x,p1[0].y); ctx.lineTo(p1[1].x,p1[1].y); ctx.lineTo(p1[2].x,p1[2].y); ctx.closePath(); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(p2[0].x,p2[0].y); ctx.lineTo(p2[1].x,p2[1].y); ctx.lineTo(p2[2].x,p2[2].y); ctx.closePath(); ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.textAlign = 'center';
                const titleFill = blueTheme ? '#1976D2' : (theme === 'purple' ? '#B388FF' : '#D32F2F');
                const titleStroke = blueTheme ? '#001B3D' : (theme === 'purple' ? '#1B001F' : '#000000');
                const subFill = blueTheme ? '#DCEBFF' : '#ffffff';
                const subStroke = blueTheme ? '#0B5FA5' : (theme === 'purple' ? '#4A148C' : '#880000');
                ctx.fillStyle = titleFill;
                ctx.strokeStyle = titleStroke;
                ctx.lineWidth = 6;
                ctx.font = `${Math.round(72)}px sans-serif`;
                ctx.strokeText(bossIntroInfo.name, 0, -canvas.height*0.26);
                ctx.fillText(bossIntroInfo.name, 0, -canvas.height*0.26);
                ctx.fillStyle = subFill;
                ctx.strokeStyle = subStroke;
                ctx.lineWidth = 4;
                ctx.font = `${Math.round(32)}px sans-serif`;
                ctx.strokeText(bossIntroInfo.subtitle, 0, -canvas.height*0.2);
                ctx.fillText(bossIntroInfo.subtitle, 0, -canvas.height*0.2);
                if (lvl2) {
                    // Level 2: Punishment God (Divine/Celestial) - ULTRA UPGRADE
                    const t = Date.now() / 1000;
                    
                    // Layer 1: Divine Aura (Bloom)
                    ctx.save();
                    const auraGrad = ctx.createRadialGradient(0, 0, size*0.5, 0, 0, size*2.0);
                    auraGrad.addColorStop(0, `rgba(255, 215, 0, 0)`);
                    auraGrad.addColorStop(0.4, `rgba(255, 200, 50, ${0.1 * alpha})`);
                    auraGrad.addColorStop(0.8, `rgba(255, 255, 200, ${0.05 * alpha})`);
                    auraGrad.addColorStop(1, `rgba(255, 255, 255, 0)`);
                    ctx.globalCompositeOperation = 'screen';
                    ctx.fillStyle = auraGrad;
                    ctx.beginPath(); ctx.arc(0, 0, size*2.0, 0, Math.PI*2); ctx.fill();
                    ctx.restore();

                    // Layer 2: Rotating Mandala (Geometric Pattern)
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    for(let m=0; m<3; m++) {
                        const rotSpeed = (m % 2 === 0 ? 1 : -1) * 0.15 / (m+1);
                        ctx.rotate(t * rotSpeed);
                        ctx.strokeStyle = `rgba(255, 220, 100, ${0.25 * alpha})`;
                        ctx.lineWidth = 1.5;
                        const petals = 6 + m*4;
                        const rOuter = size * (1.1 + m*0.35);
                        const rInner = size * (0.6 + m*0.2);
                        
                        ctx.beginPath();
                        for(let p=0; p<petals; p++) {
                            const ang = p * Math.PI*2/petals;
                            const cx = Math.cos(ang) * rOuter;
                            const cy = Math.sin(ang) * rOuter;
                            const ix = Math.cos(ang + Math.PI/petals) * rInner;
                            const iy = Math.sin(ang + Math.PI/petals) * rInner;
                            if (p===0) ctx.moveTo(cx, cy);
                            else ctx.lineTo(cx, cy);
                            ctx.quadraticCurveTo(0, 0, ix, iy);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Dots on tips
                        ctx.fillStyle = `rgba(255, 255, 200, ${0.6 * alpha})`;
                        for(let p=0; p<petals; p++) {
                            const ang = p * Math.PI*2/petals;
                            const cx = Math.cos(ang) * rOuter;
                            const cy = Math.sin(ang) * rOuter;
                            ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
                        }
                    }
                    ctx.restore();

                    // Layer 3: God Rays (Enhanced)
                    const rayCount = 16;
                    ctx.save();
                    ctx.rotate(t * 0.05);
                    for (let i = 0; i < rayCount; i++) {
                        ctx.rotate(Math.PI * 2 / rayCount);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        const width = 20 + Math.sin(t*2 + i)*10;
                        ctx.lineTo(canvas.width, -width);
                        ctx.lineTo(canvas.width, width);
                        ctx.closePath();
                        const grad = ctx.createLinearGradient(0, 0, size * 2.5, 0);
                        grad.addColorStop(0, `rgba(255, 215, 0, 0)`); // Clear center
                        grad.addColorStop(0.3, `rgba(255, 200, 50, ${0.1 * alpha})`);
                        grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
                        ctx.fillStyle = grad;
                        ctx.fill();
                    }
                    ctx.restore();

                    // Layer 4: 3D Floating Papers (Flipping effect)
                    const paperCount = 30;
                    for (let i = 0; i < paperCount; i++) {
                        const tOffset = Date.now() / 1500;
                        const pIdx = i * 13.5; 
                        const px = ((pIdx * 123 + tOffset * 60) % (canvas.width + 200)) - 100;
                        const py = ((pIdx * 321 + tOffset * 90) % (canvas.height + 200)) - 100;
                        
                        // 3D Flip Simulation
                        const flipSpeed = 2.0 + (i%3)*0.5;
                        const flipScale = Math.cos(tOffset * flipSpeed + pIdx); 
                        const scaleBase = 0.5 + (i%5)*0.1;
                        
                        ctx.save();
                        ctx.translate(px, py);
                        ctx.rotate(Math.sin(tOffset*0.5 + pIdx)*0.5); // Gentle wobble
                        ctx.scale(scaleBase * flipScale, scaleBase); // Scale X for flip
                        
                        if (Math.abs(flipScale) > 0.1) { // Only draw if visible
                            // Paper shadow
                            ctx.shadowColor = 'rgba(0,0,0,0.3)';
                            ctx.shadowBlur = 5;
                            // Paper body
                            ctx.fillStyle = `rgba(255, 250, 240, ${0.4 * alpha})`;
                            ctx.fillRect(-20, -15, 40, 30);
                            
                            // Text only if facing forwardish
                            if (flipScale > 0) {
                                ctx.fillStyle = `rgba(200, 100, 0, ${0.6 * alpha})`;
                                ctx.font = 'bold 12px serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('ç½š', 0, 0);
                            } else {
                                // Backside pattern
                                ctx.fillStyle = `rgba(200, 180, 150, ${0.6 * alpha})`;
                                ctx.fillRect(-15, -10, 30, 20);
                            }
                        }
                        ctx.restore();
                    }

                    // Layer 5: Golden Dust Particles
                    const dustCount = 50;
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    for(let i=0; i<dustCount; i++) {
                        const dt = (t * 0.2 + i*100) % 10;
                        const dr = size * (0.6 + (i%10)*0.1) + Math.sin(dt + i)*20;
                        const dang = i * (Math.PI*2/dustCount) + dt * 0.5;
                        const dx = Math.cos(dang) * dr;
                        const dy = Math.sin(dang) * dr - dt*10; // Rising
                        
                        ctx.fillStyle = `rgba(255, 255, 200, ${(0.5 + 0.5*Math.sin(dt*3)) * alpha})`;
                        ctx.beginPath();
                        ctx.arc(dx, dy, 1 + (i%3), 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();

                    // Main Circle Pulse (Divine Ring)
                    const sStamp = 1 + 0.03 * Math.sin(Date.now() / 200);
                    ctx.save(); 
                    ctx.scale(sStamp, sStamp); 
                    // Outer Glow
                    ctx.shadowColor = 'rgba(255, 200, 0, 0.8)';
                    ctx.shadowBlur = 30;
                    // Ring
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; 
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0, 0, size * 0.62, 0, Math.PI * 2); ctx.stroke();
                    // Inner Ring
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)'; 
                    ctx.lineWidth = 5;
                    ctx.beginPath(); ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();

                    // SUBTLE: Elegant Punishment Ring
                    ctx.save();
                    const time = Date.now() / 1000;
                    const ringCount = 6; // Fewer text
                    const ringRadius = size * 1.4;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Thin delicate ring
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI*2);
                    ctx.strokeStyle = `rgba(255, 100, 50, ${0.15 * alpha})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();

                    // Text
                    for (let i = 0; i < ringCount; i++) {
                        ctx.save();
                        const angle = i * (Math.PI * 2 / ringCount) + time * 0.15; // Slower
                        const x = Math.cos(angle) * ringRadius;
                        const y = Math.sin(angle) * ringRadius;
                        ctx.translate(x, y);
                        // ctx.rotate(angle - Math.PI / 2); // REMOVED: Keep text upright

                        // Subtle Glow
                        ctx.shadowColor = 'rgba(255, 50, 0, 0.3)';
                        ctx.shadowBlur = 5;
                        ctx.fillStyle = `rgba(255, 200, 150, ${0.6 * alpha})`; // Lower opacity
                        ctx.font = '24px "Microsoft YaHei"'; // Smaller
                        ctx.fillText("ç½šæŠ„", 0, 0);
                        ctx.restore();
                    }
                    ctx.restore();
                }

                if (lvl3) {
                    // Level 3: Moral God (Void/Eldritch) - ULTRA UPGRADE
                    const t = Date.now() / 1000;
                    
                    // Layer 1: Dark Matter Background (Distorted Noise simulation)
                    ctx.save();
                    ctx.globalCompositeOperation = 'multiply'; // Darken
                    const noiseCount = 8;
                    for(let i=0; i<noiseCount; i++) {
                        ctx.beginPath();
                        ctx.rotate(t * 0.1 + i);
                        const distortion = Math.sin(t*2 + i)*30;
                        ctx.ellipse(0, 0, size*(1.2 + i*0.1) + distortion, size*(0.8 + i*0.1) - distortion, t*0.5, 0, Math.PI*2);
                        ctx.fillStyle = `rgba(50, 0, 80, ${0.05 * alpha})`;
                        ctx.fill();
                    }
                    ctx.restore();

                    // Layer 2: Eldritch Tentacles (Bezier Curves)
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    const tentacleCount = 12;
                    for(let i=0; i<tentacleCount; i++) {
                        const ang = i * Math.PI*2/tentacleCount + Math.sin(t*0.5)*0.5;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(ang)*size*0.5, Math.sin(ang)*size*0.5);
                        
                        const cp1x = Math.cos(ang - 0.3) * size * 1.0;
                        const cp1y = Math.sin(ang - 0.3) * size * 1.0;
                        const cp2x = Math.cos(ang + 0.3 + Math.sin(t+i)*0.5) * size * 1.5;
                        const cp2y = Math.sin(ang + 0.3 + Math.sin(t+i)*0.5) * size * 1.5;
                        const ex = Math.cos(ang + Math.sin(t*0.8+i)) * size * 2.2;
                        const ey = Math.sin(ang + Math.sin(t*0.8+i)) * size * 2.2;
                        
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
                        
                        const grad = ctx.createLinearGradient(0,0, ex, ey);
                        grad.addColorStop(0, `rgba(138, 43, 226, ${0.8 * alpha})`);
                        grad.addColorStop(1, `rgba(0, 0, 0, 0)`);
                        
                        ctx.strokeStyle = grad;
                        ctx.lineWidth = 3 + Math.sin(t*3+i)*2;
                        ctx.lineCap = 'round';
                        ctx.stroke();
                    }
                    ctx.restore();

                    // Layer 3: Floating "Eyes" in the Void
                    const eyeCount = 6;
                    for(let i=0; i<eyeCount; i++) {
                        const eyeT = t * 0.3 + i*10;
                        const eyeR = size * (1.2 + Math.sin(eyeT)*0.3);
                        const eyeAng = eyeT + Math.sin(eyeT*2);
                        const ex = Math.cos(eyeAng) * eyeR;
                        const ey = Math.sin(eyeAng) * eyeR;
                        
                        ctx.save();
                        ctx.translate(ex, ey);
                        ctx.rotate(eyeAng + Math.PI/2);
                        // Eye shape
                        ctx.beginPath();
                        ctx.moveTo(-15, 0);
                        ctx.quadraticCurveTo(0, -10, 15, 0);
                        ctx.quadraticCurveTo(0, 10, -15, 0);
                        ctx.fillStyle = `rgba(30, 0, 40, ${0.8 * alpha})`;
                        ctx.fill();
                        ctx.strokeStyle = `rgba(180, 50, 255, ${0.6 * alpha})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        // Pupil
                        const blink = Math.abs(Math.sin(t*3 + i)) > 0.05 ? 1 : 0.1; // Blinking
                        ctx.scale(1, blink);
                        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2);
                        ctx.fillStyle = `rgba(255, 0, 255, ${0.9 * alpha})`;
                        ctx.shadowColor = 'magenta'; ctx.shadowBlur = 5;
                        ctx.fill();
                        ctx.restore();
                    }

                    // Layer 4: Chaotic Runes
                    ctx.save();
                    const runeCount = 15;
                    ctx.font = '20px monospace';
                    ctx.fillStyle = `rgba(200, 100, 255, ${0.5 * alpha})`;
                    for(let i=0; i<runeCount; i++) {
                        const rIdx = i * 20;
                        const rx = (rIdx * 73 + t*50) % (canvas.width) - canvas.width/2;
                        const ry = (rIdx * 41 + Math.sin(t+i)*100) % (canvas.height) - canvas.height/2;
                        ctx.fillText(Math.random()>0.5?'?':'!', rx, ry);
                    }
                    ctx.restore();

                    // Layer 5: Spiked Halo
                    const sStamp = 1 + 0.04 * Math.sin(Date.now() / 200);
                    ctx.save(); 
                    ctx.scale(sStamp, sStamp); 
                    ctx.shadowColor = 'rgba(100, 0, 200, 1)';
                    ctx.shadowBlur = 25;
                    ctx.strokeStyle = 'rgba(160, 30, 220, 1)'; 
                    ctx.lineWidth = 4; 
                    
                    ctx.beginPath();
                    const spikes = 12;
                    for(let i=0; i<spikes*2; i++) {
                        const a = i * Math.PI / spikes;
                        const r = (i%2===0) ? size*0.6 : size*0.75;
                        if(i===0) ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r);
                        else ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();

                    // SUBTLE: Void Deduction Ring
                    ctx.save();
                    const time = Date.now() / 1000;
                    const ringCount = 8;
                    const ringRadius = size * 1.55;

                    // Subtle Glitch Effect
                    const drawGlitchText = (text, x, y, a) => {
                        const offX = Math.sin(time * 10) * 1; // Less jitter
                        const offY = Math.cos(time * 8) * 1;
                        // Darker, less saturated colors
                        ctx.fillStyle = `rgba(100, 0, 50, ${0.4 * a})`; 
                        ctx.fillText(text, x + offX, y + offY);
                        ctx.fillStyle = `rgba(50, 0, 100, ${0.4 * a})`;
                        ctx.fillText(text, x - offX, y - offY);
                        ctx.fillStyle = `rgba(200, 200, 200, ${0.7 * a})`; // Main text less bright
                        ctx.fillText(text, x, y);
                    };

                    for (let i = 0; i < ringCount; i++) {
                        ctx.save();
                        const angle = i * (Math.PI * 2 / ringCount) - time * 0.2; // Slower
                        const x = Math.cos(angle) * ringRadius;
                        const y = Math.sin(angle) * ringRadius;
                        ctx.translate(x, y);
                        
                        ctx.rotate(angle + Math.PI/2); 

                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = '28px "Microsoft YaHei"'; // Smaller
                        
                        drawGlitchText("æ‰£åˆ†", 0, 0, alpha);
                        ctx.restore();
                    }
                    ctx.restore();
                }

                if (blueTheme) {
                    // Level 4: The Grand Astral Architect (Complex Beauty)
                    // Concept: The "Clockwork of the Universe". Extremely intricate, fractal, and detailed.
                    // Visuals: Spirographs, star charts, runic rings, flowing mana ribbons.
                    const t = Date.now() / 1000;
                    
                    // --- Layer 1: The Deepest Void (Background) ---
                    // Draw BEHIND everything.
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-over'; 
                    const gradVoid = ctx.createRadialGradient(0, 0, size * 0.5, 0, 0, size * 8);
                    gradVoid.addColorStop(0, `rgba(0, 5, 20, 0)`); // Hollow Center
                    gradVoid.addColorStop(0.3, `rgba(0, 10, 40, ${0.9 * alpha})`);
                    gradVoid.addColorStop(0.7, `rgba(0, 0, 10, ${0.95 * alpha})`);
                    gradVoid.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = gradVoid;
                    ctx.beginPath(); ctx.arc(0, 0, size * 10, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();

                    // --- Layer 2: The Spirograph (Harmonograph) Background ---
                    // Complex curves drawn behind
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = `rgba(50, 100, 200, ${0.15 * alpha})`;
                    
                    ctx.beginPath();
                    const spiroSteps = 100; // Resolution
                    for(let i=0; i<=spiroSteps; i++) {
                        const ang = (i / spiroSteps) * Math.PI * 2;
                        // Harmonograph formula
                        const rS = size * 2.5 + Math.sin(ang * 5 + t * 0.5) * size * 0.5 + Math.cos(ang * 3 - t * 0.2) * size * 0.3;
                        const x = Math.cos(ang) * rS;
                        const y = Math.sin(ang) * rS;
                        if(i===0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Second Spirograph (Counter rotation)
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(0, 200, 255, ${0.1 * alpha})`;
                    for(let i=0; i<=spiroSteps; i++) {
                        const ang = (i / spiroSteps) * Math.PI * 2;
                        const rS = size * 3.0 + Math.sin(ang * 7 - t * 0.3) * size * 0.4;
                        const x = Math.cos(ang + t*0.1) * rS;
                        const y = Math.sin(ang + t*0.1) * rS;
                        if(i===0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();

                    // --- Layer 3: Flowing Mana Ribbons (Interference) ---
                    // Dense lines creating a fabric effect
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const ribbonCount = 20;
                    for(let r=0; r<ribbonCount; r++) {
                        const rProg = r / ribbonCount;
                        const rAng = t * 0.1 + rProg * Math.PI * 2;
                        
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(0, 150, 255, ${0.05 * alpha})`;
                        ctx.lineWidth = 2;
                        
                        // Draw a wave
                        for(let x = -size*4; x <= size*4; x+=size*0.2) {
                            const dist = Math.abs(x);
                            const env = Math.max(0, 1 - dist/(size*4)); // Envelope
                            const y = Math.sin(x*0.02 + t + rProg*10) * size * 0.5 * env + 
                                      Math.cos(x*0.05 - t*2) * size * 0.3 * env;
                            
                            // Rotate point
                            const rx = x * Math.cos(rAng) - y * Math.sin(rAng);
                            const ry = x * Math.sin(rAng) + y * Math.cos(rAng);
                            
                            if(x===-size*4) ctx.moveTo(rx, ry);
                            else ctx.lineTo(rx, ry);
                        }
                        ctx.stroke();
                    }
                    ctx.restore();

                    // --- Layer 4: The Astral Clock (Runic Rings) ---
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    
                    // Ring 1: Seconds (Fast Ticks)
                    ctx.save();
                    ctx.rotate(t * 0.2);
                    const tickCount = 60;
                    for(let i=0; i<tickCount; i++) {
                        const a = (i / tickCount) * Math.PI * 2;
                        const isMajor = i % 5 === 0;
                        const rInner = size * 1.5;
                        const rOuter = isMajor ? size * 1.65 : size * 1.55;
                        
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(a)*rInner, Math.sin(a)*rInner);
                        ctx.lineTo(Math.cos(a)*rOuter, Math.sin(a)*rOuter);
                        ctx.strokeStyle = isMajor ? `rgba(100, 220, 255, ${0.8 * alpha})` : `rgba(50, 150, 200, ${0.4 * alpha})`;
                        ctx.lineWidth = isMajor ? 3 : 1;
                        ctx.stroke();
                    }
                    ctx.restore();

                    // Ring 2: Runes (Counter Rotate)
                    ctx.save();
                    ctx.rotate(-t * 0.05);
                    const runeCount = 24;
                    ctx.font = `${Math.floor(size*0.15)}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = `rgba(0, 255, 255, ${0.6 * alpha})`;
                    for(let i=0; i<runeCount; i++) {
                        const a = (i / runeCount) * Math.PI * 2;
                        const rRune = size * 1.8;
                        ctx.save();
                        ctx.translate(Math.cos(a)*rRune, Math.sin(a)*rRune);
                        ctx.rotate(a + Math.PI/2);
                        // Random-ish char
                        const char = String.fromCharCode(0x2200 + (i + Math.floor(t)) % 100); 
                        ctx.fillText(char, 0, 0);
                        ctx.restore();
                    }
                    ctx.restore();
                    
                    // Ring 3: Complex Geometry (Triangle Web)
                    ctx.save();
                    ctx.rotate(t * 0.08);
                    ctx.strokeStyle = `rgba(80, 180, 255, ${0.3 * alpha})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    const pts = 9;
                    const webR = size * 2.1;
                    for(let i=0; i<pts; i++) {
                        const a1 = (i / pts) * Math.PI * 2;
                        const a2 = ((i+2) / pts) * Math.PI * 2; // Skip 2
                        ctx.moveTo(Math.cos(a1)*webR, Math.sin(a1)*webR);
                        ctx.lineTo(Math.cos(a2)*webR, Math.sin(a2)*webR);
                    }
                    ctx.stroke();
                    ctx.restore();
                    
                    ctx.restore();

                    // --- Layer 5: Crystal Satellites (Orbiting) ---
                    // 3D-ish rotation
                    ctx.save();
                    const satCount = 6;
                    for(let i=0; i<satCount; i++) {
                        const tOff = t * 0.5 + i;
                        const orbitR = size * 2.5;
                        // Elliptical orbit to simulate 3D plane tilt
                        const ox = Math.cos(tOff) * orbitR;
                        const oy = Math.sin(tOff) * (orbitR * 0.4); 
                        
                        // Rotate the whole orbit plane
                        const planeAng = Math.PI / 4; 
                        const fx = ox * Math.cos(planeAng) - oy * Math.sin(planeAng);
                        const fy = ox * Math.sin(planeAng) + oy * Math.cos(planeAng);

                        // Draw Trail
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(0, 255, 255, ${0.2 * alpha})`;
                        ctx.lineWidth = 2;
                        ctx.moveTo(fx, fy);
                        // Short trail
                        const tx = Math.cos(tOff-0.2) * orbitR; 
                        const ty = Math.sin(tOff-0.2) * (orbitR * 0.4);
                        const ftx = tx * Math.cos(planeAng) - ty * Math.sin(planeAng);
                        const fty = tx * Math.sin(planeAng) + ty * Math.cos(planeAng);
                        ctx.lineTo(ftx, fty);
                        ctx.stroke();

                        // Draw Crystal
                        ctx.save();
                        ctx.translate(fx, fy);
                        ctx.rotate(t * 2 + i); // Spin
                        ctx.fillStyle = `rgba(200, 255, 255, ${0.9 * alpha})`;
                        ctx.shadowColor = 'white'; ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.moveTo(0, -10); ctx.lineTo(8, 0); ctx.lineTo(0, 10); ctx.lineTo(-8, 0);
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.restore();

                    // --- Layer 6: Boss Highlight (No obstruction) ---
                    // Just a subtle rim light and back glow
                    ctx.save();
                    const rimCol = `rgba(100, 220, 255, ${0.5 * alpha})`;
                    ctx.strokeStyle = rimCol;
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, size * 1.05, 0, Math.PI*2); ctx.stroke();
                    ctx.restore();

                    // SUBTLE: Astral Disciplinary Array
                    ctx.save();
                    const time = Date.now() / 1000;

                    // 1. Magic Circle Lines (Very thin)
                    ctx.save();
                    ctx.rotate(time * 0.1);
                    ctx.strokeStyle = `rgba(100, 200, 255, ${0.3 * alpha})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.8, 0, Math.PI*2);
                    ctx.stroke();
                    // Inner dashed
                    ctx.setLineDash([5, 15]);
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.4, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();

                    // 2. Rotating Pentagram (Very subtle)
                    ctx.save();
                    ctx.rotate(-time * 0.15);
                    ctx.strokeStyle = `rgba(100, 220, 255, ${0.4 * alpha})`;
                    ctx.lineWidth = 1;
                    ctx.shadowColor = 'rgba(0, 150, 255, 0.4)';
                    ctx.shadowBlur = 5;
                    const starR = size * 1.3;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const a = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const x = Math.cos(a) * starR;
                        const y = Math.sin(a) * starR;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();

                    // 3. Text Ring (Minimalist)
                    const ringCount = 5; 
                    const ringRadius = size * 1.8;
                    for (let i = 0; i < ringCount; i++) {
                        ctx.save();
                        const angle = i * (Math.PI * 2 / ringCount) + time * 0.1; // Very slow
                        const x = Math.cos(angle) * ringRadius;
                        const y = Math.sin(angle) * ringRadius;
                        
                        ctx.translate(x, y);
                        // ctx.rotate(angle + Math.PI/2); 
                        
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = '32px "Microsoft YaHei"'; // Smaller, thinner
                        
                        // Soft Glow
                        ctx.shadowColor = 'rgba(0, 200, 255, 0.5)';
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = `rgba(180, 230, 255, ${0.8 * alpha})`;
                        ctx.fillText("å¤„åˆ†", 0, 0);
                        
                        ctx.restore();
                    }
                    ctx.restore();
                }
                ctx.restore();
                ctx.save();
                for (let y=0; y<canvas.height; y+=6) { const a = 0.05*alpha; const col = blueTheme?`rgba(0,30,70,${a})`:(theme === 'purple'?`rgba(40,0,60,${a})`:`rgba(30,0,0,${a})`); ctx.fillStyle = col; ctx.fillRect(0,y,canvas.width,2); }
                ctx.restore();
                ctx.restore();
            }
            if (bossBridgeFrames > 0 && bossBridgeTarget) {
                const s = cameraScale || 1;
                const bp = pigs.find(p=>p.isBoss);
                const tx = (bp ? bp.x : bossBridgeTarget.x), ty = (bp ? bp.y : bossBridgeTarget.y);
                const sx = (tx - cameraX) * s; const sy = (ty - cameraY) * s;
                const t = Math.max(0, Math.min(1, 1 - bossBridgeFrames / 90));
                const startX = canvas.width/2, startY = canvas.height/2;
                ctx.save();
                ctx.setTransform(1,0,0,1,0,0);
                const base = Math.min(canvas.width, canvas.height) * 0.40;
                const tc = 3;
                const step = 0.33;
                const img = (bp && bp.bossType==='boss3' && boss3ImageLoaded) ? boss3Image : ((bp && bp.bossType==='boss2' && boss2ImageLoaded) ? boss2Image : (bossImageLoaded ? bossImage : bossIntroInfo?.img || null));
                for (let i=0;i<tc;i++) {
                    const ti = Math.max(0, Math.min(1, t - i*step));
                    const x = startX + (sx - startX) * ti;
                    const y = startY + (sy - startY) * ti;
                    const k = 1.0 - i*0.08;
                    const r = base * 0.38 * k;
                    // const g = ctx.createRadialGradient(x, y, r*0.15, x, y, r*1.20);
                    // g.addColorStop(0, 'rgba(160,120,255,0.85)');
                    // g.addColorStop(0.5, 'rgba(110,80,240,0.35)');
                    // g.addColorStop(1, 'rgba(0,0,0,0)');
                    const a = Math.max(0, 0.80 * (1 - i/tc));
                    ctx.globalAlpha = a;
                    // ctx.fillStyle = g;
                    // ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
                    // ctx.strokeStyle = 'rgba(0,0,0,0.95)';
                    // ctx.lineWidth = uiSize(6);
                    // ctx.beginPath(); ctx.arc(x, y, r*0.98, 0, Math.PI*2); ctx.stroke();
                    if (img) {
                        const size = base * k;
                        ctx.globalAlpha = Math.max(0, a*0.95);
                        ctx.drawImage(img, x - size/2, y - size/2, size, size);
                    }
                }
                ctx.globalAlpha = 1;
                ctx.save();
                ctx.setTransform(1,0,0,1,0,0);
                if (false) introInkRings.forEach(rg => {
                    const a = Math.max(0, rg.alpha || 0);
                    const thick = Math.max(10, (rg.thickness || 16) * (0.9 + 0.1*Math.sin((rg.phase||0)*0.7)));
                    ctx.save();
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.globalAlpha = a;
                    ctx.shadowBlur = 28;
                    ctx.shadowColor = `rgba(0,0,0,${a})`;
                    ctx.strokeStyle = `rgba(0,0,0,1)`;
                    ctx.lineWidth = thick;
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.r, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                    ctx.save();
                    ctx.globalCompositeOperation = 'multiply';
                    const steps = 160;
                    const ef1 = (rg.edgeFreq || 0.18);
                    const ef2 = ef1 * 2.7;
                    const na1 = (rg.noiseAmp || 9);
                    const na2 = na1 * 0.35;
                    const ph = rg.phase || 0;
                    const spin = Date.now()/1600;
                    ctx.beginPath();
                    for (let i=0;i<steps;i++){
                        const ang = spin + i*(Math.PI*2/steps);
                        const j = Math.sin(i*ef1 + ph) * na1 + Math.sin(i*ef2 + ph*1.3) * na2;
                        const ro = rg.r + thick*0.5 + j;
                        const x = rg.x + Math.cos(ang)*ro;
                        const y = rg.y + Math.sin(ang)*ro;
                        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                    }
                    for (let i=steps-1;i>=0;i--){
                        const ang = spin + i*(Math.PI*2/steps);
                        const j = Math.sin(i*ef1 + ph) * (na1*0.6) + Math.sin(i*ef2 + ph*1.3) * (na2*0.6);
                        const ri = rg.r - thick*0.5 - j;
                        const x = rg.x + Math.cos(ang)*ri;
                        const y = rg.y + Math.sin(ang)*ri;
                        ctx.lineTo(x,y);
                    }
                    ctx.closePath();
                    ctx.fillStyle = `rgba(0,0,0,${0.82*a})`;
                    ctx.fill();
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const arcs = 64;
                    for (let j=0;j<arcs;j++){
                        const b = j*(Math.PI*2/arcs) + (rg.phase||0)*0.5 + spin*0.8;
                        const sa = b - 0.05;
                        const ea = b + 0.05;
                        const rr = rg.r + Math.sin(b*2 + (rg.phase||0))*5;
                        ctx.globalAlpha = Math.max(0, a*0.18);
                        ctx.strokeStyle = 'rgba(36,36,36,0.9)';
                    ctx.lineWidth = 1.8;
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rr, sa, ea);
                    ctx.stroke();
                }
                ctx.restore();
                ctx.save();
                const t = Date.now()/480;
                const inkCol = 'rgba(0,0,0,0.35)';
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = inkCol;
                ctx.lineWidth = Math.max(2, thick*0.16);
                ctx.setLineDash([18, 14]);
                ctx.lineDashOffset = -t*22;
                ctx.beginPath();
                ctx.arc(rg.x, rg.y, rg.r + thick*0.35, 0, Math.PI*2);
                ctx.stroke();
                ctx.setLineDash([]);
                for (let k=0;k<6;k++) {
                    const ang = t*0.9 + k*(Math.PI*2/6);
                    const w = 0.22 + Math.sin(t*1.4 + k)*0.06;
                    const rr2 = rg.r + thick*0.25 + Math.sin(t*1.3 + k)*3;
                    ctx.globalAlpha = Math.max(0, a*0.35);
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rr2, ang - w/2, ang + w/2);
                    ctx.stroke();
                }
                ctx.restore();
                ctx.restore();
                ctx.save();
                ctx.globalCompositeOperation = 'multiply';
                ctx.globalAlpha = 0.55 * a;
                ctx.fillStyle = 'rgba(0,0,0,1)';
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.r*0.72, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                    ctx.save();
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.globalAlpha = a*0.32;
                    ctx.strokeStyle = `rgba(0,0,0,${0.55*a})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.r+5, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.r-5, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                    ctx.save();
                    ctx.setTransform(1,0,0,1,0,0);
                    const vg = ctx.createRadialGradient(canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)*0.30, canvas.width/2, canvas.height/2, Math.max(canvas.width,canvas.height)*0.86);
                    vg.addColorStop(0, `rgba(0,0,0,0)`);
                    vg.addColorStop(1, `rgba(0,0,0,${Math.min(0.85, 0.7*a)})`);
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = vg;
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                    ctx.restore();
                    ctx.save();
                    ctx.setTransform(1,0,0,1,0,0);
                    const hg = ctx.createRadialGradient(rg.x, rg.y, Math.max(0, rg.r - thick*0.5), rg.x, rg.y, rg.r + thick*1.7);
                    hg.addColorStop(0, `rgba(0,0,0,0)`);
                    hg.addColorStop(1, `rgba(0,0,0,${Math.min(0.68, 0.56*a)})`);
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = hg;
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                    ctx.restore();
                });
                ctx.restore();
                ctx.restore();
            }
            const ab = activeBird;
            if (ab && ab.type === 'red' && ab.launched && !replayMode) {
                const qFxPost = fxQ;
                const spd = Math.hypot(ab.velocity?.x || 0, ab.velocity?.y || 0);
                const v = Math.max(0, Math.min(1, (spd - 8) / 18));
                if (v > 0.01 && qFxPost >= 0.55) {
                    const s = cameraScale || 1;
                    const cx = (ab.x - cameraX) * s + (lastDrawShakeX || 0);
                    const cy = (ab.y - cameraY) * s + (lastDrawShakeY || 0);
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = (FX_OVERDRIVE ? 0.22 : 0.10) * v * (FX_OVERDRIVE ? qFxPost : qFxPost);
                    const r = Math.max(canvas.width, canvas.height) * (0.55 + 0.15 * v);
                    const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                    g.addColorStop(0, 'rgba(255,70,0,0.85)');
                    g.addColorStop(0.35, 'rgba(255,160,60,0.35)');
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = (FX_OVERDRIVE ? 0.18 : 0.08) * v * (FX_OVERDRIVE ? qFxPost : qFxPost);
                    const ang = Math.atan2(ab.velocity?.y || 0, ab.velocity?.x || 0);
                    ctx.translate(cx, cy);
                    ctx.rotate(ang);
                    const lg = ctx.createLinearGradient(-canvas.width * 0.25, 0, canvas.width * 0.35, 0);
                    lg.addColorStop(0, 'rgba(255,255,255,0)');
                    lg.addColorStop(0.45, 'rgba(255,210,120,0.65)');
                    lg.addColorStop(1, 'rgba(255,60,0,0)');
                    ctx.fillStyle = lg;
                    ctx.fillRect(-canvas.width * 0.25, -canvas.height * 0.02, canvas.width * 0.6, canvas.height * 0.04);
                    if (FX_OVERDRIVE && fxHeavy) {
                        ctx.globalAlpha = 0.10 * v;
                        const lg2 = ctx.createLinearGradient(-canvas.width * 0.35, 0, canvas.width * 0.45, 0);
                        lg2.addColorStop(0, 'rgba(255,255,255,0)');
                        lg2.addColorStop(0.52, 'rgba(255,255,255,0.55)');
                        lg2.addColorStop(1, 'rgba(255,255,255,0)');
                        ctx.fillStyle = lg2;
                        ctx.fillRect(-canvas.width * 0.35, -canvas.height * 0.012, canvas.width * 0.8, canvas.height * 0.024);
                    }
                    ctx.restore();
                }
            }
            // --- å…¨å±€é—ªå…‰ç‰¹æ•ˆ (Global Flash FX) ---
            if (flashFrames > 0) {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®å˜æ¢ï¼Œç¡®ä¿è¦†ç›–å…¨å±
                const a = Math.min(1, flashFrames / 10);
                let sx = canvas.width / 2;
                let sy = canvas.height / 2;
                if (Number.isFinite(flashWorldX) && Number.isFinite(flashWorldY)) {
                    const s = cameraScale || 1;
                    sx = (flashWorldX - cameraX) * s + (lastDrawShakeX || 0);
                    sy = (flashWorldY - cameraY) * s + (lastDrawShakeY || 0);
                }
                ctx.globalAlpha = a;
                const r = Math.max(canvas.width, canvas.height) * 0.85;
                const g = ctx.createRadialGradient(sx, sy, 0, sx, sy, r);
                g.addColorStop(0, flashColor || '#FFF');
                g.addColorStop(0.35, flashColor || '#FFF');
                g.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                flashFrames--;
            }
            if (lensFrames > 0) {
                if (fxQ < 0.55) { lensFrames--; return; }
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                const a = Math.min(1, lensFrames / 22);
                let sx = canvas.width / 2;
                let sy = canvas.height / 2;
                if (Number.isFinite(lensWorldX) && Number.isFinite(lensWorldY)) {
                    const s = cameraScale || 1;
                    sx = (lensWorldX - cameraX) * s + (lastDrawShakeX || 0);
                    sy = (lensWorldY - cameraY) * s + (lastDrawShakeY || 0);
                }
                const r = Math.max(canvas.width, canvas.height) * (FX_OVERDRIVE ? (0.65 + 0.30 * fxQ) : 0.75);
                ctx.globalCompositeOperation = 'screen';
                ctx.globalAlpha = a * (FX_OVERDRIVE ? (0.26 + 0.34 * fxQ) : 0.35);
                const g1 = ctx.createRadialGradient(sx, sy, 0, sx, sy, r);
                g1.addColorStop(0, lensColor || '#FFF');
                g1.addColorStop(0.18, 'rgba(255,255,255,0.85)');
                g1.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g1;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = a * (FX_OVERDRIVE ? (0.16 + 0.20 * fxQ) : 0.20);
                const g2 = ctx.createRadialGradient(sx, sy, 0, sx, sy, r * 0.72);
                g2.addColorStop(0, 'rgba(80,255,255,0.7)');
                g2.addColorStop(0.35, 'rgba(255,60,160,0.55)');
                g2.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g2;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const rays = (FX_OVERDRIVE && fxQ >= 0.65) ? Math.max(8, Math.round(8 + 12 * fxQ)) : (FX_OVERDRIVE ? 0 : 12);
                ctx.translate(sx, sy);
                for (let i = 0; i < rays; i++) {
                    const ang = (i * (Math.PI * 2 / rays)) + (Date.now() / 900);
                    ctx.save();
                    ctx.rotate(ang);
                    const lg = ctx.createLinearGradient(0, 0, r * 0.65, 0);
                    lg.addColorStop(0, 'rgba(255,255,255,0.0)');
                    lg.addColorStop(0.2, 'rgba(255,255,255,0.55)');
                    lg.addColorStop(1, 'rgba(255,255,255,0.0)');
                    ctx.fillStyle = lg;
                    ctx.globalAlpha = a * 0.12 * fxQ;
                    ctx.fillRect(0, -uiSize(6), r * 0.65, uiSize(12));
                    ctx.restore();
                }
                ctx.restore();
                lensFrames--;
            }
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            const slingBird = birds.find(b => b && b.inSlingshot && !b.launched && !b.dead);
            if (slingBird && slingBird !== draggedBird) {
                slingBird.x = slingshot.x;
                slingBird.y = slingshot.y;
                if (slingBird.velocity) { slingBird.velocity.x = 0; slingBird.velocity.y = 0; }
            }
            // --- Dynamic Wind Update (Every 1s) ---
            windRandomTimer++;
            if (windRandomTimer >= 60) {
                windRandomTimer = 0;
                // Random offset between -0.12 and +0.12
                windRandomOffset = (Math.random() * 0.24) - 0.12;
            }

            // --- å­å¼¹æ—¶é—´ (Bullet Time / Hit Stop) ---
            if (bulletTimeFrames > 0) {
                // å¥‡æ•°å¸§è·³è¿‡ (Skip odd frames) -> 0.5x speed
                if (bulletTimeFrames % 2 !== 0) {
                    bulletTimeFrames--;
                    return; 
                }
                // å¶æ•°å¸§ç»§ç»­ï¼Œç”±åç»­é€»è¾‘(line 4813)è´Ÿè´£é€’å‡
            }

            const qFx = FX_OVERDRIVE ? fxBoost : fxQ;
            if (FX_OVERDRIVE) {
                MAX_PARTICLES = Math.max(160, Math.round(160 + 520 * fxQ));
                spawnBudget = Math.max(80, Math.round(80 + 360 * fxQ));
            } else {
                MAX_PARTICLES = Math.max(260, Math.min(700, Math.round(560 * qFx)));
                spawnBudget = Math.max(120, Math.round(360 + 320 * qFx));
            }
            if (pigs.some(p=>p.isBoss && p.health>0)) spawnBudget += 60;
            if (bossSpawnPortal) {
                if (canDragDuringLock()) {
                    const baseScale = (settings.cameraScale || getDefaultCameraScale(currentLevel));
                    targetCameraScale = baseScale;
                    const s = targetCameraScale || 1;
                    targetCameraX = Math.max(0, slingshot.x - canvas.width/(2*s));
                    targetCameraY = Math.max(0, slingshot.y - canvas.height/(2*s));
                    cameraX += (targetCameraX - cameraX) * 0.28;
                    cameraY += (targetCameraY - cameraY) * 0.28;
                    cameraScale += (targetCameraScale - cameraScale) * 0.25;
                    clampCamera();
                }
                portalSparkPhase += 0.06;
                const spd = 0.05;
                if (bossSpawnPortal.phase === 'opening') {
                    bossSpawnPortal.openProgress = Math.min(1, (bossSpawnPortal.openProgress||0) + spd);
                    
                    // å¢åŠ ä¼ é€é—¨å¼€å¯æ—¶çš„é»‘æš—ç²’å­
                    if (Math.random() < 0.5) {
                        const cx = bossSpawnPortal.x || canvas.width/2;
                        const cy = bossSpawnPortal.y || canvas.height/2;
                        const r = (bossSpawnPortal.r || 100) * (bossSpawnPortal.openProgress || 0.1);
                        const ang = Math.random() * Math.PI * 2;
                        const px = cx + Math.cos(ang) * r;
                        const py = cy + Math.sin(ang) * r;
                        spawnParticles(px, py, 1, 'rgba(0,0,0,0.8)', { style: 'melt', vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 40 });
                        if (Math.random() < 0.3) spawnParticles(px, py, 1, 'rgba(20,0,20,0.8)', { style: 'shadow_fissure', len: 20, w: 4 });
                    }

                    if ((bossSpawnPortal.openProgress||0) >= 1) {
                        if (bossPending) {
                            pigs.push(bossPending);
                            const bp = bossPending;
                            const profiles = {
                                boss1: { name: 'é˜¿ç‘æ–¯', subtitle: 'æš´åŠ›ä¹‹ç¥', img: bossImage },
                                boss2: { name: 'é˜¿ç‘æ–¯', subtitle: 'æš´åŠ›ä¹‹ç¥', img: boss2Image },
                                boss3: { name: 'é˜¿ç‘æ–¯', subtitle: 'æš´åŠ›ä¹‹ç¥', img: boss3Image }
                            };
                            let pf = profiles[bp.bossType||'boss1'] || profiles.boss1;
                            if (currentLevel === 2) { pf = { name: 'æ–½ç»å¯¿', subtitle: 'ç½šæŠ„ä¹‹ç¥', img: bossImage }; }
                            else if (currentLevel === 3) { pf = { name: 'å¼ æ¬²ä¸°', subtitle: 'å¾·è‚²ä¹‹ç¥', img: boss2Image }; }
                            else if (currentLevel === 4) { pf = { name: 'ææ±Ÿ', subtitle: 'å¤„åˆ†ä¹‹ç¥', img: (bp.bossType==='boss3' && boss3ImageLoaded) ? boss3Image : ((bp.bossType==='boss2' && boss2ImageLoaded) ? boss2Image : bossImage) }; }
                            bossIntroInfo = { name: pf.name, subtitle: pf.subtitle, img: pf.img };
                            bossIntroFrames = 120;
                            if (!bossIntroPlayed) { try { playBossIntroSound(1); } catch(e){} bossIntroPlayed = true; }
                            // shakeFrames = Math.max(shakeFrames, 16); // Removed shake
                            bossBridgeTarget = { x: bp.x, y: bp.y };
                            bossPending = null;
                        }
                        bossSpawnPortal.phase = 'closing';
                    }
                } else if (bossSpawnPortal.phase === 'closing') {
                    bossSpawnPortal.alpha = Math.max(0, (bossSpawnPortal.alpha||1) - 0.08);
                    if ((bossSpawnPortal.alpha||0) <= 0) { bossSpawnPortal.done = true; bossSpawnPortal = null; }
                }
                return;
            }
            if (bossIntroFrames > 0) {
                if (canDragDuringLock()) {
                    const baseScale = (settings.cameraScale || getDefaultCameraScale(currentLevel));
                    targetCameraScale = baseScale;
                    const s = targetCameraScale || 1;
                    targetCameraX = Math.max(0, slingshot.x - canvas.width/(2*s));
                    targetCameraY = Math.max(0, slingshot.y - canvas.height/(2*s));
                    cameraX += (targetCameraX - cameraX) * 0.28;
                    cameraY += (targetCameraY - cameraY) * 0.28;
                    cameraScale += (targetCameraScale - cameraScale) * 0.25;
                    clampCamera();
                }
                bossIntroFrames--;
                if (bossIntroFrames === 0 && bossBridgeTarget) {
                    bossBridgeFrames = 90;
                    introInkRings.push({ x: canvas.width/2, y: canvas.height/2, r: 136, maxR: Math.min(canvas.width, canvas.height)*0.92, alpha: 1.0, growth: 4.4, thickness: 12, flashAlpha: 0, emitInterval: 1, emitCooldown: 0, edgeFreq: 0.22, noiseAmp: 7, phase: 0, phaseSpeed: 0.14 });
                    // shakeFrames = Math.max(shakeFrames, 22); // Removed shake
                    bulletTimeFrames = Math.max(bulletTimeFrames, 60);
                }
                return;
            }
            if (bossBridgeFrames > 0) {
                const bp = pigs.find(p=>p.isBoss);
                const wantSling = canDragDuringLock();
                const tx = wantSling ? slingshot.x : (bp ? bp.x : bossBridgeTarget?.x || canvas.width/2);
                const ty = wantSling ? slingshot.y : (bp ? bp.y : bossBridgeTarget?.y || canvas.height/2);
                const baseScale = (settings.cameraScale || getDefaultCameraScale(currentLevel));
                targetCameraScale = baseScale;
                const s = targetCameraScale || 1;
                targetCameraX = Math.max(0, tx - canvas.width/(2*s));
                targetCameraY = Math.max(0, ty - canvas.height/(2*s));
                cameraX += (targetCameraX - cameraX) * 0.28;
                cameraY += (targetCameraY - cameraY) * 0.28;
                cameraScale += (targetCameraScale - cameraScale) * 0.25;
                clampCamera();
                bossBridgeFrames--;
                if (bossBridgeFrames <= 0) {
                    if (introInkRings.length) {
                        const rg = introInkRings[0];
                        inkDissolve = { x: rg.x, y: rg.y, rad: 0, prevRad: 0, maxR: rg.r + (rg.thickness||16)*0.5, phase: rg.phase||0, noiseAmp: rg.noiseAmp||7, theta: 0, prog: 0 };
                        rg.collapse = true; rg.growth = -5; rg.alpha = Math.max(0, (rg.alpha||1) * 0.85);
                    }
                }
                return;
            }
            explosions.forEach((e, i) => { e.age += 1; if (e.age > 30) explosions.splice(i, 1); });
            if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy;
                if (p.shape !== 'ring' && !p.nog) p.vy += 0.05;
                p.life--;
                if (p.shape === 'ring') {
                    p.r = (p.r || 3) + 0.6;
                    p.alpha = (p.alpha || 0.9) - 0.03;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'smoke') {
                    p.r = (p.r || 6) + (p.growth || 0.08);
                    p.alpha = (p.alpha || 0.8) - 0.02;
                    p.vx *= 0.98; p.vy *= 0.98;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'afterimage') {
                    p.alpha = (p.alpha || 0.45) - 0.04;
                    p.r = (p.r || 20) * 1.01;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'impact_slash') {
                    p.alpha = (p.alpha || 0.9) - (p.decay || 0.08);
                    p.len = (p.len || 40) * 1.02;
                    p.w = (p.w || 10) * 0.985;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'amaterasu') {
                    p.r = (p.r || 8) + (p.growth || 0.14);
                    p.alpha = (p.alpha || 0.9) - 0.012;
                    p.vx *= 0.985; p.vy *= 0.985;
                    p.rot = (p.rot || 0) + 0.012;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'melt') {
                    p.vy = (p.vy || 1.0) + (p.grav || 0.02);
                    p.vx *= 0.992;
                    p.r = (p.r || 4) * (p.taper || 0.98);
                    p.alpha = (p.alpha || 0.95) - (p.decay || 0.02);
                    if (p.y > canvas.height || p.alpha <= 0 || p.r <= 0.5) p.life = 0;
                } else if (p.shape === 'ember') {
                    p.vx *= 0.99; p.vy *= 0.99;
                    p.alpha = (p.alpha || 0.9) - (p.decay || 0.02);
                    p.r = (p.r || 2.2) + (p.rGrow || 0.02);
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'rune') {
                    p.vx *= 0.992; p.vy = (p.vy || 0.1) + 0.012;
                    p.rot = (p.rot || 0) + (p.omega || 0.01);
                    p.alpha = (p.alpha || 0.85) - 0.018;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'black_flame') {
                    p.x += p.vx; p.y += p.vy;
                    p.theta = (p.theta || 0) + 0.015;
                    p.len = (p.len || 28) * 1.008;
                    p.w = (p.w || 12) * 0.992;
                    p.alpha = (p.alpha || 0.9) - (p.decay || 0.01);
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'dark_tendril') {
                    p.x += p.vx; p.y += p.vy;
                    p.theta = (p.theta || 0) + (p.curl || 0.015);
                    p.len = (p.len || 40) * 1.006;
                    p.w = (p.w || 14) * 0.993;
                    p.alpha = (p.alpha || 0.85) - (p.decay || 0.012);
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'shadow_fissure') {
                    p.x += p.vx; p.y += p.vy;
                    p.theta = (p.theta || 0) + (p.jitter || 0.02);
                    p.len = (p.len || 60) * 1.010;
                    p.w = (p.w || 8) * 0.992;
                    p.alpha = (p.alpha || 0.9) - (p.decay || 0.012);
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'orbit_blade') {
                    p.theta = (p.theta || 0) + (p.omega || 0.02);
                    p.alpha = (p.alpha || 0.85) - 0.010;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'eclipse') {
                    p.rot = (p.rot || 0) + 0.012;
                    const gg = Number.isFinite(p.growth) ? p.growth : 2.0;
                    const baseR1 = Number.isFinite(p.r1) ? p.r1 : 100;
                    p.r1 = Math.min(baseR1 + gg, 2000);
                    p.alpha = (p.alpha || 0.95) - 0.012;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'swirl') {
                    p.theta = (p.theta || 0) + 0.06;
                    p.rad = (p.rad || 20) + (p.radv || 1.2);
                    p.alpha = (p.alpha || 0.9) - (p.decay || 0.02);
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'smoke_ring') {
                    p.theta = (p.theta || 0) + (p.omega || 0.04);
                    p.alpha = (p.alpha || 0.8) - 0.008;
                    if (p.alpha <= 0) p.life = 0;
                } else if (p.shape === 'shard') {
                    p.angle = (p.angle || 0) + (p.omega || 0.05);
                }
                if (p.life <= 0) particles.splice(i,1);
            }
            
            if (bossFinale && bossFinale.frames > 0) {
                const t = Date.now();
                if (frameCounter % 3 === 0) {
                    spawnParticles(bossFinale.x, bossFinale.y, 8, 'rgba(0,0,0,0.95)', { style: 'amaterasu', life: 54, spikes: 14 });
                    spawnParticles(bossFinale.x, bossFinale.y, 6, 'rgba(0,0,0,0.9)', { style: 'orbit_blade', rad: 160 + Math.sin(t/240)*30, w: 28 });
                    spawnParticles(bossFinale.x, bossFinale.y, 6, 'rgba(0,0,0,0.85)', { style: 'smoke_ring', rad: 220 + Math.sin(t/280)*40, slow: true });
                    spawnParticles(bossFinale.x, bossFinale.y, 4, 'rgba(0,0,0,0.9)', { style: 'dark_tendril', len: 64, w: 16, slow: true });
                }
            }
            if (bossFinaleCollapse && bossFinaleCollapse.frames > 0) {
                const t = Date.now();
                if (frameCounter % 2 === 0) {
                    spawnParticles(bossFinaleCollapse.x, bossFinaleCollapse.y, 10, 'rgba(0,0,0,0.95)', { style: 'black_flame', slow: true });
                    spawnParticles(bossFinaleCollapse.x, bossFinaleCollapse.y, 6, 'rgba(0,0,0,0.9)', { style: 'shadow_fissure', slow: true });
                    spawnParticles(bossFinaleCollapse.x, bossFinaleCollapse.y, 4, 'rgba(0,0,0,0.85)', { style: 'smoke_ring', rad: 240 + Math.sin(t/220)*30, slow: true });
                }
            }
            for (let i=bossShockwaves.length-1;i>=0;i--) {
                const sw = bossShockwaves[i];
                sw.r += sw.growth || 8;
                sw.alpha = Math.max(0, (sw.alpha||0.9) - 0.025);
                sw.thick = Math.max(0, (sw.thick||12) * 0.98);
                if (sw.alpha <= 0 || sw.thick <= 0.8) bossShockwaves.splice(i,1);
            }
            for (let i=bossTrails.length-1;i>=0;i--) {
                const t = bossTrails[i];
                t.life = (t.life||30) - 1;
                t.alpha = Math.max(0, (t.alpha||0.8) - 0.02);
                if (t.ex !== undefined && frameCounter % 5 === 0) {
                    const fx = t.x + Math.random() * ((t.ex - t.x) || 0);
                    const fy = t.y + Math.random() * ((t.ey - t.y) || 0);
                    spawnParticles(fx, fy, 1, 'rgba(0,0,0,0.9)', { style: 'shadow_fissure', len: (t.w||20)*1.2, w: (t.w||20)*0.35, slow: true });
                }
                if (t.life <= 0) bossTrails.splice(i,1);
            }
            for (let i=shadowRifts.length-1;i>=0;i--) {
                const rf = shadowRifts[i];
                rf.life = (rf.life||0) - 1;
                rf.phase = (rf.phase||0) + 0.06;
                const a = Math.max(0, (rf.life || 0) / (rf.total || 1));
                const rr = Math.max(40, rf.r || 120);
                if (a > 0 && frameCounter % (fxQ >= 0.75 ? 2 : 3) === 0) {
                    const cnt = Math.max(2, Math.round(5*fxQ));
                    for (let s=0;s<cnt;s++) {
                        const ang = (rf.phase||0) + s*(Math.PI*2/cnt) + Math.sin((rf.seed||0)+s)*0.25;
                        const ex = rf.x + Math.cos(ang) * rr*(0.85 + 0.35*Math.random());
                        const ey = rf.y + Math.sin(ang) * rr*(0.85 + 0.35*Math.random());
                        spawnParticles(ex, ey, 1, 'rgba(0,229,255,0.95)', { style: 'swirl', slow: true, nograv: true, width: 2 });
                        if (fxQ >= 0.55 && s % 2 === 0) spawnParticles(ex, ey, 1, 'rgba(255,255,255,0.9)', { style: 'orbit_blade', slow: true, nograv: true, w: 2 });
                    }
                }
                if (rf.life <= 0) {
                    spawnParticles(rf.x, rf.y, Math.max(12, Math.round(24*fxQ)), 'rgba(0,229,255,0.95)', { style: 'swirl', life: 70, width: 5 });
                    spawnParticles(rf.x, rf.y, Math.max(10, Math.round(18*fxQ)), 'rgba(255,255,255,0.9)', { style: 'orbit_blade', slow: true, rad: rr });
                    if (fxQ >= 0.55) spawnParticles(rf.x, rf.y, 2, 'rgba(0,229,255,0.9)', { style: 'orbit_blade', cx: rf.x, cy: rf.y, rad: rr*1.2, w: Math.max(18, rr*0.22), slow: true });
                    bossShockwaves.push({ x: rf.x, y: rf.y, r: Math.max(56, rr*0.9), alpha: 0.95, thick: 18, growth: 16, color: 'rgba(0,229,255,0.95)' });
                    bossShockwaves.push({ x: rf.x, y: rf.y, r: Math.max(110, rr*1.3), alpha: 0.8, thick: 12, growth: 14, color: 'rgba(0,0,60,0.95)' });
                    shadowRifts.splice(i,1);
                }
            }
            if (inkDissolve) {
                const ga = Math.PI * (3 - Math.sqrt(5));
                inkDissolve.phase = (inkDissolve.phase||0) + 0.028;
                inkDissolve.prog = Math.min(1, (inkDissolve.prog||0) + 0.009);
                const ease = 1 - Math.pow(1 - inkDissolve.prog, 3);
                const rad = ease * (inkDissolve.maxR||120);
                const jitA = (inkDissolve.noiseAmp||6) * (1 - ease) * 0.26;
                const sub = 3;
                const seeds = Math.max(8, Math.round(14 * (1 - ease)));
                for (let s=1; s<=sub; s++) {
                    const t = s / sub;
                    const subRad = (inkDissolve.prevRad||0) + (rad - (inkDissolve.prevRad||0)) * t;
                    for (let j=0;j<seeds;j++) {
                        const ang = (inkDissolve.theta||0) + j*ga + t*0.08;
                        const jitter = Math.sin(j*0.6 + (inkDissolve.phase||0)*1.03 + t*0.5) * jitA;
                        const ex = inkDissolve.x + Math.cos(ang) * (subRad + jitter);
                        const ey = inkDissolve.y + Math.sin(ang) * (subRad + jitter);
                        spawnParticles(ex, ey, 1, 'rgba(36,36,36,0.88)', { style: 'melt', ang, slow: true, nograv: true });
                    if (j % 8 === 0 && s === sub) spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.85)', { style: 'ember', ang, slow: true, nograv: true });
                    }
                }
                inkDissolve.theta = (inkDissolve.theta||0) + 0.10;
                inkDissolve.prevRad = rad;
                if (inkDissolve.prog >= 1) { inkDissolve = null; }
            }
            for (let i=introInkRings.length-1;i>=0;i--) { const rg=introInkRings[i]; rg.r += (rg.growth || 5); rg.alpha -= 0.012; rg.phase = (rg.phase || 0) + (rg.phaseSpeed || 0.12); rg.collapse = rg.collapse || false; if (!rg.collapse && (rg.alpha||0) < 0.65) { rg.collapse = true; rg.growth = -7; }
                if ((rg.collapse && rg.r <= 10) || (rg.r >= (rg.maxR || canvas.width*0.90)) || rg.alpha <= 0) {
                    const lvlFlash = (currentLevel === 4);
                    const seeds = lvlFlash ? 60 : 34;
                    const noiseA = (rg.noiseAmp || 7) * (lvlFlash ? 1.0 : 0.7);
                    for (let j=0;j<seeds;j++){
                        const angBase = j*(Math.PI*2/seeds) + (rg.phase||0)*0.45;
                        const jitter = Math.sin(j*0.8 + (rg.phase||0)*1.4) * noiseA;
                        const ex = rg.x + Math.cos(angBase) * (rg.r + (rg.thickness||16)*0.5 + jitter);
                        const ey = rg.y + Math.sin(angBase) * (rg.r + (rg.thickness||16)*0.5 + jitter);
                        spawnParticles(ex, ey, 1, 'rgba(36,36,36,0.92)', { style: 'melt', ang: angBase, slow: true });
                        if (lvlFlash && j % 10 === 0) spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.9)', { style: 'ember', ang: angBase, slow: true });
                        if (lvlFlash && j % 8 === 0) spawnParticles(ex, ey, 1, 'rgba(120,180,255,0.9)', { style: 'swirl', ang: angBase, cx: rg.x, cy: rg.y, slow: true });
                    }
                    introInkRings.splice(i,1);
                }
            }
            floatScores.forEach((fs, i) => { fs.y -= 1; fs.life--; if (fs.life <= 0) floatScores.splice(i,1); });
            summonLabels.forEach((sl, i) => { sl.y -= 0.4; sl.life--; if (sl.life <= 0) summonLabels.splice(i,1); });
            riftLabels.forEach((sl, i) => { sl.y -= 0.5; sl.life--; if (sl.life <= 0) riftLabels.splice(i,1); });
            
            // æ›´æ–°Bossè¡Œä¸º
            pigs.forEach(pig => {
                if (pig.isBoss && pig.health > 0) {
                    updateBossBehavior(pig);
                }
            });
            
            if (weather === 'rain') {
                if (weatherDrops.length < 80) { weatherDrops.push({ x: Math.random()*canvas.width, y: -20 }); }
                for (let i=weatherDrops.length-1;i>=0;i--){ const d=weatherDrops[i]; d.x += 3; d.y += 10; if (d.y > canvas.height) weatherDrops.splice(i,1); }
                windTargetX += (Math.random()-0.5) * 0.002;
            } else if (weather === 'snow' || weather === 'snow_fog') {
                if (weatherSnow.length < 60) { weatherSnow.push({ x: Math.random()*canvas.width, y: -20, r: 2 + Math.random()*2 }); }
                for (let i=weatherSnow.length-1;i>=0;i--){ const s=weatherSnow[i]; s.x += (Math.random()-0.5)*0.8; s.y += 2; if (s.y > canvas.height) weatherSnow.splice(i,1); }
                fogAlpha = weather==='snow_fog' ? 0.26 : 0;
            } else { fogAlpha = 0; }
            if (comboTimer > 0) { comboTimer--; if (comboTimer === 0) comboMultiplier = 1; }
            if (structureChangedFrames > 0) structureChangedFrames--;
            if (settings.windLock) {
                windX += (settings.windValue - windX) * 0.05;
            } else {
                // ç–¯ç‹‚é£åŠ›æ¨¡å¼ï¼šæ¯ç§’éšæœºå˜åŒ– (Crazy Wind Mode)
                // windRandomOffset åœ¨ update() å¼€å¤´æ¯60å¸§æ›´æ–°ä¸€æ¬¡
                const baseWind = getWindForLevel(currentLevel) || 0;
                windTargetX = baseWind + windRandomOffset * 2.0; // æ”¾å¤§éšæœºå¹…åº¦
                
                // å¿«é€Ÿå“åº”å˜åŒ–ï¼Œè€Œä¸æ˜¯ç¼“æ…¢æ’å€¼
                windX += (windTargetX - windX) * 0.08; 
            }
            if (bulletTimeFrames > 0) bulletTimeFrames--;
            if (shakeFrames > 0) shakeFrames--;
            if (shakeKick > 0) { shakeKick *= 0.9; if (shakeKick < 0.05) shakeKick = 0; }
            if (supportPauseFrames > 0) supportPauseFrames--;
            const integScale = hitPauseFrames > 0 ? 0.35 : 1;
            if (hitPauseFrames > 0) hitPauseFrames--;
            const g = (bulletTimeFrames > 0 ? gravity * 0.5 : gravity) * integScale;
            if (activeBird) {
                if (activeBird.shield) activeBird.shield--;
                if (activeBird.blast) activeBird.blast--;
                if (activeBird.magnet) activeBird.magnet--;
                if (activeBird.green && activeBird.green.cooldown > 0) activeBird.green.cooldown--;
            }
            pickups.forEach((pk, idx) => {
                pk.vy += 0.08; pk.y += pk.vy; pk.life--; if (pk.y > canvas.height - 50) { pk.y = canvas.height - 50; pk.vy = 0; }
                const ab = activeBird;
                const pr = ab ? (ab.radius + (ab.magnet ? 40 : 15)) : 0;
                if (ab && Math.hypot(pk.x - ab.x, pk.y - ab.y) < pr) {
                    if (pk.type === 'speed') { ab.velocity.x *= 1.4; ab.velocity.y *= 1.4; }
                    else if (pk.type === 'size') { ab.baseRadius = (ab.baseRadius || ab.radius) * 1.3; ab.radius = ab.baseRadius; }
                    else if (pk.type === 'ammo') { remainingBirds++; updateHUD(); }
                    else if (pk.type === 'shield') { ab.shield = 600; }
                    else if (pk.type === 'blast') { ab.blast = 600; }
                    else if (pk.type === 'magnet') { ab.magnet = 600; }
                    pickups.splice(idx,1);
                    spawnParticles(pk.x, pk.y, 12, '#FFD54F');
                }
                if (pk.life <= 0) pickups.splice(idx,1);
            });
            eggs.forEach((egg, i) => {
                egg.vy += g;
                egg.y += egg.vy;
                if (egg.y + egg.radius > canvas.height - 50) { explodeAt(egg.x, egg.y, 90); eggs.splice(i,1); }
                blocks.forEach(block => {
                    if (block.health > 0 && egg.x > block.x - block.width/2 && egg.x < block.x + block.width/2 && egg.y + egg.radius > block.y - block.height/2 && egg.y - egg.radius < block.y + block.height/2) {
                        explodeAt(egg.x, egg.y, 90); eggs.splice(i,1);
                    }
                });
                pigs.forEach(pig => {
                    const dx = egg.x - pig.x;
                    const dy = egg.y - pig.y;
                    if (Math.sqrt(dx*dx + dy*dy) < egg.radius + pig.radius) { explodeAt(egg.x, egg.y, 90); eggs.splice(i,1); }
                });
            });
            timeLeft = Math.max(0, timeLeft - (bulletTimeFrames > 0 ? 1/120 : 1/60));
            if (cameraUserFrames > 0) {
                cameraUserFrames--;
                targetCameraX = cameraX;
                targetCameraY = cameraY;
                targetCameraScale = cameraScale;
            } else if (introFocusFrames > 0) {
                introFocusFrames--;
                const s = cameraScale || 1;
                if (levelHasPigObjective && pigs.length) {
                    const cx = pigs.reduce((a,p)=>a+p.x,0)/pigs.length;
                    const cy = pigs.reduce((a,p)=>a+p.y,0)/pigs.length;
                    targetCameraX = Math.max(0, cx - canvas.width/(2*s));
                    targetCameraY = Math.max(0, cy - canvas.height/(2*s));
                    targetCameraScale = (settings.cameraScale || getDefaultCameraScale(currentLevel));
                } else if (levelHasTargetObjective) {
                    const tg = blocks.filter(b=>b.isTarget);
                    if (tg.length) {
                        const cx = tg.reduce((a,b)=>a+b.x,0)/tg.length;
                        const cy = tg.reduce((a,b)=>a+b.y,0)/tg.length;
                        targetCameraX = Math.max(0, cx - canvas.width/(2*s));
                        targetCameraY = Math.max(0, cy - canvas.height/(2*s));
                        targetCameraScale = (settings.cameraScale || getDefaultCameraScale(currentLevel));
                    }
                }
            } else if (draggedBird) {
                const s = cameraScale || 1;
                targetCameraX = draggedBird.x - canvas.width/(2*s);
                targetCameraY = draggedBird.y - canvas.height/(2*s);
                targetCameraScale = cameraScale;
            } else if (activeBird && activeBird.launched) {
                const s = cameraScale || 1;
                targetCameraX = activeBird.x - canvas.width/(2*s);
                targetCameraY = activeBird.y - canvas.height/(2*s);
                const baseScale = (settings.cameraScale || getDefaultCameraScale(currentLevel));
                const sp = Math.hypot(activeBird.velocity.x, activeBird.velocity.y);
                const far = sp > 20 ? 0.92 : sp > 14 ? 0.96 : 1.0;
                targetCameraScale = baseScale;
            } else {
                targetCameraX = cameraX;
                targetCameraY = cameraY;
                targetCameraScale = (settings.cameraScale || getDefaultCameraScale(currentLevel));
            }
            cameraX += (targetCameraX - cameraX) * 0.2;
            cameraY += (targetCameraY - cameraY) * 0.2;
            cameraScale += (targetCameraScale - cameraScale) * 0.15;
            clampCamera();
            // æ›´æ–°å°é¸Ÿä½ç½®
            birds.forEach(bird => {
                if (bird.launched) {
                    // --- å¢å¼ºç‰ˆå­å¼¹æŒç»­åŠ¨æ•ˆ (Explosive Bullet Trail) ---
                    const spd = Math.hypot(bird.velocity.x, bird.velocity.y);
                    const particleChance = (fxQ >= 0.75) ? (0.26 + 0.60 * fxQ) : (0.22 + 0.58 * fxQ);
                    
                    if (Math.random() < particleChance) {
                        const t = Date.now() / 1000;
                        // åŸºç¡€é«˜é€Ÿæ‹–å°¾ï¼šå¢åŠ å¯†åº¦å’Œå±‚æ¬¡
                        if (spd > 5) { // é™ä½é€Ÿåº¦é—¨æ§›
                            spawnParticles(
                                bird.x - bird.velocity.x*0.2, 
                                bird.y - bird.velocity.y*0.2, 
                                Math.max(1, Math.round(3 * qFx)),
                                'rgba(255,255,255,0.6)', 
                                { style: 'default', life: 16, w: 4 }
                            );
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(1 * qFx)), 'rgba(255,255,255,0.3)', { style: 'smoke', life: 20, r: 5 });
                        }
                        // è¶…é«˜é€Ÿå…‰æµ (Super Speed Stream)
                        if (spd > 15) {
                             spawnParticles(bird.x, bird.y, Math.max(1, Math.round(2 * qFx)), '#FFFFFF', { style: 'streak', life: 12, w: 5 });
                             spawnParticles(bird.x, bird.y, Math.max(1, Math.round(1 * qFx)), 'rgba(255,255,255,0.5)', { style: 'ring', life: 8, w: 10 });
                        }

                        if (bird.type === 'yellow') {
                            // é»„é¸Ÿï¼šéŸ³çˆ†é—ªç”µ (Sonic Boom Lightning)
                            if (spd > 12) { 
                                spawnParticles(bird.x, bird.y, Math.max(1, Math.round(2 * qFx)), '#FFEB3B', { style: 'lightning', life: 18, w: 4 });
                            }
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(5 * qFx)), 'rgba(255,241,118,0.9)', { style: 'spark', life: 15 });
                            if (bird.abilityUsed) {
                                spawnParticles(bird.x, bird.y, Math.max(1, Math.round(2 * qFx)), 'rgba(255,255,0,0.4)', { style: 'ring', life: 12, w: 16 }); 
                                spawnParticles(bird.x, bird.y, Math.max(1, Math.round(3 * qFx)), '#FFFF00', { style: 'shard', life: 20 });
                            }
                        } else if (bird.type === 'black') {
                            // é»‘é¸Ÿï¼šä»£ç ä¾µèš€ (Code Corruption)
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(2 * qFx)), '#00FF00', { style: 'matrix', life: 30 });
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(8 * qFx)), 'rgba(20,20,20,0.9)', { style: 'default', life: 60, w: 10 });
                            if (Math.random() < 0.5) spawnParticles(bird.x, bird.y, Math.max(1, Math.round(2 * qFx)), '#FF5722', { style: 'spark', life: 25 }); 
                        } else if (bird.type === 'blue') {
                            // è“é¸Ÿï¼šé£˜é›¶ä¹‹ç¾½ (Drifting Feathers)
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(2 * qFx)), 'rgba(255,255,255,0.95)', { style: 'feather', life: 60, w: 4 });
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(5 * qFx)), '#4FC3F7', { style: 'shard', life: 25 });
                            if (bird.abilityUsed) {
                                spawnParticles(bird.x, bird.y, Math.max(1, Math.round(3 * qFx)), 'rgba(128,222,234,0.6)', { style: 'default', life: 20 }); 
                            }
                        } else if (bird.type === 'green') {
                        const isDrive = (bird.spinDriveFrames && bird.spinDriveFrames > 0) || (bird.huntActive && bird.huntTargets && bird.huntTargets.length);
                        const chance = isDrive ? (0.20 + 0.55 * fxQ) : (0.14 + 0.45 * fxQ);
                        if (Math.random() < chance) {
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round((isDrive ? 4 : 3) * qFx)), '#69F0AE', { style: 'spark', life: 24 });
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round((isDrive ? 2 : 1) * qFx)), '#B9F6CA', { style: 'swirl', life: 34, rad: isDrive ? 22 : 18, slow: true });
                            if (fxQ >= 0.55) spawnParticles(bird.x, bird.y, 1, 'rgba(180,255,220,0.55)', { style: 'ring', life: 14, w: 10 });
                            if (FX_OVERDRIVE && fxQ >= 0.75 && Math.random() < 0.22) spawnParticles(bird.x, bird.y, 1, 'rgba(80,255,210,0.55)', { style: 'orbit_blade', cx: bird.x, cy: bird.y, rad: 18 + Math.random()*18, w: 18 + Math.random()*14, slow: true });
                        }
                        if (FX_OVERDRIVE && isDrive && particles.length < MAX_PARTICLES && spawnBudget > 0) {
                            const step = fxHeavy ? 2 : (fxQ >= 0.55 ? 3 : 4);
                            if (frameCounter % step === 0) {
                                particles.push({ x: bird.x, y: bird.y, vx: 0, vy: 0, life: Math.round(12 + 10 * fxQ), color: 'rgba(105,240,174,0.85)', shape: 'afterimage', r: bird.radius * (1.00 + 0.10 * fxQ), alpha: (0.22 + 0.26 * fxQ), nog: true, tint: 'green' });
                                spawnBudget--;
                            }
                        }
                        } else if (bird.type === 'white') {
                            // ç™½é¸Ÿï¼šåœ£å…‰ç¾½è½ (Holy Feathers)
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(3 * qFx)), 'rgba(255, 255, 240, 0.9)', { style: 'feather', life: 50, w: 5 });
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(2 * qFx)), '#FFD700', { style: 'spark', life: 25 });
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(2 * qFx)), 'rgba(255,255,255,0.3)', { style: 'ring', life: 20, w: 10 });
                        } else {
                            // çº¢é¸Ÿï¼šæš´æ€’çº¢å°˜ (Rage Dust) - æ›´åŠ åšé‡
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(6 * qFx)), 'rgba(255, 30, 30, 0.8)', { style: 'smoke', life: 40, r: 8 });
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(3 * qFx)), '#FF0000', { style: 'spark', life: 20 });
                            spawnParticles(bird.x, bird.y, Math.max(1, Math.round(1 * qFx)), 'rgba(255,0,0,0.4)', { style: 'streak', life: 15, w: 6 });
                        }
                    }

                    if (bird.type === 'red' && spd > 7 && particles.length < MAX_PARTICLES && spawnBudget > 0) {
                        const step = FX_OVERDRIVE ? (fxHeavy ? 1 : (fxQ >= 0.55 ? 2 : 3)) : (qFx >= 0.86 ? 2 : 3);
                        if (frameCounter % step === 0) {
                            particles.push({ x: bird.x, y: bird.y, vx: 0, vy: 0, life: FX_OVERDRIVE ? Math.round(18 + 10 * fxQ) : 18, color: 'rgba(255,80,60,0.9)', shape: 'afterimage', r: bird.radius * (FX_OVERDRIVE ? (1.02 + 0.08 * fxQ) : 1), alpha: FX_OVERDRIVE ? (0.45 + 0.27 * fxQ) : (0.32 + 0.22 * qFx), nog: true });
                            spawnBudget--;
                        }
                    }
                    if (FX_OVERDRIVE && bird.type === 'red') {
                        const ang = Math.atan2(bird.velocity.y, bird.velocity.x);
                        const tx = bird.x - bird.velocity.x * 0.25;
                        const ty = bird.y - bird.velocity.y * 0.25;
                        spawnParticles(tx, ty, 1, 'rgba(255,0,90,0.85)', { style: 'amaterasu', life: 26, r0: 5 + Math.random()*3, alpha: 0.9, growth: 0.22, spikes: 10 });
                        if (Math.random() < 0.7 * fxQ) spawnParticles(bird.x, bird.y, 1, 'rgba(140,255,255,0.9)', { style: 'lightning', ang, w: 4, len: 14, speed: 2.8 });
                        if (Math.random() < 0.45 * fxQ) spawnParticles(bird.x, bird.y, 1, 'rgba(255,220,180,0.9)', { style: 'rune', nograv: true });
                        if (Math.random() < 0.85 * fxQ) spawnParticles(bird.x, bird.y, fxHeavy ? 2 : 1, 'rgba(255,80,0,0.65)', { style: 'orbit_blade', cx: bird.x, cy: bird.y, rad: 18 + Math.random()*18, w: 14 + Math.random()*12, ang: Date.now()/260 + Math.random()*0.6, slow: true });
                        if (Math.random() < 0.7 * fxQ) spawnParticles(bird.x, bird.y, 1, 'rgba(80,255,255,0.55)', { style: 'orbit_blade', cx: bird.x, cy: bird.y, rad: 26 + Math.random()*22, w: 10 + Math.random()*10, ang: Date.now()/280 + Math.random()*0.6, slow: true });
                        if (Math.random() < 0.8 * fxQ) spawnParticles(bird.x, bird.y, fxHeavy ? 2 : 1, 'rgba(255,200,90,0.55)', { style: 'smoke_ring', cx: bird.x, cy: bird.y, rad: 18 + Math.random()*26, slow: true });
                        if (Math.random() < 0.6 * fxQ) spawnParticles(bird.x, bird.y, 1, 'rgba(80,255,255,0.45)', { style: 'smoke_ring', cx: bird.x, cy: bird.y, rad: 24 + Math.random()*30, slow: true });
                        if (!bird.trail) bird.trail = [];
                        bird.trail.push({ x: bird.x, y: bird.y, a: ang, s: spd });
                        const maxTrail = Math.max(18, Math.round(18 + 28 * fxQ));
                        if (bird.trail.length > maxTrail) bird.trail.splice(0, bird.trail.length - maxTrail);
                    } else if (bird.trail) {
                        bird.trail.length = 0;
                    }

                    if (bird.inflateFrames && bird.inflateFrames > 0) bird.radius = (bird.baseRadius || bird.radius) * 1.4; else bird.radius = bird.baseRadius || bird.radius;
                    if (bird.inflateFrames && bird.inflateFrames > 0) bird.inflateFrames--;
                    if (bird.spinDriveFrames && bird.spinDriveFrames > 0) {
                        let s = bird.spinInfo;
                        if (!s) { bird.spinInfo = { cx: bird.x, cy: bird.y, ang: Math.atan2(bird.velocity.y, bird.velocity.x), ring: 0, rings: 5, baseR: 20, step: 34, lap: 0 }; s = bird.spinInfo; }
                        const r = (s.baseR || 20) + (s.step || 34) * (s.ring || 0);
                        const omega = 0.28;
                        s.ang = (s.ang || 0) + omega;
                        s.lap = (s.lap || 0) + omega;
                        const tx = (s.cx || bird.x) + Math.cos(s.ang) * r;
                        const ty = (s.cy || bird.y) + Math.sin(s.ang) * r;
                        const den = Math.max(0.001, integScale);
                        bird.velocity.x = (tx - bird.x) / den;
                        bird.velocity.y = (ty - bird.y) / den;
                        bird.auraDamage = Math.max(bird.auraDamage||0, 0.4);
                        if (s.lap >= Math.PI*2 - 1e-6) { s.lap = 0; s.ring = (s.ring||0) + 1; }
                        bird.spinDriveFrames--;
                        if ((s.ring||0) >= (s.rings||5) || bird.spinDriveFrames <= 0) {
                            bird.spinDriveFrames = 0;
                            if (bird.huntTargets && bird.huntTargets.length) {
                                bird.huntActive = true;
                                bird.bladeWidth = 32;
                                const tgt0 = bird.huntTargets[0];
                                if (tgt0) {
                                    const dx0 = (tgt0.x - bird.x), dy0 = (tgt0.y - bird.y);
                                    const dd0 = Math.hypot(dx0, dy0) || 1; const spd0 = 26;
                                    bird.velocity.x = dx0 / dd0 * spd0;
                                    bird.velocity.y = dy0 / dd0 * spd0;
                                }
                            } else {
                                bird.dead = true;
                            }
                        }
                    } else if (bird.huntActive && bird.huntTargets && bird.huntTargets.length) {
                        let ax = 0, ay = 0;
                        let tgt = bird.huntTargets[0];
                        if (!tgt || tgt.health <= 0 || tgt.isBoss) { bird.huntTargets.shift(); tgt = bird.huntTargets[0]; }
                        if (tgt) {
                            const dx = (tgt.x - bird.x), dy = (tgt.y - bird.y);
                            const dd = Math.hypot(dx, dy) || 1; const nx = dx/dd, ny = dy/dd;
                            ax += nx * 0.85; ay += ny * 0.85;
                            bird.velocity.x += ax; bird.velocity.y += ay;
                            const sp = Math.hypot(bird.velocity.x, bird.velocity.y); const maxSp = 26; if (sp > maxSp) { const s = maxSp/sp; bird.velocity.x *= s; bird.velocity.y *= s; }
                            const hitD = Math.hypot(tgt.x - bird.x, tgt.y - bird.y);
                            if (hitD < (tgt.radius || 20) + (bird.radius || 20)) {
                                tgt.health = 0;
                                const idx = pigs.indexOf(tgt);
                                if (idx >= 0) pigs.splice(idx, 1);
                                if (!pigs.length) { gameOver(true); return; }
                                awardScore(50);
                                spawnParticles(tgt.x, tgt.y, 18, '#4CAF50');
                                bird.huntTargets.shift();
                                bird.hasHit = true; bird.targetHit = true;
                                if (!bird.huntTargets.length) {
                                    bird.huntActive = false;
                                    spawnParticles(bird.x, bird.y, 12, '#B0BEC5');
                                    bird.dead = true;
                                }
                            }
                        } else {
                            bird.huntActive = false;
                            spawnParticles(bird.x, bird.y, 12, '#B0BEC5');
                            bird.dead = true;
                        }
                    } else if (bird.type === 'green' && bird.auraDamage) {
                        bird.auraDamage = 0;
                    }
                    if (!bird.trail) bird.trail = [];
                    bird.trail.push({ x: bird.x, y: bird.y });
                    if (bird.trail.length > 40) bird.trail.shift();
                    if (!(bird.type === 'green' && bird.spinDriveFrames && bird.spinDriveFrames > 0)) {
                        bird.velocity.y += g;
                        // Add wind turbulence for difficulty - å¼ºåŠ›éšæœºæ°”æµ
                        const windTurbulence = (Math.random() - 0.5) * (Math.abs(windX) + 0.1) * 2.5; 
                        // å¢åŠ ä¸å¯æ§æ€§ï¼šé£åŠ›å½±å“ç³»æ•°åŠ å¤§
                        bird.velocity.x += (windX + windTurbulence) * (weather==='snow' || weather==='snow_fog' ? 0.8 : 1.2);
                        if (weather==='rain') { bird.velocity.x *= 0.992; bird.velocity.y *= 0.992; }
                        else if (weather==='snow') { bird.velocity.x *= 0.998; bird.velocity.y *= 0.998; }
                        else if (weather==='snow_fog') { bird.velocity.x *= 0.996; bird.velocity.y *= 0.996; }
                    }
                if (bird.weakenFrames && bird.weakenFrames > 0) { bird.weakenFrames--; bird.velocity.x *= 0.94; bird.velocity.y *= 0.94; }
                if (bird.pierceFrames && bird.pierceFrames > 0) { bird.pierceFrames--; }
                if (bird.auraDamage && bird.auraDamage > 0) {
                        blocks.forEach(bk => {
                            if (bk.health > 0 && Math.hypot(bk.x - bird.x, bk.y - bird.y) < (bird.radius + 60)) {
                                bk.health -= bird.auraDamage;
                                if (bk.health > 0) { bird.hasHit = true; if (bk.isTarget) bird.targetHit = true; }
                                if (bk.health <= 0) { bk.fallen = true; bk.rotation = (Math.random()-0.5)*Math.PI/2; awardScore(10); bird.hasHit = true; if (bk.isTarget) bird.targetHit = true; structureChangedFrames = Math.max(structureChangedFrames, 120); }
                            }
                        });
                        
                    }
                    if (bird.type === 'green' && bird.green) {
                        if (bird.green.phase === 'spin') {
                            bird.green.timer--;
                            const ang = Math.atan2(bird.velocity.y, bird.velocity.x);
                            bird.velocity.x += Math.cos(ang + 1.2) * 0.5;
                            bird.velocity.y += Math.sin(ang + 1.2) * 0.5;
                            if (bird.green.timer <= 0) bird.green.phase = 'seek';
                        } else if (bird.green.phase === 'seek') {
                            let tgt = null; let md = 1e9;
                            for (let i=0;i<pigs.length;i++) { const p = pigs[i]; if (p.health > 0) { const d = Math.hypot(p.x - bird.x, p.y - bird.y); if (d < md) { md = d; tgt = p; } } }
                            if (tgt) {
                                const lx = (tgt.vx||0) * 6, ly = (tgt.vy||0) * 6;
                                const dx = (tgt.x + lx) - bird.x, dy = (tgt.y + ly) - bird.y;
                                const dd = Math.hypot(dx, dy) || 1; const nx = dx/dd, ny = dy/dd;
                                const tx = -ny, ty = nx;
                                const acc = 0.22, orbit = 0.012;
                                let ax = nx*acc + tx*orbit, ay = ny*acc + ty*orbit;
                                const floorY = canvas.height - 50; const clearance = 36;
                                if (bird.y + bird.radius > floorY - clearance) { if (ay > 0) ay *= 0.25; const k = Math.min(1, (bird.y + bird.radius - (floorY - clearance))/clearance); ay -= 0.30*k; if (bird.velocity.y > 2.0) bird.velocity.y *= 0.85; }
                                bird.velocity.x += ax; bird.velocity.y += ay;
                                const sp = Math.hypot(bird.velocity.x, bird.velocity.y); const maxSp = 20; if (sp > maxSp) { const s = maxSp/sp; bird.velocity.x *= s; bird.velocity.y *= s; }
                                if (bird.green.cooldown <= 0 && bird.green.dashes > 0 && md < 140) { bird.green.phase = 'dash'; bird.green.timer = 14; }
                            }
                        } else if (bird.green.phase === 'dash') {
                            bird.green.timer--;
                            const sp = Math.hypot(bird.velocity.x, bird.velocity.y) || 1;
                            bird.velocity.x *= 1.08; bird.velocity.y *= 1.08;
                            if (bird.green.timer <= 0) { bird.green.dashes--; bird.green.cooldown = 14; bird.green.phase = bird.green.dashes>0 ? 'seek' : 'end'; }
                        } else if (bird.green.phase === 'end') {
                            bird.green.endLoop = (bird.green.endLoop||0) + 1;
                            const ang = Math.atan2(bird.velocity.y, bird.velocity.x);
                            bird.velocity.x += Math.cos(ang + 1.4) * 0.3;
                            bird.velocity.y += Math.sin(ang + 1.4) * 0.3;
                        }
                    }
                    const oldX = bird.x, oldY = bird.y;
                    const nxStep = bird.velocity.x * integScale;
                    const nyStep = bird.velocity.y * integScale;
                    const sub = Math.max(1, Math.min(2, Math.ceil(Math.hypot(nxStep, nyStep)/24)));
                    for (let si=1; si<=sub; si++) {
                        const frac = si/sub;
                        bird.x = oldX + nxStep * frac;
                        bird.y = oldY + nyStep * frac;
                        pigs.forEach((pig, index) => {
                            if (pig.health > 0 && Math.hypot(bird.x - pig.x, bird.y - pig.y) < bird.radius + pig.radius) {
                                const spdHit = Math.hypot(bird.velocity.x, bird.velocity.y);
                                impactRings.push({ x: pig.x, y: pig.y, r: 0, maxR: 20 + Math.min(60, spdHit*3), alpha: 0.8 });
                                hitPauseFrames = Math.max(hitPauseFrames, spdHit > 6 ? 5 : 0);
                                if (typeof playImpactSound === 'function') { playImpactSound(Math.min(1, spdHit / 12)); }
                                if (pig.escort) { pig.vx = (pig.vx || 0) + bird.velocity.x * 0.2; pig.vy = (pig.vy || 0) + bird.velocity.y * 0.2; }
                                else {
                                    if (pig.isBoss) {
                                        if (pig.bossGrace && pig.bossGrace > 0) { pig.bossGrace--; }
                                        else if (!bird.bossHit) { pig.health -= 1; pig.bossShield = 12; onBossDamaged(pig, 1); bird.bossHit = true; }
                                    } else { pig.health -= 2; }
                                    if (pig.health <= 0) { pigs.splice(index,1); awardScore(50); spawnParticles(pig.x, pig.y, 18, '#4CAF50'); bird.hasHit = true; bird.targetHit = true; }
                                }
                            }
                        });
                    }
                    if (bird.type === 'green' && (bird.spinDriveFrames && bird.spinDriveFrames > 0 || (bird.huntActive && bird.huntTargets && bird.huntTargets.length))) {
                        const sx = oldX, sy = oldY, ex = bird.x, ey = bird.y;
                        const dx = ex - sx, dy = ey - sy; const len2 = dx*dx + dy*dy;
                        const cut = (bird.bladeWidth || 28);
                        for (let i = pigs.length - 1; i >= 0; i--) {
                            const p = pigs[i]; if (p.health <= 0) continue;
                            const ux = p.x - sx, uy = p.y - sy; const t = len2 ? Math.max(0, Math.min(1, (ux*dx + uy*dy) / len2)) : 0;
                            const px = sx + t*dx, py = sy + t*dy;
                            const dist = Math.hypot(p.x - px, p.y - py);
                            if (dist < cut + (p.radius || 20) * 0.80) {
                                p.health = 0;
                                pigs.splice(i, 1);
                                if (!pigs.length) { gameOver(true); return; }
                                awardScore(50);
                                spawnParticles(p.x, p.y, 18, '#4CAF50');
                                bird.hasHit = true; bird.targetHit = true;
                            }
                        }
                        blocks.forEach(block => {
                            if (!(block.health > 0)) return;
                            const ux = block.x - sx, uy = block.y - sy; const t = len2 ? Math.max(0, Math.min(1, (ux*dx + uy*dy) / len2)) : 0;
                            const px = sx + t*dx, py = sy + t*dy;
                            const dist = Math.hypot(block.x - px, block.y - py);
                            const thresh = cut + Math.min((block.width||12),(block.height||12)) * 0.60;
                            if (dist < thresh) {
                                block.health = 0;
                                block.fallen = true;
                                block.rotation = (Math.random() - 0.5) * Math.PI / 2;
                                awardScore(10);
                                const pc = block.material === 'glass' ? '#BDE1FF' : block.material === 'metal' ? '#B0BEC5' : block.material === 'rubber' ? '#7E57C2' : block.material === 'ice' ? '#BDE1FF' : block.material === 'flammable' ? '#FF8F00' : '#A0522D';
                                const style = block.material === 'glass' ? 'streak' : block.material === 'metal' ? 'ring' : block.material === 'ice' ? 'shard' : block.material === 'flammable' ? 'streak' : (block.material === 'rubber' ? 'default' : 'streak');
                                spawnParticles(block.x, block.y, 14, pc, { style });
                                if (block.material === 'barrel') { explodeAt(block.x, block.y, 110); }
                                if (precisionMode && !block.isTarget) precisionFail = true;
                                if (precisionMode && block.isTarget) awardTargetBonus(8);
                                if (block.isTarget && !block._counted) { targetsDestroyed++; block._counted = true; completedTargets.push({ label: block.label || ('T'+targetsDestroyed), x: Math.round(block.x), y: Math.round(block.y), material: block.material }); }
                                bird.hasHit = true; if (block.isTarget) bird.targetHit = true;
                            }
                        });
                        if (bird.seekers && bird.seekers.length) {
                            for (let si = bird.seekers.length - 1; si >= 0; si--) {
                                const s = bird.seekers[si];
                                if (!s.target || s.target.health <= 0) {
                                    const opts = pigs.filter(p=>p.health>0);
                                    s.target = opts.length ? opts[Math.floor(Math.random()*opts.length)] : null;
                                }
                                if (s.target) {
                                    const dx2 = s.target.x - s.x, dy2 = s.target.y - s.y;
                                    const dd2 = Math.hypot(dx2, dy2) || 1; const nx2 = dx2/dd2, ny2 = dy2/dd2;
                                    s.vx = (s.vx||0) + nx2 * 0.55; s.vy = (s.vy||0) + ny2 * 0.55;
                                    const sp2 = Math.hypot(s.vx, s.vy) || 1; const ms2 = 8; if (sp2 > ms2) { const k = ms2/sp2; s.vx *= k; s.vy *= k; }
                                    s.x += s.vx; s.y += s.vy;
                                    const dtt = Math.hypot(s.target.x - s.x, s.target.y - s.y);
                                    if (dtt < (s.target.radius || 20) + 6) {
                                        s.target.health = 0;
                                        const idx = pigs.indexOf(s.target);
                                        if (idx >= 0) pigs.splice(idx, 1);
                                        awardScore(50);
                                        spawnParticles(s.target.x, s.target.y, 18, '#4CAF50');
                                        bird.hasHit = true; bird.targetHit = true;
                                        s.life = 0;
                                    }
                                }
                                s.life = (s.life||240) - 1;
                                if (s.life <= 0) bird.seekers.splice(si, 1);
                            }
                        }
                    }

                    if (bird.tpCooldown && bird.tpCooldown > 0) bird.tpCooldown--;
                    portals.forEach(p => {
                        if (!bird.tpCooldown && bird.x > p.x && bird.x < p.x + p.w && bird.y > p.y && bird.y < p.y + p.h) {
                            bird.x = p.exitX;
                            bird.y = p.exitY;
                            bird.velocity.x *= 1.05;
                            bird.velocity.y *= 1.05;
                            bird.tpCooldown = 30;
                            spawnParticles(bird.x, bird.y, 8, '#000', { style: 'void_lightning', len: 20, w: 2 });
                            spawnParticles(bird.x, bird.y, 10, 'rgba(0,0,0,0.8)');
                        }
                    });

                    wheels.forEach(w => {
                        if (bird.type === 'green' && ((bird.spinDriveFrames && bird.spinDriveFrames > 0) || (bird.huntActive && bird.huntTargets && bird.huntTargets.length))) return;
                        w.angle += w.omega;
                        const dx = bird.x - w.x; const dy = bird.y - w.y; const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < bird.radius + w.r) {
                            const nx = dx / dist; const ny = dy / dist;
                            const dot = bird.velocity.x * nx + bird.velocity.y * ny;
                            bird.velocity.x -= 2 * dot * nx;
                            bird.velocity.y -= 2 * dot * ny;
                            bird.x = w.x + nx * (w.r + bird.radius + 0.1);
                            bird.y = w.y + ny * (w.r + bird.radius + 0.1);
                            spawnParticles(bird.x, bird.y, 10, '#CFD8DC');
                        }
                    });

                    // è½åœ°å¤„ç†
                    if (bird.y + bird.radius >= canvas.height - 50) {
                        if (bird.type === 'green' && ((bird.spinDriveFrames && bird.spinDriveFrames > 0) || (bird.huntActive && bird.huntTargets && bird.huntTargets.length))) {
                            bird.y = canvas.height - 50 - bird.radius;
                            bird.velocity.y = -Math.abs(bird.velocity.y) * 0.95;
                            bird.velocity.x *= 0.98;
                        } else if (bird.type === 'green' && ((bird.attackCharges||0) > 0 || (bird.homingFrames&&bird.homingFrames>0))) {
                            bird.y = canvas.height - 50 - bird.radius;
                            bird.velocity.y = -Math.abs(bird.velocity.y) * 0.9;
                            bird.velocity.x *= 0.95;
                        } else {
                            spawnParticles(bird.x, bird.y, 10, '#B0BEC5');
                            bird.dead = true;
                            return;
                        }
                    }

                    // é£æ´å½±å“
                    windTunnels.forEach(t => {
                        if (bird.x > t.x && bird.x < t.x + t.w && bird.y > t.y && bird.y < t.y + t.h) {
                            bird.velocity.x += t.forceX;
                            bird.velocity.y += t.forceY;
                        }
                    });
                    // å¼¹è·³æ¿ç¢°æ’
                    bouncers.forEach(b => {
                        if (bird.x + bird.radius > b.x && bird.x - bird.radius < b.x + b.w && bird.y + bird.radius > b.y && bird.y - bird.radius < b.y + b.h) {
                            if (bird.velocity.y > 0) {
                                bird.y = b.y - bird.radius;
                                bird.velocity.y = -Math.abs(bird.velocity.y) * 1.2;
                                bird.velocity.x *= 0.9;
                                spawnParticles(bird.x, bird.y, 10, '#7E57C2');
                            }
                        }
                    });
                    // æ£€æŸ¥ä¸æœ¨å—çš„ç¢°æ’
                    blocks.forEach(block => {
                        if (block.health > 0 && checkCollision(bird, block) && !(bird.type === 'green' && (bird.spinDriveFrames && bird.spinDriveFrames > 0 || (bird.huntActive && bird.huntTargets && bird.huntTargets.length)))) {
                            if (block.material === 'boss_fence') {
                                const sp = Math.hypot(bird.velocity.x, bird.velocity.y);
                                const dmgFence = Math.max(0, Math.floor((sp - 18) / 15));
                                block.health -= dmgFence;
                                if (bird.spinDriveFrames && bird.spinDriveFrames > 0) {
                                    bird.velocity.x *= 0.98;
                                    bird.velocity.y *= 0.98;
                                } else if (bird.pierceFrames && bird.pierceFrames > 0) {
                                    bird.velocity.x *= 0.9;
                                    bird.velocity.y *= 0.9;
                                } else {
                                    bird.velocity.x *= 0.55;
                                    bird.velocity.y *= 0.55;
                                }
                                const dir = Math.sign(bird.x - block.x) || 1;
                                block.rotation = (block.rotation || 0) + dir * Math.min(0.14, sp * 0.0055);
                                if (block.baseX !== undefined && block.baseY !== undefined) {
                                    block.x += bird.velocity.x * 0.08;
                                    block.y += bird.velocity.y * 0.05;
                                }
                                bird.weakenFrames = Math.max(bird.weakenFrames||0, 100);
                                bird.hasHit = true; if (block.isTarget) bird.targetHit = true;
                            } else if (block.material === 'fence') {
                                const sp = Math.hypot(bird.velocity.x, bird.velocity.y);
                                const dmgFence = Math.max(0, Math.floor((sp - 14) / 10));
                                block.health -= dmgFence;
                                if (bird.spinDriveFrames && bird.spinDriveFrames > 0) {
                                    bird.velocity.x *= 0.98;
                                    bird.velocity.y *= 0.98;
                                } else if (bird.pierceFrames && bird.pierceFrames > 0) {
                                    bird.velocity.x *= 0.9;
                                    bird.velocity.y *= 0.9;
                                } else {
                                    bird.velocity.x *= 0.55;
                                    bird.velocity.y *= 0.55;
                                }
                                const dir = Math.sign(bird.x - block.x) || 1;
                                block.rotation = (block.rotation || 0) + dir * Math.min(0.14, sp * 0.0055);
                                if (block.baseX !== undefined && block.baseY !== undefined) {
                                    block.x += bird.velocity.x * 0.08;
                                    block.y += bird.velocity.y * 0.05;
                                }
                                bird.weakenFrames = Math.max(bird.weakenFrames||0, 100);
                                bird.hasHit = true; if (block.isTarget) bird.targetHit = true;
                            } else {
                            const spd = Math.hypot(bird.velocity.x, bird.velocity.y);
                            const crit = Math.random() < 0.2 ? 2 : 1;
                            let dmg = Math.max(1, Math.floor(spd / 4)) * crit;
                            if (bird.spinDriveFrames && bird.spinDriveFrames > 0) { dmg = Math.floor(dmg * 2.4); }
                            block.health -= dmg;
                            structureChangedFrames = Math.max(structureChangedFrames, 90);
                            const hx = block.width/2 + bird.radius - Math.abs(bird.x - block.x);
                            const hy = block.height/2 + bird.radius - Math.abs(bird.y - block.y);
                            let nx = 0, ny = 0;
                            if (hx < hy) { nx = Math.sign(bird.x - block.x) || 1; ny = 0; } else { ny = Math.sign(bird.y - block.y) || 1; nx = 0; }
                            const restitution = block.material === 'rubber' ? 0.9 : block.material === 'metal' ? 0.7 : block.material === 'glass' ? 0.4 : block.material === 'barrel' ? 0.3 : (block.material === 'fence' || block.material === 'boss_fence') ? 0.2 : block.material === 'ice' ? 0.6 : 0.5;
                            const dotv = bird.velocity.x*nx + bird.velocity.y*ny;
                            bird.velocity.x -= (1+restitution) * dotv * nx;
                            bird.velocity.y -= (1+restitution) * dotv * ny;
                            impactRings.push({ x: bird.x, y: bird.y, r: 0, maxR: 20 + Math.min(60, dmg*4), alpha: 0.8 });
                            floatScores.push({ x: bird.x, y: bird.y, text: `-${dmg}`, life: 28 });
                            shakeFrames = Math.max(shakeFrames, Math.min(12, 4 + Math.floor(dmg*0.6)));
                            if (bird.type === 'red') {
                                impactRings.push({ x: bird.x, y: bird.y, r: 0, maxR: 180, alpha: 0.85, growth: 5.6, decay: 0.018, rgb: '255,80,0', w: 3, spiky: true, phase: Math.random() * 10, noise: 8 + dmg * 1.6, nDecay: 0.94 });
                                impactRings.push({ x: bird.x, y: bird.y, r: 0, maxR: 120, alpha: 0.75, growth: 3.8, decay: 0.026, rgb: '255,220,120', w: 2 });
                                if (FX_OVERDRIVE && fxHeavy) impactRings.push({ x: bird.x, y: bird.y, r: 0, maxR: 220, alpha: 0.75, growth: 7.8, decay: 0.020, rgb: '80,255,255', w: 2.6, spiky: true, phase: Math.random() * 10, noise: 9 + dmg * 1.2, nDecay: 0.95 });
                                flashFrames = Math.max(flashFrames, Math.min(FX_OVERDRIVE ? 18 : 10, (FX_OVERDRIVE ? 8 : 4) + Math.floor(dmg * (FX_OVERDRIVE ? 1.4 : 0.8))));
                                flashColor = '#FF6A00';
                                flashWorldX = bird.x;
                                flashWorldY = bird.y;
                                lensFrames = Math.max(lensFrames, FX_OVERDRIVE ? 26 : 14);
                                lensColor = 'rgba(255,120,0,1)';
                                lensWorldX = bird.x;
                                lensWorldY = bird.y;
                                shakeKick = Math.max(shakeKick, Math.min(FX_OVERDRIVE ? 12 : 6, (FX_OVERDRIVE ? 4.2 : 1.6) + dmg * (FX_OVERDRIVE ? 1.1 : 0.6)));
                                if (FX_OVERDRIVE && fxQ >= 0.65) {
                                    spawnParticles(bird.x, bird.y, fxHeavy ? 2 : 1, 'rgba(255,60,0,0.95)', { style: 'eclipse', life: 52, rad: 14 + dmg * 1.2, len: 240 + dmg * 14, alpha: 0.85, growth: 10, spikes: 22 });
                                    if (fxHeavy) spawnParticles(bird.x, bird.y, 1, 'rgba(80,255,255,0.75)', { style: 'eclipse', life: 46, rad: 10 + dmg * 0.8, len: 210 + dmg * 12, alpha: 0.55, growth: 9, spikes: 18 });
                                }
                                spawnParticles(bird.x, bird.y, Math.max(1, Math.round((FX_OVERDRIVE ? 26 : 10) * qFx)), 'rgba(255,120,0,0.85)', { style: 'ember', life: 26 });
                                spawnParticles(bird.x, bird.y, Math.max(1, Math.round((FX_OVERDRIVE ? 14 : 5) * qFx)), 'rgba(255,40,0,0.85)', { style: 'streak', life: 18, w: 6 });
                                spawnParticles(bird.x, bird.y, Math.max(1, Math.round((FX_OVERDRIVE ? 18 : 6) * qFx)), 'rgba(140,255,255,0.9)', { style: 'lightning', life: 26, w: 5 });
                                if (FX_OVERDRIVE && fxHeavy) spawnParticles(bird.x, bird.y, 6, 'rgba(255,70,180,0.85)', { style: 'lightning', life: 24, w: 4 });
                                if (fxQ >= 0.62 && particles.length < MAX_PARTICLES && spawnBudget > 0) {
                                    const ang = Math.atan2(bird.velocity.y, bird.velocity.x);
                                    const w = (FX_OVERDRIVE ? 16 : 10) + dmg * (FX_OVERDRIVE ? 1.9 : 1.2);
                                    const len = (FX_OVERDRIVE ? 70 : 40) + dmg * (FX_OVERDRIVE ? 10 : 7);
                                    particles.push({ x: bird.x, y: bird.y, vx: 0, vy: 0, life: FX_OVERDRIVE ? 18 : 14, shape: 'impact_slash', theta: ang, len, w, alpha: 1.0, decay: FX_OVERDRIVE ? 0.06 : 0.08, nog: true });
                                    spawnBudget--;
                                    if (particles.length < MAX_PARTICLES && spawnBudget > 0) { particles.push({ x: bird.x, y: bird.y, vx: 0, vy: 0, life: FX_OVERDRIVE ? 16 : 12, shape: 'impact_slash', theta: ang + 0.65, len: len * 0.85, w: w * 0.8, alpha: 0.9, decay: FX_OVERDRIVE ? 0.07 : 0.095, nog: true }); spawnBudget--; }
                                    if (FX_OVERDRIVE && fxHeavy && particles.length < MAX_PARTICLES && spawnBudget > 0) { particles.push({ x: bird.x, y: bird.y, vx: 0, vy: 0, life: 14, shape: 'impact_slash', theta: ang - 0.85, len: len * 0.78, w: w * 0.72, alpha: 0.85, decay: 0.075, nog: true }); spawnBudget--; }
                                }
                            }
                            hitPauseFrames = Math.max(hitPauseFrames, dmg >= 4 ? 6 : 0);
                            if (typeof playImpactSoundMaterial === 'function') { playImpactSoundMaterial(block.material, Math.min(1, dmg / 12)); }
                            if (dmg > 0) { bird.hasHit = true; if (block.isTarget) bird.targetHit = true; awardScore(getMaterialBonus(block.material,'hit',dmg)); }
                        }
                            if (block.health <= 0) {
                                // æœ¨æ¿è¢«å‡»å€’ï¼Œå¼€å§‹å€’ä¸‹
                                block.fallen = true;
                                // éšæœºæ—‹è½¬è§’åº¦ï¼Œæ¨¡æ‹ŸçœŸå®çš„å€’ä¸‹æ•ˆæœ
                                block.rotation = (Math.random() - 0.5) * Math.PI / 2;
                                block.bossId = null; block.dx = undefined; block.dy = undefined;
                                {
                                    const approx = (typeof dmg==='number') ? dmg : Math.floor(Math.hypot(bird.velocity.x,bird.velocity.y)/4);
                                    awardScore(10 + getMaterialBonus(block.material,'break',approx));
                                    structureChangedFrames = Math.max(structureChangedFrames, 120);
                                }
                                const pc = block.material === 'glass' ? '#BDE1FF' : block.material === 'metal' ? '#B0BEC5' : block.material === 'rubber' ? '#7E57C2' : block.material === 'ice' ? '#BDE1FF' : block.material === 'flammable' ? '#FF8F00' : '#A0522D';
                                const style = block.material === 'glass' ? 'streak' : block.material === 'metal' ? 'ring' : block.material === 'ice' ? 'shard' : block.material === 'flammable' ? 'streak' : (block.material === 'rubber' ? 'default' : 'streak');
                                spawnParticles(block.x, block.y, 14, pc, { style });
                                if (Math.random() < 0.4) spawnPickup(block.x, block.y);
                                if (block.material === 'barrel') { explodeAt(block.x, block.y, 110); }
                                if (precisionMode && !block.isTarget) precisionFail = true;
                                if (precisionMode && block.isTarget) awardTargetBonus(8);
                                if (block.isTarget && !block._counted) { targetsDestroyed++; block._counted = true; completedTargets.push({ label: block.label || ('T'+targetsDestroyed), x: Math.round(block.x), y: Math.round(block.y), material: block.material }); }
                            }
                            bounce(bird, block);
                            if (block.material === 'ice') {
                                block.health -= 1;
                            } else if (block.material === 'rubber') {
                                bird.velocity.y *= -0.8;
                                bird.velocity.x *= 1.05;
                            } else if (block.material === 'flammable') {
                                if (Math.abs(bird.velocity.x) + Math.abs(bird.velocity.y) > 6) { block.onFire = true; structureChangedFrames = Math.max(structureChangedFrames, 60); if (!block._igniteCounted) { awardScore(getMaterialBonus('flammable','ignite', Math.abs(bird.velocity.x) + Math.abs(bird.velocity.y))); block._igniteCounted = true; } }
                            } else if (block.material === 'metal') {
                                bird.velocity.y *= -0.5; bird.velocity.x *= 0.9;
                            } else if (block.material === 'glass') {
                                block.health -= 1;
                                structureChangedFrames = Math.max(structureChangedFrames, 60);
                            }
                        }
                    });

                    // æ£€æŸ¥ä¸çŒªçš„ç¢°æ’
                    pigs.forEach((pig, index) => {
                        if (pig.health > 0 && checkPigCollision(bird, pig)) {
                            const spdHit = Math.hypot(bird.velocity.x, bird.velocity.y);
                            impactRings.push({ x: pig.x, y: pig.y, r: 0, maxR: 20 + Math.min(60, spdHit*3), alpha: 0.8 });
                            hitPauseFrames = Math.max(hitPauseFrames, spdHit > 6 ? 5 : 0);
                            if (bird.type === 'red') {
                                const pwr = Math.min(18, 6 + spdHit * 1.2);
                                impactRings.push({ x: pig.x, y: pig.y, r: 0, maxR: 220, alpha: 0.9, growth: 6.4, decay: 0.016, rgb: '255,50,0', w: 3, spiky: true, phase: Math.random() * 10, noise: 10 + pwr * 2.0, nDecay: 0.94 });
                                impactRings.push({ x: pig.x, y: pig.y, r: 0, maxR: 140, alpha: 0.8, growth: 4.2, decay: 0.024, rgb: '255,210,120', w: 2 });
                                if (FX_OVERDRIVE && fxHeavy) impactRings.push({ x: pig.x, y: pig.y, r: 0, maxR: 260, alpha: 0.75, growth: 8.4, decay: 0.020, rgb: '80,255,255', w: 2.8, spiky: true, phase: Math.random() * 10, noise: 10 + pwr * 1.4, nDecay: 0.95 });
                                flashFrames = Math.max(flashFrames, Math.min(FX_OVERDRIVE ? 20 : 12, (FX_OVERDRIVE ? 10 : 5) + Math.floor(pwr * (FX_OVERDRIVE ? 0.9 : 0.35))));
                                flashColor = '#FF3D00';
                                flashWorldX = pig.x;
                                flashWorldY = pig.y;
                                lensFrames = Math.max(lensFrames, FX_OVERDRIVE ? 30 : 16);
                                lensColor = 'rgba(255,40,0,1)';
                                lensWorldX = pig.x;
                                lensWorldY = pig.y;
                                shakeFrames = Math.max(shakeFrames, Math.min(14, 6 + Math.floor(pwr * 0.25)));
                                shakeKick = Math.max(shakeKick, Math.min(FX_OVERDRIVE ? 14 : 7, (FX_OVERDRIVE ? 5.0 : 2.2) + pwr * (FX_OVERDRIVE ? 0.6 : 0.22)));
                                if (FX_OVERDRIVE && fxQ >= 0.65) {
                                    spawnParticles(pig.x, pig.y, fxHeavy ? 2 : 1, 'rgba(255,40,0,0.95)', { style: 'eclipse', life: 54, rad: 16 + pwr * 1.1, len: 270 + pwr * 14, alpha: 0.88, growth: 11, spikes: 24 });
                                    if (fxHeavy) spawnParticles(pig.x, pig.y, 1, 'rgba(80,255,255,0.75)', { style: 'eclipse', life: 48, rad: 11 + pwr * 0.7, len: 230 + pwr * 12, alpha: 0.58, growth: 10, spikes: 18 });
                                }
                                spawnParticles(pig.x, pig.y, Math.max(1, Math.round((FX_OVERDRIVE ? 34 : 14) * qFx)), 'rgba(255,140,0,0.9)', { style: 'ember', life: 28 });
                                spawnParticles(pig.x, pig.y, Math.max(1, Math.round((FX_OVERDRIVE ? 22 : 8) * qFx)), 'rgba(255,60,0,0.8)', { style: 'spark', life: 22 });
                                spawnParticles(pig.x, pig.y, Math.max(1, Math.round((FX_OVERDRIVE ? 10 : 4) * qFx)), 'rgba(255,255,255,0.7)', { style: 'ring', life: 14, w: 12 });
                                spawnParticles(pig.x, pig.y, Math.max(1, Math.round((FX_OVERDRIVE ? 22 : 7) * qFx)), 'rgba(140,255,255,0.9)', { style: 'lightning', life: 26, w: 6 });
                                if (FX_OVERDRIVE && fxHeavy) spawnParticles(pig.x, pig.y, 8, 'rgba(255,70,180,0.85)', { style: 'lightning', life: 24, w: 5 });
                                if (fxQ >= 0.62 && particles.length < MAX_PARTICLES && spawnBudget > 0) {
                                    const ang = Math.atan2(bird.velocity.y, bird.velocity.x);
                                    const w = (FX_OVERDRIVE ? 18 : 12) + pwr * (FX_OVERDRIVE ? 0.95 : 0.55);
                                    const len = (FX_OVERDRIVE ? 86 : 54) + pwr * (FX_OVERDRIVE ? 10 : 6.5);
                                    particles.push({ x: pig.x, y: pig.y, vx: 0, vy: 0, life: FX_OVERDRIVE ? 18 : 14, shape: 'impact_slash', theta: ang, len, w, alpha: 1.0, decay: FX_OVERDRIVE ? 0.06 : 0.08, nog: true });
                                    spawnBudget--;
                                    if (particles.length < MAX_PARTICLES && spawnBudget > 0) { particles.push({ x: pig.x, y: pig.y, vx: 0, vy: 0, life: FX_OVERDRIVE ? 16 : 12, shape: 'impact_slash', theta: ang - 0.55, len: len * 0.82, w: w * 0.78, alpha: 0.9, decay: FX_OVERDRIVE ? 0.07 : 0.095, nog: true }); spawnBudget--; }
                                    if (FX_OVERDRIVE && fxHeavy && particles.length < MAX_PARTICLES && spawnBudget > 0) { particles.push({ x: pig.x, y: pig.y, vx: 0, vy: 0, life: 14, shape: 'impact_slash', theta: ang + 0.95, len: len * 0.75, w: w * 0.72, alpha: 0.85, decay: 0.075, nog: true }); spawnBudget--; }
                                }
                            }
                            if (typeof playImpactSound === 'function') { playImpactSound(Math.min(1, spdHit / 12)); }
                            if (bird.type === 'green' && bird.green && bird.green.phase === 'dash') {
                                if (pig.isBoss) {
                                    if (pig.bossShield && pig.bossShield > 0) { spawnParticles(pig.x, pig.y, 12, 'rgba(0,0,0,0.95)', { style: 'amaterasu' }); }
                                    bird.hasHit = true; bird.targetHit = true;
                                    bird.velocity.x *= 0.92; bird.velocity.y *= 0.92;
                                } else {
                                    pig.health = 0;
                                    if (pig.isBoss) { onBossDeath(); pig.deathFrames = Math.max(pig.deathFrames||0, 90); pig._removeOnDeath = true; }
                                    else {
                                        pigs.splice(index, 1);
                                        awardScore(50);
                                        spawnParticles(pig.x, pig.y, 18, '#4CAF50');
                                    }
                                    bird.hasHit = true; bird.targetHit = true;
                                    bird.velocity.x *= 0.92; bird.velocity.y *= 0.92;
                                }
                                bird.green.timer = 0; bird.green.dashes = Math.max(0, (bird.green.dashes||0)-1); bird.green.cooldown = 10; bird.green.phase = bird.green.dashes>0 ? 'seek' : 'end';
                            } else if (bird.spinDriveFrames && bird.spinDriveFrames > 0) {
                                if (pig.isBoss) {
                                    if (bird.type === 'green') {
                                        if (pig.bossShield && pig.bossShield > 0) { spawnParticles(pig.x, pig.y, 12, 'rgba(0,0,0,0.95)', { style: 'amaterasu' }); }
                                        bird.hasHit = true; bird.targetHit = true;
                                        bird.velocity.x *= 0.92; bird.velocity.y *= 0.92;
                                    } else {
                                        if (pig.bossShield && pig.bossShield > 0) { spawnParticles(pig.x, pig.y, 12, 'rgba(0,0,0,0.95)', { style: 'amaterasu' }); }
                                        else if (!bird.bossHit) { pig.health -= 1; pig.bossShield = 12; onBossDamaged(pig, 1); bird.bossHit = true; spawnParticles(pig.x, pig.y, 6, '#000', { style: 'void_lightning', len: 40, w: 2 }); spawnParticles(pig.x, pig.y, 10, 'rgba(0,0,0,0.9)', { style: 'black_flame' }); }
                                        if (bird.type === 'yellow') { bird.pierceFrames = 0; bird.velocity.x *= 0.8; bird.velocity.y *= 0.8; bird.dead = true; }
                                        pig.vx = (pig.vx || 0) + bird.velocity.x * 0.15;
                                        pig.vy = (pig.vy || 0) + bird.velocity.y * 0.15;
                                        bird.hasHit = true; bird.targetHit = true;
                                        bird.velocity.x *= 0.92; bird.velocity.y *= 0.92;
                                    }
                                } else {
                                    pig.health = 0;
                                    if (pig.isBoss) { onBossDeath(); pig.deathFrames = Math.max(pig.deathFrames||0, 90); pig._removeOnDeath = true; }
                                    else {
                                        pigs.splice(index, 1);
                                        awardScore(50);
                                        spawnParticles(pig.x, pig.y, 18, '#4CAF50');
                                    }
                                    bird.hasHit = true; bird.targetHit = true;
                                    bird.velocity.x *= 0.95; bird.velocity.y *= 0.95;
                                }
                            } else {
                                if (pig.escort) {
                                    pig.vx = (pig.vx || 0) + bird.velocity.x * 0.2;
                                    pig.vy = (pig.vy || 0) + bird.velocity.y * 0.2;
                                } else {
                                    if (pig.isBoss) {
                                        if (pig._lastDamageFrame === frameCounter || bossDamageLock > 0) { }
                                        else if (pig.bossShield && pig.bossShield > 0) { }
                                        else if (!bird.bossHit) { pig.health -= 1; pig.bossShield = 12; onBossDamaged(pig, 1); pig._lastDamageFrame = frameCounter; bird.bossHit = true; }
                                        if (bird.type === 'yellow') { bossDamageLock = Math.max(bossDamageLock, 8); bird.pierceFrames = 0; bird.velocity.x *= 0.8; bird.velocity.y *= 0.8; bird.dead = true; }
                                    } else {
                                        pig.health -= 2;
                                    }
                                    if (pig.health <= 0) {
                                        if (pig.isBoss) { onBossDeath(); pig.deathFrames = Math.max(pig.deathFrames||0, 90); pig._removeOnDeath = true; }
                                        else { pigs.splice(index, 1); awardScore(50); spawnParticles(pig.x, pig.y, 18, '#4CAF50'); }
                                        bird.hasHit = true; bird.targetHit = true;
                                    } else { bird.hasHit = true; }
                                }
                            }
                        }
                    });
                }
            });
            birds.forEach(b => { if (b.launched && b.dead && !b._countedStats) { if (b.hasHit) stats.shotsHit++; b._countedStats = true; } });
            birds = birds.filter(b => !b.dead);

        const bpCheck = pigs.find(p=>p.isBoss);
        if (bpCheck) bossLastPos = { x: bpCheck.x, y: bpCheck.y };
        const bossAliveBefore = !!bpCheck;
        pigs.forEach((pig, index) => {
            if (pig.isBoss && pig.deathFrames && pig.deathFrames > 0) {
                pig.vx = 0; pig.vy = 0;
                pig.deathFrames--;
                pig.radius = Math.max(10, (pig.deathStartR || pig.radius) * 0.986);
                if (frameCounter % 3 === 0) {
                    spawnParticles(pig.x, pig.y, 4, 'rgba(33,33,33,0.95)', { style: 'shard' });
                    spawnParticles(pig.x, pig.y, 2, 'rgba(0,0,0,0.9)', { style: 'smoke_ring', rad: Math.max(80, pig.radius*2.2), slow: true });
                }
                if (pig.deathFrames <= 0) { pig.health = 0; pig._readyRemove = true; }
            }
            if (pig.health > 0 && pig.baseY !== undefined && !pig.isMinion) {
                pig.y = pig.baseY + Math.sin(pig.wigglePhase + Date.now()/400) * 3;
            }
            if (pig.supportGrace && pig.supportGrace > 0) pig.supportGrace--;
            if (pig.bossShield && pig.bossShield > 0) pig.bossShield--;
            if (pig.health > 0 && !pig.escort && !pig.isMinion && !pig.levitate && !pig.isBoss && !(pig.supportGrace && pig.supportGrace > 0) && supportPauseFrames <= 0 && !draggedBird && structureChangedFrames > 0) {
                const py = (pig.baseY !== undefined) ? pig.baseY : pig.y;
                const pigBottom = py + pig.radius;
                const supported = blocks.some(b => {
                    if (!(b.health > 0 && !b.fallen)) return false;
                    const top = b.y - b.height/2;
                    const withinX = pig.x >= (b.x - b.width/2 + 2) && pig.x <= (b.x + b.width/2 - 2);
                    const withinY = pigBottom >= (top - 2) && pigBottom <= (top + 20);
                    return withinX && withinY;
                });
                if (!supported) {
                    pig.escort = true;
                    pig.vx = pig.vx || 0;
                    pig.vy = pig.vy || 0.5;
                    delete pig.baseY;
                }
            }
            if (pig.escort) {
                pig.vy = (pig.vy || 0) + gravity * 0.4;
                pig.vx = (pig.vx || 0) * 0.98;
                pig.vy = (pig.vy || 0) * 0.98;
                pig.x += pig.vx; pig.y += pig.vy;
            }
            if (pig.isBoss) {
                const targetSlots = (currentLevel === 2 || currentLevel === 3) ? 6 : 5;
                const mins = pigs.filter(m => m.isMinion && m.health > 0 && (m.bossId === pig.bossId));
                if (mins.length > targetSlots) {
                    const keep = mins.slice(0, targetSlots);
                    const drop = mins.slice(targetSlots);
                    drop.forEach(m => { m.health = 0; });
                }
                if (!pig.summonRingR || !pig.minionSlots || pig.minionSlots.length !== targetSlots) {
                    const rCircle0 = Math.max(140, pig.radius * 2.6);
                    const phase0 = (pig.slotPhase || (pig.slotPhase = Math.random()*Math.PI*2));
                    const slots0 = [];
                    for (let k=0;k<targetSlots;k++) { const ang = phase0 + (Math.PI*2) * (k/targetSlots); slots0.push({ ang }); }
                    let ringR0 = rCircle0;
                    for (let pass=0; pass<2; pass++) {
                        let bumped = false;
                        for (let si=0; si<slots0.length; si++) {
                            const ang = slots0[si].ang;
                            const nx = pig.x + Math.cos(ang) * ringR0;
                            const ny = pig.y + Math.sin(ang) * ringR0;
                            for (let j=0;j<pigs.length;j++) {
                                const other = pigs[j];
                                if (other.health <= 0) continue;
                                const minDist = (other.radius || 20) + 40;
                                const dx = other.x - nx, dy = other.y - ny;
                                if (Math.hypot(dx,dy) < minDist) { ringR0 += 34; bumped = true; break; }
                            }
                            if (bumped) break;
                        }
                        if (!bumped) break;
                    }
                    const fences0 = blocks.filter(b => {
                        if (b.material !== 'fence' || b.health <= 0) return false;
                        if (currentLevel === 4) return true;
                        const near = Math.hypot(b.x - pig.x, b.y - pig.y) < Math.max(140, pig.radius + 100);
                        return near;
                    });
                    let fenceMinR0 = 0;
                    if (fences0.length) {
                        let needR0 = 0;
                        const minionR0 = 24;
                        for (let si=0; si<slots0.length; si++) {
                            const ang = slots0[si].ang;
                            for (let k=0;k<fences0.length;k++) {
                                const fb = fences0[k];
                                const left = fb.x - fb.width/2, right = fb.x + fb.width/2, top = fb.y - fb.height/2, bottom = fb.y + fb.height/2;
                                const dist = rayIntersectAABB(pig.x, pig.y, ang, left, right, top, bottom);
                                if (dist !== null) {
                                    const fGap = 6;
                                    needR0 = Math.max(needR0, dist + minionR0 + fGap);
                                }
                            }
                        }
                        if (needR0 > 0) { ringR0 = Math.max(ringR0, needR0); fenceMinR0 = needR0; }
                    }
                    const safeTop0 = 120, safeBottom0 = canvas.height - 240;
                    const minionR0 = 24;
                    let minY0 = Infinity, maxY0 = -Infinity;
                    for (let si=0; si<slots0.length; si++) { const ang = slots0[si].ang; const ny = pig.y + Math.sin(ang) * ringR0; if (ny < minY0) minY0 = ny; if (ny > maxY0) maxY0 = ny; }
                    if (minY0 - minionR0 < safeTop0) ringR0 = Math.min(ringR0, Math.max(minionR0, pig.y - (safeTop0 + minionR0)));
                    if (maxY0 + minionR0 > safeBottom0) ringR0 = Math.min(ringR0, Math.max(minionR0, (safeBottom0 - minionR0) - pig.y));
                    ringR0 = Math.max(ringR0, fenceMinR0);
                    ringR0 = Math.max(pig.radius + minionR0 + 10, ringR0);
                    pig.summonRingR = ringR0;
                    pig.minionSlots = slots0.map((s,idx)=>({ ang: s.ang, index: idx }));
                }
                if (pig.summonRingR && pig.minionSlots) {
                    const occA = new Array(targetSlots).fill(false);
                    mins.forEach(m => {
                        if (typeof m.slotIndex !== 'number') {
                            let bestI = -1, bestD = Infinity;
                            for (let i=0;i<pig.minionSlots.length;i++) {
                                if (occA[i]) continue;
                                const s = pig.minionSlots[i];
                                const ex = pig.x + Math.cos(s.ang)*pig.summonRingR;
                                const ey = pig.y + Math.sin(s.ang)*pig.summonRingR;
                                const d = Math.hypot((m.x-ex),(m.y-ey));
                                if (d < bestD) { bestD = d; bestI = i; }
                            }
                            const idx = (bestI>=0) ? bestI : pig.minionSlots.findIndex((_,i)=>!occA[i]);
                            if (idx>=0) {
                                m.slotIndex = idx;
                            } else {
                                m.slotIndex = typeof m.slotIndex === 'number' && m.slotIndex>=0 ? (m.slotIndex % targetSlots) : Math.floor(Math.random()*targetSlots);
                            }
                        }
                        if (typeof m.slotIndex === 'number' && m.slotIndex>=0 && m.slotIndex<targetSlots) occA[m.slotIndex] = true;
                    });
                    mins.forEach(m => { const s = pig.minionSlots[m.slotIndex]; if (!s) return; m.x = pig.x + Math.cos(s.ang) * pig.summonRingR; m.y = pig.y + Math.sin(s.ang) * pig.summonRingR; m.baseY = m.y; });
                }
                if (pig.summonInterval) {
                    pig.summonTimer = (pig.summonTimer || pig.summonInterval) - 1;
                    if (pig.summonTimer <= 0) {
                        const target = (currentLevel === 2 || currentLevel === 3) ? 6 : 5;
                        const existingMinions = pigs.filter(m => m.isMinion && m.health > 0 && (m.bossId === pig.bossId));
                        if (existingMinions.length > target) {
                            const keep = existingMinions.slice(0, target);
                            const drop = existingMinions.slice(target);
                            drop.forEach(m => { m.health = 0; });
                        }
                        const existing = existingMinions.length;
                        let need = Math.max(0, target - existing);
                        const rCircle = Math.max(140, pig.radius * 2.6);
                        const phase = (pig.slotPhase || (pig.slotPhase = Math.random()*Math.PI*2));
                        let slots = (pig.minionSlots && pig.minionSlots.length===target) ? pig.minionSlots.map(s=>({ ang: s.ang })) : [];
                        if (!slots.length) { for (let k=0;k<target;k++) { const ang = phase + (Math.PI*2) * (k/target); slots.push({ ang }); } }
                        let ringR = pig.summonRingR || rCircle;
                        let fenceMinR = 0;
                        if (!pig.summonRingR) {
                            for (let pass=0; pass<2; pass++) {
                                let bumped = false;
                                for (let si=0; si<slots.length; si++) {
                                    const ang = slots[si].ang;
                                    const nx = pig.x + Math.cos(ang) * ringR;
                                    const ny = pig.y + Math.sin(ang) * ringR;
                                    for (let j=0;j<pigs.length;j++) {
                                        const other = pigs[j];
                                        if (other.health <= 0) continue;
                                        const minDist = (other.radius || 20) + 40;
                                        const dx = other.x - nx, dy = other.y - ny;
                                        if (Math.hypot(dx,dy) < minDist) { ringR += 34; bumped = true; break; }
                                    }
                                    if (bumped) break;
                                }
                                if (!bumped) break;
                            }
                        }
                        if (!pig.summonRingR) {
                            blocks.forEach(b => {
                                const left = b.x - b.width/2, right = b.x + b.width/2, top = b.y - b.height/2, bottom = b.y + b.height/2;
                                for (let si=0; si<slots.length; si++) {
                                    const ang = slots[si].ang;
                                    const nx = pig.x + Math.cos(ang) * ringR;
                                    const ny = pig.y + Math.sin(ang) * ringR;
                                    const minionR = 24;
                                    if (nx > left - minionR && nx < right + minionR && ny > top - minionR && ny < bottom + minionR) { ringR = Math.max(ringR, ringR + Math.max(b.width, b.height)/2 + 20); }
                                }
                            });
                            const fenceBlocks = blocks.filter(b => {
                                if (b.material !== 'fence' || b.health <= 0) return false;
                                if (currentLevel === 4) return true;
                                const near = Math.hypot(b.x - pig.x, b.y - pig.y) < Math.max(140, pig.radius + 100);
                                return near;
                            });
                            fenceMinR = 0;
                        if (fenceBlocks.length) {
                            let needR = 0;
                            const minionR = 24;
                            for (let si=0; si<slots.length; si++) {
                                const ang = slots[si].ang;
                                for (let k=0;k<fenceBlocks.length;k++) {
                                    const fb = fenceBlocks[k];
                                    const left = fb.x - fb.width/2, right = fb.x + fb.width/2, top = fb.y - fb.height/2, bottom = fb.y + fb.height/2;
                                    const dist = rayIntersectAABB(pig.x, pig.y, ang, left, right, top, bottom);
                                    if (dist !== null) {
                                        const fGap = 6;
                                        needR = Math.max(needR, dist + minionR + fGap);
                                    }
                                }
                            }
                            if (needR > 0) { ringR = Math.max(ringR, needR); fenceMinR = needR; }
                        }
                    }
                    const safeTop = 120;
                    const safeBottom = canvas.height - 240;
                    const minionR = 24;
                    let minY = Infinity, maxY = -Infinity;
                    for (let si=0; si<slots.length; si++) { const ang = slots[si].ang; const ny = pig.y + Math.sin(ang) * ringR; if (ny < minY) minY = ny; if (ny > maxY) maxY = ny; }
                    if (minY - minionR < safeTop) ringR = Math.min(ringR, Math.max(minionR, pig.y - (safeTop + minionR)));
                    if (maxY + minionR > safeBottom) ringR = Math.min(ringR, Math.max(minionR, (safeBottom - minionR) - pig.y));
                    ringR = Math.max(ringR, fenceMinR);
                    ringR = Math.max(pig.radius + minionR + 10, ringR);
                    pig.summonRingR = pig.summonRingR || ringR;
                    pig.minionSlots = pig.minionSlots && pig.minionSlots.length===target ? pig.minionSlots : slots.map((s,idx)=>({ ang: s.ang, index: idx }));

                        existingMinions.forEach(m => {
                            if (typeof m.slotIndex === 'number') return;
                            let bestI = -1, bestD = Infinity;
                            for (let i=0;i<pig.minionSlots.length;i++) {
                                const s = pig.minionSlots[i];
                                const ex = pig.x + Math.cos(s.ang)*pig.summonRingR;
                                const ey = pig.y + Math.sin(s.ang)*pig.summonRingR;
                                const d = Math.hypot((m.x-ex),(m.y-ey));
                                if (d < bestD) { bestD = d; bestI = i; }
                            }
                            if (bestI>=0) m.slotIndex = bestI;
                        });
                        const occupied = new Array(target).fill(false);
                        existingMinions.forEach(m => { if (typeof m.slotIndex === 'number' && m.slotIndex>=0 && m.slotIndex<target) occupied[m.slotIndex] = true; });
                        existingMinions.forEach(m => {
                            if (typeof m.slotIndex !== 'number') return;
                            const s = pig.minionSlots[m.slotIndex];
                            if (!s) return;
                            m.x = pig.x + Math.cos(s.ang) * pig.summonRingR;
                            m.y = pig.y + Math.sin(s.ang) * pig.summonRingR;
                            m.baseY = m.y;
                        });
                        if (currentLevel === 2 || currentLevel === 3) {
                            const tLeft = Math.max(0, pig.summonTimer || 0);
                            const qFx = getFxQuality();
                            const telegraphEvery = qFx >= 0.75 ? 2 : 3;
                            if (tLeft <= 45 && (frameCounter % telegraphEvery === 0)) {
                                for (let i=0;i<pig.minionSlots.length; i++) {
                                    if (occupied[i]) continue;
                                    const s = pig.minionSlots[i];
                                    const ex = pig.x + Math.cos(s.ang) * pig.summonRingR;
                                    const ey = pig.y + Math.sin(s.ang) * pig.summonRingR;
                                    spawnParticles(ex, ey, qFx >= 0.75 ? 2 : 1, 'rgba(0,0,0,0.95)', { style: 'black_flame', ang: s.ang, slow: true });
                                    spawnParticles(ex, ey, qFx >= 0.75 ? 2 : 1, 'rgba(0,0,0,0.9)', { style: 'shadow_fissure', ang: s.ang, slow: true });
                                    if (qFx >= 0.55) {
                                        spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.95)', { style: 'eclipse', r0: 12, len: 70, alpha: 0.94, growth: 1.6, spikes: 20 });
                                        spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.9)', { style: 'orbit_blade', cx: ex, cy: ey, rad: Math.max(26, pig.radius*0.5), w: Math.max(10, pig.radius*0.35), slow: true });
                                        spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.9)', { style: 'swirl', cx: ex, cy: ey, rad: Math.max(24, pig.radius*0.6), width: 3 });
                                    }
                                }
                            }
                        }
                        let didSummon = false;
                        for (let i=0;i<pig.minionSlots.length && need>0; i++) {
                            if (occupied[i]) continue;
                            const s = pig.minionSlots[i];
                            const nx = pig.x + Math.cos(s.ang) * pig.summonRingR;
                            const ny = pig.y + Math.sin(s.ang) * pig.summonRingR;
                            pigs.push({ x: nx, y: ny, baseY: ny, wigglePhase: Math.random()*Math.PI*2, radius: 24, color: '#202020', health: 2, isMinion: true, bossType: pig.bossType, bossId: pig.bossId, levitate: true, supportGrace: 120, slotIndex: i });
                    
                    // ç½šæŠ„åŠ¨æ•ˆ (Level 2/3) - å¢å¼ºç‰ˆ
                    if (currentLevel === 2 || currentLevel === 3) {
                        // äº§ç”Ÿå¤šä¸ªâ€œç½šæŠ„â€æ–‡å­—ï¼Œå‘å››å‘¨æ‰©æ•£
                        const qFx = getFxQuality();
                        const ft = Math.max(2, Math.round(5 * qFx));
                        for(let f=0; f<ft; f++) {
                            spawnParticles(nx, ny, 1, '#fff', { 
                                style: 'fachao_text', 
                                text: 'ç½šæŠ„', 
                                life: 80, 
                                slow: true, 
                                nograv: true,
                                vx: (Math.random()-0.5)*3, 
                                vy: (Math.random()-0.5)*3 - 1 
                            });
                        }
                    }
                            didSummon = true;
                            if (currentLevel === 2 || currentLevel === 3) {
                                const qFx = getFxQuality();
                                const a1 = Math.max(12, Math.round(24 * qFx));
                                const a2 = Math.max(4, Math.round(10 * qFx));
                                const a3 = Math.max(18, Math.round(40 * qFx));
                                spawnParticles(nx, ny, 1, 'rgba(0,0,0,0.95)', { style: 'eclipse', r0: Math.max(24, pig.radius*0.8), len: Math.max(130, pig.summonRingR*0.8), alpha: 0.97, growth: 2.6, spikes: 24 });
                                spawnParticles(nx, ny, a1, 'rgba(0,0,0,0.95)', { style: 'amaterasu', life: 70, spikes: 16 });
                                spawnParticles(nx, ny, a2, 'rgba(0,0,0,0.9)', { style: 'shadow_fissure', slow: true });
                                spawnParticles(nx, ny, qFx >= 0.55 ? 2 : 1, 'rgba(0,0,0,0.9)', { style: 'orbit_blade', cx: nx, cy: ny, rad: Math.max(34, pig.radius*0.7), w: Math.max(14, pig.radius*0.45), slow: true });
                                if (qFx >= 0.55) {
                                    spawnParticles(nx, ny, 2, 'rgba(0,0,0,0.9)', { style: 'swirl', cx: nx, cy: ny, rad: Math.max(140, pig.summonRingR*0.9), width: 3 });
                                    spawnParticles(nx, ny, 1, 'rgba(0,0,0,0.9)', { style: 'smoke_ring', rad: Math.max(140, pig.summonRingR*1.1), slow: true });
                                }
                                spawnParticles(pig.x, pig.y, a3, 'rgba(0,0,0,0.95)', { style: 'amaterasu', life: 40, w: 6 });
                                spawnParticles(pig.x, pig.y, Math.max(6, Math.round(10 * qFx)), '#FF0000', { style: 'shard', life: 30 });
                                bossShockwaves.push({ x: nx, y: ny, r: Math.max(48, pig.radius*1.4), alpha: 0.95, thick: 20, growth: 14 });
                                bossShockwaves.push({ x: nx, y: ny, r: Math.max(96, pig.radius*2.0), alpha: 0.75, thick: 14, growth: 12 });
                                shakeFrames = Math.max(shakeFrames || 0, 24);
                            }
                            occupied[i] = true; need--;
                        }
                        if (didSummon && (currentLevel === 2 || currentLevel === 3)) {
                            summonLabels.push({ x: pig.x, y: pig.y - Math.max(60, pig.radius*1.6), life: 24, total: 24, size: Math.max(34, pig.radius*1.2) });
                        }
                        
                        
                        pig.summonTimer = pig.summonInterval;
                    }
                }
                pig._pulse = (pig._pulse||0) + 1;
                const qFx = getFxQuality();
                if (pig._pulse % 22 === 0) { spawnParticles(pig.x, pig.y, Math.max(6, Math.round(12*qFx)), 'rgba(0,0,0,0.95)', { style: 'amaterasu', spikes: 10, life: 60, r0: 10, growth: 0.18, alpha: 0.95 }); }
                pig.darkAuraPhase = (pig.darkAuraPhase||0) + 0.04;
                if (pig._pulse % 40 === 0) { spawnParticles(pig.x, pig.y, 1, 'rgba(0,0,0,0.6)', { style: 'smoke_ring', rad: pig.radius*1.8, slow: true }); }
                if (pig._pulse % 80 === 0) { spawnParticles(pig.x, pig.y, 1, 'rgba(0,0,0,0.7)', { style: 'orbit_blade', cx: pig.x, cy: pig.y, rad: Math.max(80, pig.radius*2.0), w: pig.radius*0.35, slow: true }); }
                if (pig._pulse % 160 === 0) { const ang = pig.darkAuraPhase || 0; const rx = pig.x + Math.cos(ang) * Math.max(80, pig.radius*1.2); const ry = pig.y + Math.sin(ang) * Math.max(80, pig.radius*1.2); spawnParticles(rx, ry, 1, 'rgba(180,180,180,0.6)', { style: 'rune', ang, slow: true, nograv: true }); }
                if (pig._pulse % (qFx >= 0.75 ? 6 : 10) === 0) {
                    const ringR = Math.max(60, pig.radius*1.2);
                    const cnt = Math.max(2, Math.round(6*qFx));
                    for (let s=0;s<cnt;s++) { const ang = (pig.darkAuraPhase||0) + s*(Math.PI*2/cnt); const ex = pig.x + Math.cos(ang) * ringR; const ey = pig.y + Math.sin(ang) * ringR; spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.95)', { style: 'black_flame', ang, len: pig.radius*1.0, w: pig.radius*0.45, speed: 0.5, slow: true, nograv: true }); }
                }
                if (pig._pulse % (qFx >= 0.75 ? 12 : 18) === 0) {
                    const ringR = Math.max(70, pig.radius*1.35);
                    const cnt = Math.max(1, Math.round(4*qFx));
                    for (let s=0;s<cnt;s++) { const ang = (pig.darkAuraPhase||0) + s*(Math.PI*2/cnt); const ex = pig.x + Math.cos(ang) * ringR; const ey = pig.y + Math.sin(ang) * ringR; spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.9)', { style: 'shadow_fissure', ang, len: pig.radius*1.2, w: pig.radius*0.3, slow: true }); }
                }
                if (pig._pulse % (qFx >= 0.75 ? 20 : 28) === 0) {
                    const ringR = Math.max(80, pig.radius*1.5);
                    const cnt = Math.max(1, Math.round(3*qFx));
                    for (let s=0;s<cnt;s++) { const ang = (pig.darkAuraPhase||0) + s*(Math.PI*2/cnt); const ex = pig.x + Math.cos(ang) * ringR; const ey = pig.y + Math.sin(ang) * ringR; spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.9)', { style: 'dark_tendril', ang, len: pig.radius*1.4, w: pig.radius*0.35, slow: true }); }
                }
                if (currentLevel === 3 && pig.bossType === 'boss2') {
                    const now = performance.now();
                    const interval = pig.riftIntervalMs || 4200;
                    pig._riftNextAt = (typeof pig._riftNextAt === 'number') ? pig._riftNextAt : (now + interval);
                    const tLeftMs = pig._riftNextAt - now;
                    if (tLeftMs > 0 && tLeftMs < 900) {
                        const k = Math.max(0, 1 - tLeftMs / 900);
                        if (frameCounter % (qFx >= 0.75 ? 2 : 3) === 0) {
                            spawnParticles(pig.x, pig.y, 1, 'rgba(0,0,0,0.95)', { style: 'eclipse', r0: Math.max(18, pig.radius*0.55), len: Math.max(80, pig.radius*2.1), alpha: 0.95, growth: 2.2, spikes: 20 });
                            spawnParticles(pig.x, pig.y, 1, 'rgba(0,0,0,0.9)', { style: 'orbit_blade', cx: pig.x, cy: pig.y, rad: Math.max(60, pig.radius*1.9), w: Math.max(14, pig.radius*0.35), slow: true });
                            if (qFx >= 0.55) spawnParticles(pig.x, pig.y, 1, 'rgba(0,0,0,0.9)', { style: 'swirl', cx: pig.x, cy: pig.y, rad: Math.max(90, pig.radius*2.4), width: 3 });
                        }
                        bossUi.flash = Math.max(bossUi.flash || 0, 8);
                        bossUi.pulse = Math.max(bossUi.pulse || 0, 8);
                        // ç§»é™¤BossæŠ€èƒ½é¢„è­¦çš„ç´«è‰²é—ªå…‰
                        // flashFrames = Math.max(flashFrames, 6 + Math.round(6*k));
                        // flashColor = '#B388FF';
                        flashWorldX = pig.x;
                        flashWorldY = pig.y;
                    }
                    if (now >= pig._riftNextAt) {
                        const rr0 = Math.max(150, pig.riftRadius || 210);
                        let tx = pig.x, ty = pig.y;
                        const ab = activeBird && activeBird.launched && !activeBird.dead ? activeBird : null;
                        if (ab) {
                            const ang = Math.atan2(ab.velocity?.y || 0, ab.velocity?.x || 0) + (Math.random()-0.5)*0.9;
                            const d = 160 + Math.random()*140;
                            tx = ab.x + Math.cos(ang) * d;
                            ty = ab.y + Math.sin(ang) * d;
                        } else {
                            tx = 180 + Math.random()*(canvas.width - 360);
                            ty = 140 + Math.random()*(canvas.height - 420);
                        }
                        for (let k=0;k<10;k++) {
                            const tooCloseToPlayer = Math.hypot(tx - slingshot.x, ty - slingshot.y) < 240;
                            if (!tooCloseToPlayer) break;
                            tx = 200 + Math.random()*(canvas.width - 400);
                            ty = 150 + Math.random()*(canvas.height - 460);
                        }
                        const spawnRift = (x, y, rr, life, tag) => {
                            const total = life;
                            // Tag is now just for internal logic, no text label
                            shadowRifts.push({ x, y, r: rr, life, total, seed: Math.random()*1000, phase: Math.random()*Math.PI*2, tag });
                            while (shadowRifts.length > 2) shadowRifts.shift();
                            
                            // ç§»é™¤æ—§çš„æ–‡å­—æç¤º riftLabels.push(...)
                            
                            bossTrails.push({ type: 'stamp', x, y, r: Math.max(80, rr*0.78), life: 38, alpha: 0.95 });
                            
                            // æ”¹ä¸ºé’è‰²/æ·±ç©ºè“çš„å†²å‡»æ³¢
                            bossShockwaves.push({ x, y, r: Math.max(70, rr*0.55), alpha: 0.95, thick: 18, growth: 14, color: 'rgba(0,229,255,0.85)' });
                            bossShockwaves.push({ x, y, r: Math.max(130, rr*0.85), alpha: 0.82, thick: 12, growth: 13, color: 'rgba(0,0,40,0.95)' });
                            
                            // ç²’å­æ”¹ä¸ºç¥ç§˜é£æ ¼ (é»‘è‰²/æš—ç´«)
                            spawnParticles(x, y, Math.max(14, Math.round(26*qFx)), 'rgba(20,20,20,0.95)', { style: 'smoke', life: 62, growth: 0.3 });
                            spawnParticles(x, y, Math.max(10, Math.round(18*qFx)), 'rgba(40,0,60,0.85)', { style: 'black_flame', slow: true, rad: rr*1.2 });
                            
                            if (qFx >= 0.55) {
                                spawnParticles(x, y, 3, 'rgba(0,0,0,0.8)', { style: 'shadow_fissure', cx: x, cy: y, rad: rr*0.8, w: Math.max(18, rr*0.2), slow: true });
                                spawnParticles(x, y, 2, 'rgba(60,20,80,0.6)', { style: 'smoke_ring', cx: x, cy: y, rad: rr*1.4, width: 2 });
                            }
                            
                            // ç§»é™¤å…¨å±ç´«è‰²é—ªå…‰ï¼Œä»…è½»å¾®éœ‡åŠ¨
                            shakeFrames = Math.max(shakeFrames || 0, 12);
                            // ç¡®ä¿ä¸è§¦å‘å…¨å±é—ªå…‰
                            flashFrames = 0; 
                            bossUi.flash = 0;
                        };
                        const life = Math.max(220, pig.riftLifeFrames || 270);
                        spawnRift(tx, ty, rr0, life, 'æ‰£åˆ†');
                        if ((ab && Math.random() < 0.65) || (!ab && Math.random() < 0.45) || qFx >= 0.75) {
                            let x2 = tx + (Math.random()-0.5) * (rr0*2.2);
                            let y2 = ty + (Math.random()-0.5) * (rr0*1.6);
                            for (let k=0;k<8;k++) {
                                x2 = Math.max(170, Math.min(canvas.width - 170, x2));
                                y2 = Math.max(140, Math.min(canvas.height - 260, y2));
                                const tooCloseToPlayer2 = Math.hypot(x2 - slingshot.x, y2 - slingshot.y) < 220;
                                if (!tooCloseToPlayer2) break;
                                x2 = 200 + Math.random()*(canvas.width - 400);
                                y2 = 150 + Math.random()*(canvas.height - 460);
                            }
                            spawnRift(x2, y2, rr0*0.78, Math.max(170, Math.round(life*0.72)), 'æ‰£åˆ†');
                        }
                        pig._riftNextAt = now + interval;
                    }
                    if (shadowRifts.length) {
                        for (let ri=0; ri<shadowRifts.length; ri++) {
                            const rf = shadowRifts[ri];
                            const rr = Math.max(70, rf.r || 140);
                            const maxR = rr * 2.6;
                            birds.forEach(b => {
                                if (!b.launched || b.dead) return;
                                if (b.spinDriveFrames && b.spinDriveFrames > 0) return;
                                if (b.huntActive && b.huntTargets && b.huntTargets.length) return;
                                if (b.pierceFrames && b.pierceFrames > 0) return;
                                const dx = rf.x - b.x, dy = rf.y - b.y;
                                const dist = Math.hypot(dx, dy);
                                if (dist >= maxR) return;
                                const t = Math.max(0, 1 - dist / maxR);
                                const inv = 1 / (dist + 30);
                                const pulse = 0.75 + 0.25*Math.sin((rf.phase||0) + dist*0.03);
                                const base = (0.28 + 0.18*fxQ) * t * t * pulse;
                                b.velocity.x += dx * inv * base;
                                b.velocity.y += dy * inv * base;
                                const swirl = base * 0.26;
                                b.velocity.x += (-dy) * inv * swirl;
                                b.velocity.y += (dx) * inv * swirl;
                                if (dist < rr * 0.62) {
                                    b.velocity.x *= 0.978;
                                    b.velocity.y *= 0.978;
                                    if (frameCounter % (fxQ >= 0.75 ? 3 : 4) === 0) spawnParticles(b.x, b.y, 1, 'rgba(0,0,0,0.9)', { style: 'shadow_fissure', slow: true, nograv: true });
                                    if (frameCounter % 10 === 0) {
                                        const loss = FX_OVERDRIVE ? 4 : 3;
                                        if (score > 0) {
                                            score = Math.max(0, score - loss);
                                            floatScores.push({ x: b.x, y: b.y, text: `-${loss}`, life: 28 });
                                            updateHUD();
                                        }
                                        // ç§»é™¤ç´«è‰²é—ªå…‰
                                        // flashFrames = Math.max(flashFrames, 5);
                                        // flashColor = '#7C4DFF';
                                        flashWorldX = b.x;
                                        flashWorldY = b.y;
                                    }
                                }
                            });
                        }
                    }
                }
                if (pig.teleportIntervalMs) {
                    const now = performance.now();
                    pig._teleportNextAt = (typeof pig._teleportNextAt === 'number') ? pig._teleportNextAt : (now + pig.teleportIntervalMs);
                    if (now >= pig._teleportNextAt) {
                        const oldX = pig.x, oldY = pig.y;
                        let nx = pig.x, ny = pig.y;
                        for (let k=0;k<12;k++) {
                            nx = Math.max(160, Math.min(canvas.width - 160, 160 + Math.random()*(canvas.width - 320)));
                            ny = Math.max(120, Math.min(canvas.height - 240, 120 + Math.random()*(canvas.height - 360)));
                            const tooCloseToPlayer = Math.hypot(nx - slingshot.x, ny - slingshot.y) < 260;
                            if (tooCloseToPlayer) continue;
                            const ab = activeBird;
                            if (ab) {
                                const horiz = Math.abs(nx - ab.x);
                                const directAbove = ny < ab.y - 60 && horiz < 100;
                                if (directAbove) continue;
                            }
                            break;
                        }
                        pig.x = nx; pig.y = ny; pig.baseY = ny;
                        bossTrails.push({ x: oldX, y: oldY, ex: nx, ey: ny, life: 28, alpha: 0.8, w: Math.max(18, pig.radius*0.6) });
                        bossTrails.push({ type: 'stamp', x: oldX, y: oldY, r: Math.max(60, pig.radius*2.2), life: 42, alpha: 0.9 });
                        spawnParticles(nx, ny, Math.max(8, Math.round(24*qFx)), 'rgba(0,0,0,0.95)', { style: 'amaterasu' });
                        blocks.forEach(b => { if (b.bossId === pig.bossId && b.health > 0 && !b.fallen) { b.x = pig.x + (b.dx||0); b.y = pig.y + (b.dy||0); } });
                        pig._teleportNextAt = now + pig.teleportIntervalMs;
                    }
                } else if (pig.teleportInterval) {
                    pig.teleportTimer = (pig.teleportTimer || pig.teleportInterval) - 1;
                    if (pig.teleportTimer <= 0) {
                        const oldX = pig.x, oldY = pig.y;
                        let nx = pig.x, ny = pig.y;
                        for (let k=0;k<12;k++) {
                            nx = Math.max(160, Math.min(canvas.width - 160, 160 + Math.random()*(canvas.width - 320)));
                            ny = Math.max(120, Math.min(canvas.height - 240, 120 + Math.random()*(canvas.height - 360)));
                            const tooCloseToPlayer = Math.hypot(nx - slingshot.x, ny - slingshot.y) < 260;
                            if (tooCloseToPlayer) continue;
                            const ab = activeBird;
                            if (ab) {
                                const horiz = Math.abs(nx - ab.x);
                                const directAbove = ny < ab.y - 60 && horiz < 100;
                                if (directAbove) continue;
                            }
                            break;
                        }
                        pig.x = nx; pig.y = ny; pig.baseY = ny;
                        bossTrails.push({ x: oldX, y: oldY, ex: nx, ey: ny, life: 28, alpha: 0.8, w: Math.max(18, pig.radius*0.6) });
                        bossTrails.push({ type: 'stamp', x: oldX, y: oldY, r: Math.max(60, pig.radius*2.2), life: 42, alpha: 0.9 });
                        spawnParticles(nx, ny, Math.max(8, Math.round(24*qFx)), 'rgba(0,0,0,0.95)', { style: 'amaterasu' });
                        blocks.forEach(b => { if (b.bossId === pig.bossId && b.health > 0 && !b.fallen) { b.x = pig.x + (b.dx||0); b.y = pig.y + (b.dy||0); } });
                        pig.teleportTimer = pig.teleportInterval;
                    }
                }
                birds.forEach(b => {
                    if (!b.launched || b.dead) return;
                    if (b.spinDriveFrames && b.spinDriveFrames > 0) return;
                    if (b.huntActive && b.huntTargets && b.huntTargets.length) return;
                    if (b.pierceFrames && b.pierceFrames > 0) return;
                    const d = Math.hypot(b.x - pig.x, b.y - pig.y);
                    const auraR = Math.max(140, pig.radius * 2.4);
                    if (d < auraR) {
                        const nx = (b.x - pig.x) / (d || 1), ny = (b.y - pig.y) / (d || 1);
                        b.velocity.x = b.velocity.x * 0.96 + nx * 0.08;
                        b.velocity.y = b.velocity.y * 0.96 + ny * 0.06;
                    }
                });
                // Bossä¸å…¶ä»–çŒªçš„é‡å åˆ†ç¦»ï¼Œé¿å…â€œå‹æ­»â€ä¸‹é¢çš„å°æ€ª
                pigs.forEach((other, oi) => {
                    if (other === pig || other.health <= 0) return;
                    const dx = other.x - pig.x, dy = other.y - pig.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const minDist = (other.radius || 20) + (pig.radius || 40) + 2;
                    if (dist > 0 && dist < minDist) {
                        const push = (minDist - dist);
                        const nx = dx / dist, ny = dy / dist;
                        other.x += nx * push;
                        other.y += ny * push;
                        other.vx = (other.vx || 0) + nx * 0.2;
                        other.vy = (other.vy || 0) + ny * 0.2;
                    }
                });
                }
                const py2 = (pig.baseY !== undefined) ? pig.baseY : pig.y;
            const pigBottom2 = py2 + pig.radius;
            const supported2 = blocks.some(b => {
                if (!(b.health > 0 && !b.fallen)) return false;
                const top = b.y - b.height/2;
                const withinX = pig.x >= (b.x - b.width/2 + 2) && pig.x <= (b.x + b.width/2 - 2);
                const withinY = pigBottom2 >= (top - 2) && pigBottom2 <= (top + 20);
                return withinX && withinY;
            });
            if (!pig.isMinion && !pig.levitate && !pig.isBoss && !(pig.supportGrace && pig.supportGrace > 0) && supportPauseFrames <= 0 && !draggedBird && (pig.y + pig.radius >= canvas.height - 50) && !supported2 && structureChangedFrames > 0) {
                pigs.splice(index, 1);
                awardScore(50);
                spawnParticles(pig.x, pig.y, 18, '#4CAF50');
            }
            if (pig.isBoss) {
                if (pig.prevX === undefined) { pig.prevX = pig.x; pig.prevY = pig.y; }
                const dxmv = pig.x - pig.prevX, dymv = pig.y - pig.prevY;
                const dmv = Math.hypot(dxmv, dymv);
                if (dmv > 6) { bossTrails.push({ x: pig.prevX, y: pig.prevY, ex: pig.x, ey: pig.y, life: 32, alpha: 0.8, w: Math.max(18, pig.radius*0.6) }); }
                pig.prevX = pig.x; pig.prevY = pig.y;
            }
        });
        const bossAliveAfter = pigs.some(p=>p.isBoss);
        pigs = pigs.filter(p => !(p.isBoss && p._removeOnDeath && p._readyRemove));
        if (lastBossAlive && !bossAliveAfter && !(victoryFrames && victoryFrames>0)) {
            const pos = bossLastPos || { x: canvas.width/2, y: canvas.height/2 };
            victoryFrames = Math.max(victoryFrames||0, 160);
            bossDeathFx = { x: pos.x, y: pos.y, frames: 120, flash: 12 };
            bossFinale = { x: pos.x, y: pos.y, frames: 160 };
            shakeFrames = Math.max(shakeFrames||0, 24);
            timeSlowFrames = Math.max(timeSlowFrames||0, 40);
            spawnBudget += 160;
            spawnParticles(pos.x, pos.y, 18, 'rgba(0,0,0,0.95)', { style: 'black_flame', slow: true });
            spawnParticles(pos.x, pos.y, 12, 'rgba(0,0,0,0.9)', { style: 'shadow_fissure', slow: true });
            bossShockwaves.push({ x: pos.x, y: pos.y, r: 60, alpha: 0.9, thick: 16, growth: 12 });
        }
        lastBossAlive = bossAliveAfter;

        // å¤„ç†å€’ä¸‹çš„æœ¨æ¿
        blocks.forEach(block => {
            if (block.fallen) {
                // æœ¨æ¿å€’ä¸‹æ•ˆæœ - æ›´çœŸå®çš„ç‰©ç†
                if (block.y < canvas.height - 50) {
                    block.y += 8; // æœ¨æ¿åŠ é€Ÿæ‰è½
                    block.x += (Math.random() - 0.5) * 3; // å·¦å³æ™ƒåŠ¨
                    // å¢åŠ æ—‹è½¬æ•ˆæœ
                    if (block.rotation) {
                        block.rotation += (Math.random() - 0.5) * 0.1;
                    }
                }
                
                // æ£€æŸ¥æœ¨æ¿æ˜¯å¦å‹åˆ°çŒª
                pigs.forEach((pig, index) => {
                    if (pig.health > 0 && checkBlockPigCollision(block, pig)) {
                        if (block.material === 'fence') {
                            pig.vx = (pig.vx || 0) + (Math.random()-0.5)*2;
                            pig.vy = (pig.vy || 0) + 2;
                        } else if (pig.escort) {
                            pig.vx = (pig.vx || 0) + (Math.random()-0.5)*2;
                            pig.vy = (pig.vy || 0) + 2;
                        } else if (pig.isBoss) {
                            if (pig._lastDamageFrame === frameCounter) { }
                            else if (pig.bossShield && pig.bossShield > 0) { }
                            else {
                                pig.health -= 1; pig.bossShield = 12; onBossDamaged(pig, 1); pig._lastDamageFrame = frameCounter;
                                if (pig.health <= 0) { onBossDeath(); pig.deathFrames = Math.max(pig.deathFrames||0, 90); pig._removeOnDeath = true; awardScore(50); }
                            }
                        } else {
                            pig.health = 0;
                            pigs.splice(index, 1);
                            awardScore(50);
                            spawnParticles(pig.x, pig.y, 18, '#4CAF50');
                        }
                    }
                });
            }
            if (!block.fallen && block.onFire) {
                block.health -= 0.02;
                spawnParticles(block.x, block.y, 2, '#FF8F00', { style: 'streak' });
                if (block.health <= 0) {
                    block.fallen = true;
                    block.rotation = (Math.random()-0.5) * Math.PI/2;
                    awardScore(10 + getMaterialBonus(block.material,'break', 6));
                    if (precisionMode && !block.isTarget) precisionFail = true;
                    if (block.isTarget && !block._counted) { targetsDestroyed++; block._counted = true; completedTargets.push({ label: block.label || ('T'+targetsDestroyed), x: Math.round(block.x), y: Math.round(block.y), material: block.material }); }
                }
                const smN = 24;
                const pr = pig.radius * 1.7;
                for (let s=0;s<smN;s++) {
                    const ang = Date.now()/900 + s*(Math.PI*2/smN);
                    const ex = pig.x + Math.cos(ang) * pr;
                    const ey = pig.y + Math.sin(ang) * pr;
                    spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.95)', { style: 'black_flame', ang, len: pig.radius*1.0, w: pig.radius*0.50, speed: 0.55, slow: true, nograv: true });
                    if (s % 2 === 0) spawnParticles(ex, ey, 1, 'rgba(0,0,0,0.9)', { style: 'dark_tendril', ang, len: pig.radius*1.3, w: pig.radius*0.5, speed: 0.4, slow: true, nograv: true });
                    if (s % 3 === 0) spawnParticles(pig.x, pig.y, 1, 'rgba(0,0,0,0.9)', { style: 'orbit_blade', ang, cx: pig.x, cy: pig.y, rad: pr*0.9, w: pig.radius*0.4, slow: true });
                }
                spawnParticles(pig.x, pig.y, 3, 'rgba(0,0,0,0.95)', { style: 'black_flame', len: pig.radius*1.3, w: pig.radius*0.6, speed: 0.45, slow: true, nograv: true });
            }
            
            rotorBars.forEach(rb => {
                rb.angle += rb.omega;
                birds.forEach(bird => {
                    if (bird.type === 'green' && ((bird.spinDriveFrames && bird.spinDriveFrames > 0) || (bird.huntActive && bird.huntTargets && bird.huntTargets.length))) return;
                    const lx = bird.x - rb.cx; const ly = bird.y - rb.cy;
                    const ca = Math.cos(-rb.angle), sa = Math.sin(-rb.angle);
                    const rx = lx*ca - ly*sa; const ry = lx*sa + ly*ca;
                    if (Math.abs(ry) < rb.width/2 && rx > 0 && rx < rb.length) {
                        const ny = Math.sign(ry) || 1;
                        bird.velocity.y = -Math.abs(bird.velocity.y) * ny;
                        bird.velocity.x *= 0.9;
                        spawnParticles(bird.x, bird.y, 6, '#B0BEC5');
                    }
                });
            });
        });

        // æ …æ å¼¹æ€§æ¢å¤ä¸å€¾å€’
        blocks.forEach(block => {
            if (block.material === 'fence' && !block.fallen) {
                if (block.baseX !== undefined && block.baseY !== undefined) {
                    block.x += (block.baseX - block.x) * 0.06;
                    block.y += (block.baseY - block.y) * 0.06;
                }
                block.rotation = (block.rotation || 0) * 0.94;
                if (Math.abs(block.rotation || 0) > 0.65) {
                    block.fallen = true;
                    block.rotation = (block.rotation || 0);
                }
            }
        });

            const allPigsDead = pigs.length === 0;
            if (allPigsDead) {
                gameOver(true);
            } else if (remainingBirds === 0) {
                const aliveBirds = birds.filter(b => b && !b.dead);
                const anyBirdInSlingshot = aliveBirds.some(b => b.inSlingshot && !b.launched);
                const anyBirdStillActive = aliveBirds.some(b => {
                    if (!b.launched) return false;
                    if (b.spinDriveFrames && b.spinDriveFrames > 0) return true;
                    if (b.huntActive && b.huntTargets && b.huntTargets.length) return true;
                    const vx = (b.velocity && typeof b.velocity.x === 'number') ? b.velocity.x : 0;
                    const vy = (b.velocity && typeof b.velocity.y === 'number') ? b.velocity.y : 0;
                    const sp = Math.hypot(vx, vy);
                    if (sp > 0.6) return true;
                    const groundY = canvas.height - (b.radius || 0) - 50;
                    if (b.y < groundY - 2) return true;
                    return false;
                });
                if (!anyBirdInSlingshot && !anyBirdStillActive) {
                    gameOver(false);
                }
            }
        }

        // ç¢°æ’æ£€æµ‹
        function checkCollision(bird, block) {
            return bird.x + bird.radius > block.x - block.width/2 &&
                   bird.x - bird.radius < block.x + block.width/2 &&
                   bird.y + bird.radius > block.y - block.height/2 &&
                   bird.y - bird.radius < block.y + block.height/2;
        }

        // çŒªç¢°æ’æ£€æµ‹
        function checkPigCollision(bird, pig) {
            const dx = bird.x - pig.x;
            const dy = bird.y - pig.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < bird.radius + pig.radius;
        }

        // æœ¨æ¿å‹åˆ°çŒªçš„æ£€æµ‹
        function checkBlockPigCollision(block, pig) {
            return block.x - block.width/2 < pig.x + pig.radius &&
                   block.x + block.width/2 > pig.x - pig.radius &&
                   block.y - block.height/2 < pig.y + pig.radius &&
                   block.y + block.height/2 > pig.y - pig.radius;
        }

        // åå¼¹æ•ˆæœ
        function bounce(bird, block) {
            // ç®€å•åå¼¹æ•ˆæœ
            if (bird.shield) {
                bird.velocity.y *= -0.7;
                bird.velocity.x *= 0.95;
            } else {
                bird.velocity.y *= -0.5;
                bird.velocity.x *= 0.8;
            }
        }

        // æ¸¸æˆç»“æŸ
        function gameOver(win) {
            if (!gameRunning) return;
            stopLoop();
            if (win && currentLevel === maxUnlockedLevel) {
                maxUnlockedLevel = currentLevel + 1;
                localStorage.setItem('maxUnlockedLevel', maxUnlockedLevel);
            }
            const overlay = document.getElementById('overlay');
            const titleEl = document.getElementById('overlayTitle');
            const scoreEl = document.getElementById('overlayScore');
            const nextBtn = document.getElementById('nextLevelBtn');
            const starsEl = document.getElementById('overlayStars');
            const bestComboEl = document.getElementById('overlayBestCombo');
            const bestHitEl = document.getElementById('overlayBestHit');
            const reasonEl = document.getElementById('overlayReason');
            const pbEl = document.getElementById('overlayPrecisionBonus');
            const tsEl = document.getElementById('overlayTargetSummary');
            const replayBtn = document.getElementById('watchReplayBtn');
            const ohEl = document.getElementById('overlayHitRate');
            const oavgEl = document.getElementById('overlayAvgScore');
            const oefEl = document.getElementById('overlayEff');
            const oexpEl = document.getElementById('overlayExplosions');
            const oabEl = document.getElementById('overlayAbilities');
            const oachEl = document.getElementById('overlayAchievements');
            scoreEl.textContent = score;
            if (!win && precisionMode && precisionFail) {
                titleEl.textContent = `ç¬¬${currentLevel}å…³å¤±è´¥`;
                if (reasonEl) reasonEl.textContent = 'ç²¾å‡†æ‹†é™¤å¤±è´¥ï¼šå‡»å€’äº†éç›®æ ‡ç»“æ„';
            } else {
                const suffix = currentLevel === 5 ? 'ï¼ˆè·¯å¾„è°œé¢˜ï¼‰' : '';
                titleEl.textContent = win ? `ç¬¬${currentLevel}å…³é€šå…³${suffix}` : `ç¬¬${currentLevel}å…³å¤±è´¥${suffix}`;
                if (reasonEl) reasonEl.textContent = win && precisionMode ? 'ç²¾å‡†åŠ æˆï¼šç›®æ ‡ç»“æ„åŠ åˆ†å·²ç”Ÿæ•ˆ' : '';
            }
            nextBtn.style.display = win ? 'inline-block' : 'none';
            replayBtn.style.display = replayFrames.length > 10 ? 'inline-block' : 'none';
            const stars = win ? Math.min(3, 1 + Math.floor(remainingBirds/2)) : 0;
            starsEl.textContent = 'â˜…'.repeat(stars) + 'â˜†'.repeat(3 - stars);
            if (win) { totalStars += stars; localStorage.setItem('totalStars', totalStars); }
            bestComboEl.textContent = bestCombo.toFixed(2);
            bestHitEl.textContent = highestSingleHit;
            const ts = document.getElementById('overlayTotalStars');
            if (ts) ts.textContent = `${totalStars}`;
            if (precisionMode) {
                const pct = score > 0 ? Math.round((precisionBonusAccum / score) * 100) : 0;
                if (pbEl) pbEl.textContent = `ç²¾å‡†åŠ æˆ: +${precisionBonusAccum} åˆ†ï¼ˆ${pct}%ï¼‰`;
                if (tsEl) tsEl.textContent = `ç›®æ ‡å®Œæˆ: ${targetsDestroyed}/${targetsTotal}`;
                const td = document.getElementById('overlayTargetsDetail');
                if (td) {
                    const materialMap = { wood: 'æœ¨', glass: 'ç»ç’ƒ', metal: 'é‡‘å±', rubber: 'æ©¡èƒ¶', flammable: 'æ˜“ç‡ƒ', barrel: 'æ¡¶', ice: 'å†°' };
                    const colorMap = { wood: '#A0522D', glass: '#BDE1FF', metal: '#B0BEC5', rubber: '#7E57C2', flammable: '#FF8F00', barrel: '#B85C00', ice: '#90CAF9' };
                    const list = completedTargets.map(t => `<span style="color:${colorMap[t.material] || '#fff'}">${t.label}(${t.x},${t.y},${materialMap[t.material] || 'æœªçŸ¥'})</span>`).join('ï¼Œ');
                    td.innerHTML = list ? `å®Œæˆç›®æ ‡æ¸…å•ï¼š${list}` : '';
                }
            }
            if (ohEl) {
                const rate = stats.shotsFired ? (stats.shotsHit / stats.shotsFired) : 0;
                ohEl.textContent = `${Math.round(rate*100)}%`;
            }
            if (oavgEl) {
                const avg = stats.shotsFired ? Math.round(score / stats.shotsFired) : 0;
                oavgEl.textContent = avg;
            }
            if (oefEl) {
                const eff = targetsTotal ? Math.round((targetsDestroyed / targetsTotal) * 100) : 0;
                oefEl.textContent = `${eff}%`;
            }
            if (oexpEl) oexpEl.textContent = stats.explosions;
            if (oabEl) {
                const names = { red:'çº¢', blue:'è“', yellow:'é»„', black:'é»‘', white:'ç™½', orange:'æ©™', green:'ç»¿' };
                const abilityText = Object.keys(stats.abilities).map(k => `${names[k]||k}:${stats.abilities[k]}`).join('ï¼Œ');
                oabEl.textContent = abilityText || '--';
            }
            if (oachEl) {
                const ach = (typeof computeAchievements === 'function') ? computeAchievements() : [];
                oachEl.textContent = ach.length ? ach.join('ï¼Œ') : '--';
            }
            overlay.style.display = 'flex';
        }

        function computeAchievements(){
            const res = [];
            if (bestCombo >= 3.5) res.push('è¿å‡»è¾¾äºº');
            if (highestSingleHit >= 60) res.push('è‡´å‘½ä¸€å‡»');
            if (remainingBirds >= Math.max(1, Math.floor(totalBirds*0.4))) res.push('èŠ‚çœå¼¹è¯');
            if (precisionMode && !precisionFail && targetsTotal>0 && targetsDestroyed===targetsTotal) res.push('ç²¾å‡†æ‹†é™¤');
            if (stats.shotsFired>=1 && stats.shotsHit===stats.shotsFired) res.push('å…¨ä¸­é«˜æ‰‹');
            if (weather==='rain') res.push('é›¨æˆ˜æ‰§è¡Œ');
            if (weather==='snow' || weather==='snow_fog') res.push('é›ªåœ°æŒæ§');
            if (weather==='fog' || weather==='snow_fog') res.push('èƒ½è§åº¦å‹åˆ¶');
            if (stats.explosions>=3) res.push('çˆ†ç ´ç‹‚äºº');
            if (score>=300) res.push('é«˜åˆ†ç©å®¶');
            return res;
        }

        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            const overlay = document.getElementById('overlay');
            overlay.style.display = 'none';
            if (currentLevel < levels.length) {
                currentLevel += 1;
                initGame(currentLevel);
                startLoop();
                restartBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'inline-block';
            } else {
                showLevelSelection();
            }
        });
        document.getElementById('watchReplayBtn').addEventListener('click', () => {
            playReplay();
        });
        document.getElementById('skipReplayBtn').addEventListener('click', () => {
            endReplay();
        });
        document.getElementById('settingsBtn').addEventListener('click', () => {
            document.getElementById('settingsPanel').style.display = 'flex';
            const cb = document.getElementById('settingBgm'); if (cb) cb.checked = !!settings.bgmEnabled;
            const vol = document.getElementById('settingBgmVolume'); const lab = document.getElementById('settingBgmVolumeLabel');
            if (vol) { const v = (typeof settings.bgmVolume==='number')?settings.bgmVolume:0.12; vol.value = v; if (lab) lab.textContent = v.toFixed(2); }
        });
        (function(){ const cb=document.getElementById('settingBgm'); const vol=document.getElementById('settingBgmVolume'); const lab=document.getElementById('settingBgmVolumeLabel'); if (cb) cb.addEventListener('change',()=>{ settings.bgmEnabled = !!cb.checked; saveSettings(); if (settings.bgmEnabled) startBGM(); }); if (vol) vol.addEventListener('input',()=>{ const v=parseFloat(vol.value||'0'); setBGMVolume(v); saveSettings(); if (lab) lab.textContent = v.toFixed(2); }); })();
        (function(){ const btn=document.getElementById('muteBtn'); const apply=()=>{ if(btn) btn.textContent = settings.muted? 'ğŸ”‡':'ğŸ”Š'; if (bgmEl) bgmEl.volume = safeVolume(); }; if(btn){ btn.addEventListener('click',()=>{ settings.muted=!settings.muted; saveSettings(); apply(); }); apply(); } })();
        document.getElementById('statsBtn').addEventListener('click', () => {
            document.getElementById('statsPanel').style.display = 'flex';
            document.getElementById('statsShots').textContent = stats.shotsFired;
            document.getElementById('statsHits').textContent = stats.shotsHit;
            const rate = stats.shotsFired ? Math.round((stats.shotsHit / stats.shotsFired) * 100) : 0;
            document.getElementById('statsHitRate').textContent = `${rate}%`;
            const avg = stats.shotsFired ? Math.round(score / stats.shotsFired) : 0;
            document.getElementById('statsAvgScore').textContent = avg;
            document.getElementById('statsExplosions').textContent = stats.explosions;
            document.getElementById('statsBestCombo').textContent = `${bestCombo.toFixed(2)}x`;
            const effText = `${targetsDestroyed}/${targetsTotal} (${targetsTotal?Math.round((targetsDestroyed/targetsTotal)*100):0}%)`;
            document.getElementById('statsTargetsEff').textContent = effText;
            const names = { red:'çº¢', blue:'è“', yellow:'é»„', black:'é»‘', white:'ç™½', orange:'æ©™', green:'ç»¿' };
            const abilityText = Object.keys(stats.abilities).map(k => `${names[k]||k}:${stats.abilities[k]}`).join('ï¼Œ');
            document.getElementById('statsAbilitiesList').textContent = abilityText || '--';
        });
        document.getElementById('skillsBtn').addEventListener('click', () => {
            document.getElementById('skillsPanel').style.display = 'flex';
            const list = Object.keys(skillDescriptions).map(k => `${typeNames[k]}ï¼š${skillDescriptions[k]}`).join('ï¼› ');
            document.getElementById('skillsList').textContent = list;
        });
        document.getElementById('statsCloseBtn').addEventListener('click', () => { document.getElementById('statsPanel').style.display = 'none'; });
        document.getElementById('settingsCloseBtn').addEventListener('click', () => { document.getElementById('settingsPanel').style.display = 'none'; });
        document.getElementById('skillsCloseBtn').addEventListener('click', () => { document.getElementById('skillsPanel').style.display = 'none'; });
        document.getElementById('restartLevelBtn').addEventListener('click', () => {
            const overlay = document.getElementById('overlay');
            overlay.style.display = 'none';
            initGame(currentLevel);
            startLoop();
            restartBtn.style.display = 'inline-block';
            pauseBtn.style.display = 'inline-block';
        });
        document.getElementById('backToSelectBtn').addEventListener('click', () => {
            const overlay = document.getElementById('overlay');
            overlay.style.display = 'none';
            showLevelSelection();
        });
        
        // æ˜¾ç¤ºå…³å¡é€‰æ‹©ç•Œé¢
        function showLevelSelection() {
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('levelSelection').style.display = 'block';
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('restartBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'none';
            try { startBGM(); } catch(e){}
            
            
            // æ›´æ–°å…³å¡æŒ‰é’®çŠ¶æ€
            const levelButtons = document.querySelectorAll('.level-btn');
            levelButtons.forEach((btn, index) => {
                btn.disabled = index + 1 > maxUnlockedLevel;
                btn.classList.toggle('locked', index + 1 > maxUnlockedLevel);
            });
            updateHUD();
            updateThemeFromStars();
            drawRoutePreview();
            drawWindPreview();
            drawMaterialLegend();
        }

        function resetDrag() {
            if (draggedBird && !draggedBird.launched) {
                draggedBird.x = slingshot.x;
                draggedBird.y = slingshot.y;
                draggedBird.radius = draggedBird.baseRadius || draggedBird.radius;
                draggedBird.dragging = false;
                draggedBird.dragPath = [];
            }
            draggedBird = null;
        }
        function launchPower(dist) {
            const m = 180;
            const base = 0.22; // Increased speed slightly as requested
            const f = Math.max(0, Math.min(1, dist / m));
            return base * (0.6 + 0.4 * f);
        }
        // é¼ æ ‡äº‹ä»¶å¤„ç†
        canvas.addEventListener('mousedown', (e) => {
            if (!gameRunning || (inputLocked() && !canDragDuringLock())) return;
            perf.inputEventTime = performance.now();
            const rect = canvas.getBoundingClientRect();
            const s = cameraScale || 1;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const screenX = (e.clientX - rect.left) * scaleX;
            const screenY = (e.clientY - rect.top) * scaleY;
            mouse.x = cameraX + (screenX - lastDrawShakeX) / s;
            mouse.y = cameraY + (screenY - lastDrawShakeY) / s;
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å¼¹å¼“ä¸­çš„å°é¸Ÿï¼ˆæ‰©å¤§å®¹é”™åŠå¾„ï¼‰
            const bird = birds.find(bird => 
                bird.inSlingshot && !bird.launched &&
                Math.hypot(mouse.x - bird.x, mouse.y - bird.y) <= Math.max(bird.radius, 80)
            );
            
            if (bird) {
                draggedBird = bird;
                draggedBird.dragging = true;
                draggedBird.radius = (draggedBird.baseRadius || draggedBird.radius) * 1.08;
                draggedBird.dragAlpha = 0.9;
                draggedBird.dragPath = [];
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (!gameRunning || !draggedBird || (inputLocked() && !canDragDuringLock())) return;
            perf.inputEventTime = performance.now();
            const rect = canvas.getBoundingClientRect();
            const s = cameraScale || 1;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const screenX = (e.clientX - rect.left) * scaleX;
            const screenY = (e.clientY - rect.top) * scaleY;
            mouse.x = cameraX + (screenX - lastDrawShakeX) / s;
            mouse.y = cameraY + (screenY - lastDrawShakeY) / s;
            
            // é™åˆ¶æ‹–åŠ¨èŒƒå›´ - åªèƒ½å¾€å·¦æ‹–æ‹½ï¼ˆæ„¤æ€’çš„å°é¸Ÿé£æ ¼ï¼‰
            const maxPull = 180;
            let dx = mouse.x - slingshot.x;
            let dy = mouse.y - slingshot.y;
            
            // é™åˆ¶åªèƒ½å‘å·¦æ‹–æ‹½
            if (dx > 0) dx = 0;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > maxPull) {
                const angle = Math.atan2(dy, dx);
                const tx = slingshot.x + Math.cos(angle) * maxPull;
                const ty = slingshot.y + Math.sin(angle) * maxPull;
                const k = 1;
                draggedBird.x = draggedBird.x + (tx - draggedBird.x) * k;
                draggedBird.y = draggedBird.y + (ty - draggedBird.y) * k;
            } else {
                const tx = slingshot.x + dx;
                const ty = slingshot.y + dy;
                const k = 1;
                draggedBird.x = draggedBird.x + (tx - draggedBird.x) * k;
                draggedBird.y = draggedBird.y + (ty - draggedBird.y) * k;
            }
            if (!draggedBird.dragPath) draggedBird.dragPath = [];
            draggedBird.dragPath.push({ x: draggedBird.x, y: draggedBird.y });
            if (draggedBird.dragPath.length > 24) draggedBird.dragPath.shift();
        });

        window.addEventListener('mouseup', () => {
            if (!gameRunning || !draggedBird || (inputLocked() && !canDragDuringLock())) return;
            perf.inputEventTime = performance.now();
            const minPull = 35;
            const distPull = Math.hypot(draggedBird.x - slingshot.x, draggedBird.y - slingshot.y);
            if (distPull < minPull) {
                resetDrag();
                return;
            }
            
            // å‘å°„å°é¸Ÿ
            const power = launchPower(distPull);
            draggedBird.velocity.x = (slingshot.x - draggedBird.x) * power;
            draggedBird.velocity.y = (slingshot.y - draggedBird.y) * power;
            draggedBird.launched = true;
            draggedBird.inSlingshot = false;
            draggedBird.dragging = false;
            draggedBird.radius = draggedBird.baseRadius || draggedBird.radius;
            draggedBird.dragPath = [];
            activeBird = draggedBird;
            lastLaunchTime = Date.now();
            bulletTimeFrames = 12;
            const spd = Math.hypot(activeBird.velocity.x, activeBird.velocity.y);
            const launchColors = { yellow:'#FF7043', black:'#F44336', blue:'#1E88E5', white:'#FDD835', orange:'#FFC107', green:'#4CAF50', red:'#FFD54F' };
            const lc = launchColors[activeBird.type] || '#FFD54F';
            {
                const dir = { x: activeBird.velocity.x, y: activeBird.velocity.y };
                // --- å¢å¼ºç‰ˆå‘å°„çˆ†ç‚¸ç‰¹æ•ˆ (Explosive Launch) ---
                spawnParticles(slingshot.x, slingshot.y, 40, lc, { style: 'streak', dir, life: 25, w: 4 });
                spawnParticles(slingshot.x, slingshot.y, 1, 'rgba(255,255,255,0.8)', { style: 'ring', life: 20, w: 20 });
                if (activeBird.type === 'black') {
                    spawnParticles(slingshot.x, slingshot.y, 20, '#333', { style: 'default', life: 45, w: 5 });
                } else if (activeBird.type === 'yellow') {
                    spawnParticles(slingshot.x, slingshot.y, 15, '#FFF', { style: 'streak', life: 30 });
                }
            }
            impactRings.push({ x: slingshot.x, y: slingshot.y, r: 0, maxR: 28 + Math.min(60, spd*0.8), alpha: 0.9 });
            if (typeof playLaunchSound === 'function') { playLaunchSound(Math.min(1, spd/18)); }
            shakeFrames = Math.max(shakeFrames, 6);
            slingJitterFrames = Math.max(slingJitterFrames, 8);
            supportPauseFrames = Math.max(supportPauseFrames, 120);
            draggedBird = null;
            stats.shotsFired++;
            
            remainingBirds--;
            updateHUD();
            
            // å»¶è¿Ÿåˆ›å»ºæ–°å°é¸Ÿï¼ˆå¦‚æœæœ‰å‰©ä½™å­å¼¹ï¼‰
            if (spawnNextBirdTimer) clearTimeout(spawnNextBirdTimer);
            spawnNextBirdTimer = setTimeout(() => {
                if (remainingBirds > 0) {
                    createBird();
                    updateHUD();
                }
                spawnNextBirdTimer = null;
            }, 1000);
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            resetDrag();
        });
        canvas.addEventListener('touchstart', (e) => {
            if (!gameRunning || (inputLocked() && !canDragDuringLock())) return;
            e.preventDefault();
            perf.inputEventTime = performance.now();
            const t = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const s = cameraScale || 1;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const screenX = (t.clientX - rect.left) * scaleX;
            const screenY = (t.clientY - rect.top) * scaleY;
            mouse.x = cameraX + (screenX - lastDrawShakeX) / s;
            mouse.y = cameraY + (screenY - lastDrawShakeY) / s;
            const bird = birds.find(b => b.inSlingshot && !b.launched && Math.hypot(mouse.x - b.x, mouse.y - b.y) <= Math.max(b.radius, 80));
            if (bird) {
                draggedBird = bird;
                draggedBird.dragging = true;
                draggedBird.radius = (draggedBird.baseRadius || draggedBird.radius) * 1.08;
                draggedBird.dragAlpha = 0.9;
                draggedBird.dragPath = [];
            }
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            if (!gameRunning || !draggedBird || (inputLocked() && !canDragDuringLock())) return;
            e.preventDefault();
            perf.inputEventTime = performance.now();
            const t = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const s = cameraScale || 1;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const screenX = (t.clientX - rect.left) * scaleX;
            const screenY = (t.clientY - rect.top) * scaleY;
            mouse.x = cameraX + (screenX - lastDrawShakeX) / s;
            mouse.y = cameraY + (screenY - lastDrawShakeY) / s;
            const maxPull = 180;
            let dx = mouse.x - slingshot.x;
            let dy = mouse.y - slingshot.y;
            if (dx > 0) dx = 0;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > maxPull) {
                const angle = Math.atan2(dy, dx);
                const tx = slingshot.x + Math.cos(angle) * maxPull;
                const ty = slingshot.y + Math.sin(angle) * maxPull;
                const k = 0.6;
                draggedBird.x = draggedBird.x + (tx - draggedBird.x) * k;
                draggedBird.y = draggedBird.y + (ty - draggedBird.y) * k;
            } else {
                const tx = slingshot.x + dx;
                const ty = slingshot.y + dy;
                const k = 0.6;
                draggedBird.x = draggedBird.x + (tx - draggedBird.x) * k;
                draggedBird.y = draggedBird.y + (ty - draggedBird.y) * k;
            }
            if (!draggedBird.dragPath) draggedBird.dragPath = [];
            draggedBird.dragPath.push({ x: draggedBird.x, y: draggedBird.y });
            if (draggedBird.dragPath.length > 24) draggedBird.dragPath.shift();
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => {
            if (!gameRunning || !draggedBird || (inputLocked() && !canDragDuringLock())) return;
            e.preventDefault();
            perf.inputEventTime = performance.now();
            const minPull = 12;
            const distPull = Math.hypot(draggedBird.x - slingshot.x, draggedBird.y - slingshot.y);
            if (distPull < minPull) {
                resetDrag();
                return;
            }
            const power = launchPower(distPull);
            draggedBird.velocity.x = (slingshot.x - draggedBird.x) * power;
            draggedBird.velocity.y = (slingshot.y - draggedBird.y) * power;
            draggedBird.launched = true;
            draggedBird.inSlingshot = false;
            draggedBird.dragging = false;
            draggedBird.radius = draggedBird.baseRadius || draggedBird.radius;
            draggedBird.dragPath = [];
            activeBird = draggedBird;
            lastLaunchTime = Date.now();
            bulletTimeFrames = 12;
            const spd2 = Math.hypot(activeBird.velocity.x, activeBird.velocity.y);
            const launchColors2 = { yellow:'#FF7043', black:'#F44336', blue:'#1E88E5', white:'#FDD835', orange:'#FFC107', green:'#4CAF50', red:'#FFD54F' };
            const lc2 = launchColors2[activeBird.type] || '#FFD54F';
            {
                const dir = { x: activeBird.velocity.x, y: activeBird.velocity.y };
                // --- å¢å¼ºç‰ˆå‘å°„çˆ†ç‚¸ç‰¹æ•ˆ (Explosive Launch) ---
                // 1. æ ¸å¿ƒçˆ†å‘
                spawnParticles(slingshot.x, slingshot.y, 40, lc2, { style: 'streak', dir, life: 25, w: 4 });
                // 2. æ‰©æ•£æ¿€æ³¢
                spawnParticles(slingshot.x, slingshot.y, 1, 'rgba(255,255,255,0.8)', { style: 'ring', life: 20, w: 20 });
                // 3. é¢å¤–çš„ç«èŠ±/çƒŸé›¾
                if (activeBird.type === 'black') {
                    spawnParticles(slingshot.x, slingshot.y, 20, '#333', { style: 'default', life: 45, w: 5 });
                } else if (activeBird.type === 'yellow') {
                    spawnParticles(slingshot.x, slingshot.y, 15, '#FFF', { style: 'streak', life: 30 });
                }
            }
            impactRings.push({ x: slingshot.x, y: slingshot.y, r: 0, maxR: 28 + Math.min(60, spd2*0.8), alpha: 0.9 });
            if (typeof playLaunchSound === 'function') { playLaunchSound(Math.min(1, spd2/18)); }
            shakeFrames = Math.max(shakeFrames, 6);
            slingJitterFrames = Math.max(slingJitterFrames, 8);
            supportPauseFrames = Math.max(supportPauseFrames, 120);
            draggedBird = null;
            stats.shotsFired++;
            remainingBirds--;
            updateHUD();
            if (spawnNextBirdTimer) clearTimeout(spawnNextBirdTimer);
            spawnNextBirdTimer = setTimeout(() => {
                if (remainingBirds > 0) {
                    createBird();
                    updateHUD();
                }
                spawnNextBirdTimer = null;
            }, 1000);
        }, { passive: false });
        canvas.addEventListener('touchcancel', () => { resetDrag(); }, { passive: false });
        window.addEventListener('blur', () => { if (draggedBird) resetDrag(); });

        function activateAbility() {
            if (inputLocked()) return;
            if (!activeBird || !activeBird.launched || activeBird.abilityUsed) return;
            if (Date.now() - lastLaunchTime < 60) return;
            const t = activeBird.type || 'red';
            if (t === 'blue') {
                const angles = [-0.35, 0, 0.35];
                angles.forEach(a => {
                    const cs = Math.cos(a), sn = Math.sin(a);
                    const speedBoost = 0.9;
                    let vx = (activeBird.velocity.x*cs - activeBird.velocity.y*sn) * speedBoost;
                    let vy = (activeBird.velocity.x*sn + activeBird.velocity.y*cs) * speedBoost;
                    const cur = Math.hypot(vx, vy);
                    const ymax = Math.hypot(activeBird.velocity.x, activeBird.velocity.y) * 2.1;
                    if (ymax > 0 && cur > ymax) { const f = ymax / cur; vx *= f; vy *= f; }
                    const nb = {
                        x: activeBird.x,
                        y: activeBird.y,
                        radius: Math.max(16, activeBird.radius * 0.85),
                        color: 'blue',
                        velocity: { x: vx, y: vy },
                        inSlingshot: false,
                        launched: true,
                        type: 'blue',
                        pierceFrames: 80,
                        abilityUsed: true,
                        bossHit: false
                    };
                    birds.push(nb);
                });
                activeBird.abilityUsed = true;
                stats.abilities['blue'] = (stats.abilities['blue']||0) + 1;
                
                // --- è“é¸ŸæŠ€èƒ½ç‰¹æ•ˆï¼šå¹»å½±åˆ†èº« (Phantom Split) ---
                playImpactSound(0.6);
                flashFrames = 4; flashColor = '#80DEEA'; // æŸ”å’Œé—ªå…‰
                // 1. å†°æ™¶çˆ†å‘
                spawnParticles(activeBird.x, activeBird.y, 8, '#80DEEA', { style: 'shard', life: 30, w: 6 });
                // 2. è™šå¹»å…‰æ™•
                spawnParticles(activeBird.x, activeBird.y, 1, 'rgba(128,222,234,0.7)', { style: 'ring', life: 20, w: 10, growth: 5 });
                // 3. ç¾½æ¯›æ•£è½
                spawnParticles(activeBird.x, activeBird.y, 5, 'rgba(255,255,255,0.8)', { style: 'feather', life: 40 });
            } else if (t === 'yellow') {
                activeBird.velocity.x *= 2.1;
                activeBird.velocity.y *= 2.1;
                activeBird.pierceFrames = 120;
                activeBird.abilityUsed = true;
                stats.abilities['yellow'] = (stats.abilities['yellow']||0) + 1;

                // --- é»„é¸ŸæŠ€èƒ½ç‰¹æ•ˆï¼šéŸ³çˆ†æ¿€æ³¢ (Sonic Boom) ---
                shakeFrames = 15;
                shakeIntensity = 12;
                flashFrames = 8; flashColor = '#FFEB3B'; // å¼ºé—ªå…‰
                bulletTimeFrames = 15; // å†²å‡»åœé¡¿
                playImpactSound(0.8);
                // 1. æ¿€æ³¢ç¯
                spawnParticles(activeBird.x, activeBird.y, 1, 'rgba(255,255,255,0.8)', { style: 'ring', life: 20, w: 15, growth: 8 });
                spawnParticles(activeBird.x, activeBird.y, 1, 'rgba(255,235,59,0.6)', { style: 'ring', life: 30, w: 30, growth: 4 });
                // 2. é—ªç”µçˆ†å‘
                for(let i=0; i<5; i++) {
                    spawnParticles(activeBird.x, activeBird.y, 1, '#FFEB3B', { style: 'lightning', life: 15, w: 4, len: 30 });
                }
                // 3. é€Ÿåº¦çº¿
                spawnParticles(activeBird.x, activeBird.y, 12, '#FFF', { style: 'streak', life: 20, w: 3 });

            } else if (t === 'black') {
                // --- é»‘é¸ŸæŠ€èƒ½ç‰¹æ•ˆï¼šæ¯ç­å‰å¥ (Doom Precursor) ---
                flashFrames = 12; flashColor = '#FFFFFF'; // æè‡´é—ªå…‰
                bulletTimeFrames = 30; // æ¯ç­åœé¡¿ (æ›´é•¿)
                // çˆ†ç‚¸å‰çš„ç¬é—´è§†è§‰æ”¶ç¼©
                spawnParticles(activeBird.x, activeBird.y, 1, 'rgba(0,0,0,0.8)', { style: 'ring', life: 10, w: 50, growth: -4 }); // Implosion ring
                
                explodeAt(activeBird.x, activeBird.y, 130);
                activeBird.dead = true;
                
                // çˆ†ç‚¸æ ¸å¿ƒè§†è§‰å¢å¼º
                spawnParticles(activeBird.x, activeBird.y, 30, '#FF6F00', { style: 'ring', life: 40, w: 8 });
                spawnParticles(activeBird.x, activeBird.y, 15, '#212121', { style: 'default', life: 60, w: 8 });
                spawnParticles(activeBird.x, activeBird.y, 8, '#FF5722', { style: 'spark', life: 45, len: 20 });
                spawnParticles(activeBird.x, activeBird.y, 5, '#000', { style: 'swirl', life: 50, rad: 60 }); // Dark vortex
                
                activeBird.abilityUsed = true;
                stats.abilities['black'] = (stats.abilities['black']||0) + 1;
                shakeFrames = 30; shakeIntensity = 20;

            } else if (t === 'white') {
                eggs.push({ x: activeBird.x, y: activeBird.y, vy: 3, radius: 12 });
                // å¢å¼ºï¼šä¸‹è›‹æ—¶çš„ç¾½æ¯›å’Œå…‰æ•ˆ
                spawnParticles(activeBird.x, activeBird.y, 8, '#FFF', { style: 'feather', life: 30 }); 
                spawnParticles(activeBird.x, activeBird.y, 5, '#FDD835', { style: 'ring', life: 20, w: 5 });

                eggs.push({ x: activeBird.x+8, y: activeBird.y-6, vy: 3.5, radius: 10 });
                eggs.push({ x: activeBird.x-8, y: activeBird.y-6, vy: 3.5, radius: 10 });
                activeBird.abilityUsed = true;
                stats.abilities['white'] = (stats.abilities['white']||0) + 1;
            } else if (t === 'orange') {
                activeBird.inflateFrames = 180;
                // å¢å¼ºï¼šè†¨èƒ€æ—¶çš„æ°”æµª
                spawnParticles(activeBird.x, activeBird.y, 15, '#FF9800', { style: 'swirl', life: 40, rad: 30 });
                spawnParticles(activeBird.x, activeBird.y, 1, '#FFC107', { style: 'ring', life: 15, w: 40, growth: 10 });
                shakeFrames = 8;

                activeBird.auraDamage = 0.3;
                activeBird.abilityUsed = true;
                stats.abilities['orange'] = (stats.abilities['orange']||0) + 1;
            } else if (t === 'green') {
                const q = fxQ;
                const vx = activeBird.velocity.x, vy = activeBird.velocity.y;
                const sp = Math.hypot(vx, vy) || 1; const boost = Math.max(20, Math.min(26, sp * 1.2));
                const nx = vx / sp, ny = vy / sp;
                activeBird.velocity.x = nx * boost;
                activeBird.velocity.y = ny * boost;
                activeBird.spinDriveFrames = 140;
                activeBird.pierceFrames = Math.max(activeBird.pierceFrames||0, 140);
                activeBird.auraDamage = Math.max(activeBird.auraDamage||0, 0.4);
                activeBird.bladeWidth = 40;
                activeBird.spinInfo = { cx: activeBird.x, cy: activeBird.y, ang: Math.atan2(activeBird.velocity.y, activeBird.velocity.x), ring: 0, rings: 5, baseR: 20, step: 34, lap: 0 };
                const candidates = pigs.filter(p=>p.health>0 && !p.isBoss);
                const picks = [];
                for (let k=0;k<Math.min(2, candidates.length); k++) { const i = Math.floor(Math.random()*candidates.length); picks.push(candidates.splice(i,1)[0]); }
                activeBird.huntTargets = picks;
                activeBird.huntActive = false;
                if (FX_OVERDRIVE && q >= 0.75) {
                    lensFrames = Math.max(lensFrames, 16);
                    lensColor = 'rgba(105,240,174,1)';
                    lensWorldX = activeBird.x;
                    lensWorldY = activeBird.y;
                }
                spawnParticles(activeBird.x, activeBird.y, Math.max(10, Math.round(16 + 22 * q)), '#4CAF50', { style: 'ring' });
                impactRings.push({ x: activeBird.x, y: activeBird.y, r: 0, maxR: 260, alpha: 0.9, growth: 1.05, decay: 0.010, rgb: '105,240,174', w: 3 });
                
                playImpactSound(0.7);
                flashFrames = Math.max(flashFrames, Math.round(4 + 8 * q));
                flashColor = '#B9F6CA';
                spawnParticles(activeBird.x, activeBird.y, Math.max(1, Math.round(2 + 4 * q)), '#69F0AE', { style: 'swirl', life: 34, rad: 34 + 24 * q, slow: true });
                spawnParticles(activeBird.x, activeBird.y, Math.max(3, Math.round(7 + 14 * q)), '#B9F6CA', { style: 'spark', life: 22, len: 16 });
                spawnParticles(activeBird.x, activeBird.y, Math.max(2, Math.round(5 + 10 * q)), 'rgba(105,240,174,0.6)', { style: 'streak', life: 26 });
                if (FX_OVERDRIVE && q >= 0.75) {
                    spawnParticles(activeBird.x, activeBird.y, 2, 'rgba(80,255,210,0.55)', { style: 'orbit_blade', cx: activeBird.x, cy: activeBird.y, rad: 28 + Math.random()*26, w: 26 + Math.random()*18, slow: true });
                    spawnParticles(activeBird.x, activeBird.y, 1, 'rgba(255,255,255,0.55)', { style: 'eclipse', life: 34, rad: activeBird.radius*0.9, len: activeBird.radius*(5.0 + Math.random()*2.8), alpha: 0.55, growth: 8 + Math.random()*4, spikes: 18 });
                }

                activeBird.abilityUsed = true;
                stats.abilities['green'] = (stats.abilities['green']||0) + 1;
            }
        }

        function explodeAt(x, y, r) {
            stats.explosions++;
            let affected = false;
            const er = activeBird && activeBird.blast ? r * 1.35 : r;
            explosions.push({ x, y, r: er, age: 0 });
            if (typeof playImpactSound === 'function') { playImpactSound(Math.min(1, er / 140)); }
            pigs.forEach((pig, index) => {
                const dx = pig.x - x;
                const dy = pig.y - y;
                if (Math.sqrt(dx*dx + dy*dy) <= er) {
                    if (!pig.escort) {
                        if (pig.isBoss) {
                            if (pig._lastDamageFrame === frameCounter || bossDamageLock > 0) { affected = true; }
                            else if (pig.bossShield && pig.bossShield > 0) {
                                spawnParticles(pig.x, pig.y, 40, 'rgba(0,0,0,0.95)', { style: 'amaterasu', life: 40, w: 6 });
                                spawnParticles(pig.x, pig.y, 10, '#FF0000', { style: 'shard', life: 30 });
                                affected = true;
                            } else if (!activeBird || !activeBird.bossHit) {
                                pig.health -= 1; pig.bossShield = 12; onBossDamaged(pig, 1); pig._lastDamageFrame = frameCounter; if (activeBird) activeBird.bossHit = true;
                                if (activeBird && activeBird.type === 'yellow') { bossDamageLock = Math.max(bossDamageLock, 8); }
                                if (pig.health <= 0) { onBossDeath(); pig.deathFrames = Math.max(pig.deathFrames||0, 90); pig._removeOnDeath = true; awardScore(50); }
                                affected = true;
                            } else {
                                affected = true;
                            }
                        } else {
                            pig.health = 0;
                            pigs.splice(index, 1);
                            awardScore(50);
                            // çŒªæ­»äº¡çˆ†ç‚¸å¢å¼º
                            spawnParticles(pig.x, pig.y, 60, '#4CAF50', { style: 'default', life: 40, w: 5 });
                            spawnParticles(pig.x, pig.y, 15, '#81C784', { style: 'ring', life: 25, w: 12 });
                            spawnParticles(pig.x, pig.y, 8, '#FFF', { style: 'shard', life: 30 });
                            affected = true;
                        }
                    } else {
                        pig.vx = (pig.vx || 0) + (Math.random()-0.5)*2;
                        pig.vy = (pig.vy || 0) - 2;
                    }
                }
            });
            blocks.forEach(block => {
                const dx = block.x - x;
                const dy = block.y - y;
                if (Math.sqrt(dx*dx + dy*dy) <= er) {
                    if (block.health > 0) {
                        block.health = 0;
                        block.fallen = true;
                        block.rotation = (Math.random() - 0.5) * Math.PI/2;
                        awardScore(10);
                        const pc = block.material === 'glass' ? '#BDE1FF' : block.material === 'metal' ? '#B0BEC5' : block.material === 'rubber' ? '#7E57C2' : block.material === 'ice' ? '#BDE1FF' : block.material === 'flammable' ? '#FF8F00' : '#A0522D';
                        const style = block.material === 'glass' ? 'streak' : block.material === 'metal' ? 'ring' : block.material === 'ice' ? 'shard' : block.material === 'flammable' ? 'streak' : (block.material === 'rubber' ? 'default' : 'streak');
                        // ç –å—ç ´ç¢çˆ†ç‚¸å¢å¼º
                        spawnParticles(block.x, block.y, 40, pc, { style, life: 35, w: 4 });
                        spawnParticles(block.x, block.y, 12, pc, { style: 'shard', life: 25 });
                        spawnParticles(block.x, block.y, 5, '#FFF', { style: 'ring', life: 15, w: 10 });
                        if (block.material === 'flammable') block.onFire = true;
                        if (block.material === 'glass') block.health = 0;
                        if (Math.random() < 0.2) spawnPickup(block.x, block.y);
                        if (block.material === 'barrel' && !block._exploded) { block._exploded = true; explodeAt(block.x, block.y, er*0.8); }
                        if (precisionMode && !block.isTarget) precisionFail = true;
                        if (precisionMode && block.isTarget) awardTargetBonus(8);
                        if (block.isTarget && !block._counted) { targetsDestroyed++; block._counted = true; completedTargets.push({ label: block.label || ('T'+targetsDestroyed), x: Math.round(block.x), y: Math.round(block.y), material: block.material }); }
                        affected = true;
                    }
                }
            });
            shakeFrames = 10;
            if (affected && activeBird) { activeBird.hasHit = true; activeBird.targetHit = true; }
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') activateAbility();
        });
        canvas.addEventListener('click', () => {
            activateAbility();
        });
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyD' && !replayMode && !inputLocked()) { cameraX += 60/(cameraScale||1); }
            if (e.code === 'KeyA' && !replayMode && !inputLocked()) { cameraX -= 60/(cameraScale||1); }
            if (e.code === 'KeyW' && !replayMode && !inputLocked()) { cameraY -= 60/(cameraScale||1); }
            if (e.code === 'KeyS' && !replayMode && !inputLocked()) { cameraY += 60/(cameraScale||1); }
            if (e.code === 'KeyT') { dailyMode = !dailyMode; initGame(currentLevel); }
            if (e.code === 'KeyF') { const p = document.getElementById('perfPanel'); if (p) { p.style.display = p.style.display==='none'?'block':'none'; } else { createPerfPanel(); } }
            
            if (e.code === 'Escape' && replayMode) { endReplay(); }
            if (e.code === 'Escape' && draggedBird && !draggedBird.launched) { resetDrag(); }
            if (['KeyW','KeyA','KeyS','KeyD'].includes(e.code) && !inputLocked()) { cameraUserFrames = 30; targetCameraX = cameraX; targetCameraY = cameraY; }
            clampCamera();
        });
        

        function gameStep() {
            if (!replayMode) {
                frameCounter++;
                if (bossDamageLock > 0) bossDamageLock--;
                if (timeSlowFrames && timeSlowFrames > 0 && (frameCounter % 2 === 1)) {
                    timeSlowFrames--;
                    draw();
                } else {
                    update();
                    draw();
                }
                const now = performance.now();
                if (perf.lastFrameTime) {
                    const dt = now - perf.lastFrameTime;
                    perf.frameTimes.push(dt);
                    if (perf.frameTimes.length > 60) perf.frameTimes.shift();
                    const avg = perf.frameTimes.reduce((a,b)=>a+b,0) / (perf.frameTimes.length||1);
                    perf.fps = Math.max(1, Math.min(120, 1000/avg));
                    if (dt > 18) perf.droppedFrames++;
                    if (perf.inputEventTime) perf.inputLatencyMs = Math.max(0, now - perf.inputEventTime);
                    const el = document.getElementById('perfPanelInfo'); if (el) el.textContent = `FPS ${Math.round(perf.fps)} | FX ${Math.round(getFxQuality()*100)}% | particles ${particles.length} | input ${Math.round(perf.inputLatencyMs)}ms | dropped ${perf.droppedFrames}`;
                }
                updateFxDyn();
                perf.lastFrameTime = now;
                if (recordReplay) {
                    const frame = snapshotFrame();
                    replayFrames.push(frame);
                    if (replayFrames.length > 1800) replayFrames.shift();
                }
            }
        }

        function createPerfPanel(){
            const panel = document.createElement('div');
            panel.id = 'perfPanel';
            panel.style.position = 'fixed';
            panel.style.top = '60px';
            panel.style.right = '10px';
            panel.style.background = 'rgba(0,0,0,0.55)';
            panel.style.color = '#fff';
            panel.style.padding = '8px 12px';
            panel.style.borderRadius = '8px';
            panel.style.zIndex = '1200';
            const info = document.createElement('div'); info.id='perfPanelInfo'; info.textContent='--'; panel.appendChild(info);
            document.body.appendChild(panel);
        }

        function snapshotFrame() {
            return {
                birds: birds.map(b => ({ x: b.x, y: b.y, r: b.radius, t: b.type, vx: b.velocity?.x || 0, vy: b.velocity?.y || 0, launched: !!b.launched })),
                pigs: pigs.map(p => ({ x: p.x, y: p.y, r: p.radius, h: p.health, b: !!p.isBoss, bt: p.bossType || null })),
                blocks: blocks.map(b => ({ x: b.x, y: b.y, w: b.width, h: b.height, rot: b.rotation || 0, fall: !!b.fallen, mat: b.material, hl: b.health })),
                explosions: explosions.map(e => ({ x: e.x, y: e.y, r: e.r, age: e.age })),
                floatScores: floatScores.map(fs => ({ x: fs.x, y: fs.y, text: fs.text, life: fs.life })),
                cameraScale,
                cameraX,
                cameraY
            };
        }

        function playReplay() {
            if (!replayFrames.length) return;
            const overlay = document.getElementById('overlay');
            overlay.style.display = 'none';
            const skipBtnTop = document.getElementById('skipReplayBtn');
            if (skipBtnTop) { skipBtnTop.style.display = 'none'; }
            replayMode = true;
            gameRunning = false;
            replayIndex = 0;
            let replaySpeed = 1;
            let updateRangeRef = null;
            replayLastTime = 0;
            const step = (timestamp) => {
                if (!replayLastTime) replayLastTime = timestamp;
                const delta = timestamp - replayLastTime;
                if (delta >= frameInterval) {
                    const f = replayFrames[replayIndex];
                    if (!f) { endReplay(); return; }
                    cameraScale = f.cameraScale || cameraScale;
                    cameraX = f.cameraX || 0;
                    cameraY = f.cameraY || 0;
                    birds = f.birds.map(b => ({ x: b.x, y: b.y, radius: b.r, type: b.t, color: 'red', velocity: { x: b.vx, y: b.vy }, launched: b.launched }));
                    pigs = f.pigs.map(p => ({ x: p.x, y: p.y, radius: p.r, color: 'green', health: p.h, isBoss: !!p.b, bossType: p.bt }));
                    blocks = f.blocks.map(b => ({ x: b.x, y: b.y, width: b.w, height: b.h, rotation: b.rot, fallen: b.fall, material: b.mat, color: '#8B4513', health: b.hl }));
                    explosions = f.explosions.map(e => ({ x: e.x, y: e.y, r: e.r, age: e.age }));
                    floatScores = f.floatScores.map(fs => ({ x: fs.x, y: fs.y, text: fs.text, life: fs.life }));
                    draw();
                    replayIndex += replaySpeed;
                    if (updateRangeRef) updateRangeRef();
                    replayLastTime = timestamp - (delta % frameInterval);
                }
                if (replayIndex < replayFrames.length) {
                    replayAniId = requestAnimationFrame(step);
                } else {
                    endReplay();
                }
            };
            const ctrl = document.createElement('div');
            ctrl.id = 'replayControls';
            ctrl.style.position = 'fixed';
            ctrl.style.bottom = '12px';
            ctrl.style.left = '50%';
            ctrl.style.transform = 'translateX(-50%)';
            ctrl.style.background = 'rgba(0,0,0,0.5)';
            ctrl.style.padding = '8px 12px';
            ctrl.style.borderRadius = '8px';
            ctrl.style.color = '#fff';
            ctrl.style.zIndex = '1100';
            const range = document.createElement('input');
            range.type = 'range'; range.min = '0'; range.max = String(Math.max(0, replayFrames.length - 1)); range.value = '0'; range.style.width = '360px';
            const b1 = document.createElement('button'); b1.textContent = 'x1'; b1.style.marginLeft = '8px';
            const b2 = document.createElement('button'); b2.textContent = 'x2'; b2.style.marginLeft = '4px';
            const skipInline = document.createElement('button'); skipInline.textContent = 'è·³è¿‡å›æ”¾'; skipInline.style.marginLeft = '8px';
            ctrl.appendChild(range); ctrl.appendChild(b1); ctrl.appendChild(b2); ctrl.appendChild(skipInline);
            document.body.appendChild(ctrl);
            b1.addEventListener('click', () => { replaySpeed = 1; });
            b2.addEventListener('click', () => { replaySpeed = 2; });
            skipInline.addEventListener('click', () => { endReplay(); });
            range.addEventListener('input', () => { replayIndex = Math.min(replayFrames.length - 1, Math.max(0, parseInt(range.value))); });
            const updateRange = () => { range.value = String(Math.min(replayFrames.length - 1, replayIndex)); };
            updateRangeRef = updateRange;
            replayAniId = requestAnimationFrame(step);
        }

        function endReplay() {
            replayMode = false;
            if (replayAniId) cancelAnimationFrame(replayAniId);
            const overlay = document.getElementById('overlay');
            overlay.style.display = 'flex';
            const ctrl = document.getElementById('replayControls');
            if (ctrl) ctrl.remove();
        }

        let loopGen = 0;
        function stopLoop() {
            gameRunning = false;
            loopLastTime = 0;
            loopGen++;
            if (animationId) cancelAnimationFrame(animationId);
            animationId = null;
        }

        function startLoop() {
            loopGen++;
            const myGen = loopGen;
            gameRunning = true;
            loopLastTime = 0;
            if (animationId) cancelAnimationFrame(animationId);
            const step = (timestamp) => {
                if (!gameRunning) return;
                if (myGen !== loopGen) return;
                if (!loopLastTime) loopLastTime = timestamp;
                const delta = timestamp - loopLastTime;
                if (delta >= frameInterval) {
                    gameStep();
                    loopLastTime = timestamp - (delta % frameInterval);
                }
                animationId = requestAnimationFrame(step);
            };
            animationId = requestAnimationFrame(step);
        }

        pauseBtn.addEventListener('click', () => {
            if (gameRunning) {
                stopLoop();
                pauseBtn.textContent = 'ç»§ç»­';
            } else {
                startLoop();
                pauseBtn.textContent = 'æš‚åœ';
            }
        });

        // å¼€å§‹æ¸¸æˆæŒ‰é’®
        startBtn.addEventListener('click', () => {
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('levelSelection').style.display = 'none';
            initGame(currentLevel);
            startLoop();
            try { if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){}
            pauseBtn.style.display = 'inline-block';
            restartBtn.style.display = 'inline-block';
            settingsBtn.style.display = 'inline-block';
            statsBtn.style.display = 'inline-block';
            skillsBtn.style.display = 'inline-block';
        });
        document.getElementById('dailyChallengeBtn').addEventListener('click', () => {
            dailyMode = true;
            currentLevel = 5;
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('levelSelection').style.display = 'none';
            initGame(currentLevel);
            startLoop();
            pauseBtn.style.display = 'inline-block';
            settingsBtn.style.display = 'inline-block';
            statsBtn.style.display = 'inline-block';
            skillsBtn.style.display = 'inline-block';
        });
        
        // å…³å¡é€‰æ‹©æŒ‰é’®äº‹ä»¶
        document.querySelectorAll('.level-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                currentLevel = parseInt(this.dataset.level);
                document.getElementById('gameCanvas').style.display = 'block';
                document.getElementById('levelSelection').style.display = 'none';
                initGame(currentLevel);
                startLoop();
                pauseBtn.style.display = 'inline-block';
                settingsBtn.style.display = 'inline-block';
                statsBtn.style.display = 'inline-block';
                skillsBtn.style.display = 'inline-block';
            });
        });
        
        // åˆå§‹æ˜¾ç¤ºå…³å¡é€‰æ‹©ç•Œé¢
        showLevelSelection();

        // é‡æ–°å¼€å§‹æŒ‰é’®
        restartBtn.addEventListener('click', () => {
            initGame(currentLevel);
            startLoop();
            restartBtn.style.display = 'inline-block';
            pauseBtn.style.display = 'inline-block';
            statsBtn.style.display = 'inline-block';
            skillsBtn.style.display = 'inline-block';
        });

        // é€‰æ‹©ç•Œé¢ç‚¹å‡»é¢„è§ˆäº¤äº’
        const windPrev = document.getElementById('windPreview');
        if (windPrev) {
            windPrev.addEventListener('click', () => {
                dailyMode = !dailyMode;
                currentLevel = 5;
                document.getElementById('gameCanvas').style.display = 'block';
                document.getElementById('levelSelection').style.display = 'none';
                initGame(currentLevel);
                startLoop();
                pauseBtn.style.display = 'inline-block';
                restartBtn.style.display = 'inline-block';
            });
        }
        const routePrev = document.getElementById('routePreview');
        if (routePrev) {
            routePrev.addEventListener('click', (e) => {
                const rect = routePrev.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const third = rect.width / 3;
                let lane = mx < third ? 0 : mx < third*2 ? 1 : 2;
                document.getElementById('gameCanvas').style.display = 'block';
                document.getElementById('levelSelection').style.display = 'none';
                currentLevel = 5;
                initGame(currentLevel);
                startLoop();
                pauseBtn.style.display = 'inline-block'; restartBtn.style.display = 'inline-block';
                const s = cameraScale || 1;
                const bands = [100, canvas.width/2, canvas.width - 260];
                const cx = bands[Math.max(0, Math.min(2, lane))];
                targetCameraX = Math.max(0, cx - canvas.width/(2*s));
                targetCameraY = 0;
                cameraX = targetCameraX; cameraY = targetCameraY; cameraUserFrames = 90;
                clampCamera();
            });
        }
        const matLegend = document.getElementById('materialLegend');
        if (matLegend) {
            matLegend.addEventListener('click', (e) => {
                const rect = matLegend.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const idx = Math.floor((mx - 8) / 56);
                const keys = ['wood','glass','metal','rubber','flammable','barrel','ice'];
                const k = keys[Math.max(0, Math.min(keys.length-1, idx))];
                if (!gameRunning) {
                    currentLevel = 5; initGame(currentLevel); startLoop(); pauseBtn.style.display='inline-block'; restartBtn.style.display='inline-block';
                }
                const target = blocks.find(b => b.material === k);
                if (target) {
                    const s = cameraScale || 1;
                    targetCameraX = Math.max(0, target.x - canvas.width/(2*s));
                    targetCameraY = Math.max(0, target.y - canvas.height/(2*s));
                    cameraX = targetCameraX; cameraY = targetCameraY; cameraUserFrames = 90; clampCamera();
                }
            });
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
            clampCamera();
        });

        // åˆå§‹ç»˜åˆ¶
        draw();
        const statsPanel = document.getElementById('statsPanel');
        const statsShotsEl = document.getElementById('statsShots');
        const statsHitsEl = document.getElementById('statsHits');
        const statsHitRateEl = document.getElementById('statsHitRate');
        const statsAvgScoreEl = document.getElementById('statsAvgScore');
        const statsTargetsEffEl = document.getElementById('statsTargetsEff');
        const statsAbilitiesListEl = document.getElementById('statsAbilitiesList');
        const statsExplosionsEl = document.getElementById('statsExplosions');
        const statsBestComboEl = document.getElementById('statsBestCombo');
        const statsCloseBtn = document.getElementById('statsCloseBtn');
        const skillsPanel = document.getElementById('skillsPanel');
        const skillsListEl = document.getElementById('skillsList');
        const skillsCloseBtn = document.getElementById('skillsCloseBtn');
        function computeAchievements() {
            const list = [];
            const rate = stats.shotsFired ? (stats.shotsHit / stats.shotsFired) : 0;
            const eff = targetsTotal ? (targetsDestroyed / targetsTotal) : 0;
            if (rate >= 0.8) list.push('ç¨³å‡†ç‹ ');
            if (remainingBirds >= Math.ceil(totalBirds/2)) list.push('èŠ‚çº¦å¼¹è¯');
            if (precisionMode && targetsDestroyed === targetsTotal && !precisionFail) list.push('ç²¾å‡†å¤§å¸ˆ');
            if (bestCombo >= 3) list.push('è¿å‡»è¾¾äºº');
            if (stats.explosions >= 3) list.push('çˆ†ç ´ä¸“å®¶');
            if ((stats.abilities['yellow']||0) >= 2) list.push('æé€Ÿé»„é¸Ÿ');
            if ((stats.abilities['blue']||0) >= 2) list.push('åˆ†è£‚æˆ˜æœ¯');
            if (eff >= 1) list.push('ç›®æ ‡æ¸…é™¤');
            const avg = stats.shotsFired ? (score / stats.shotsFired) : 0;
            if (avg >= 60) list.push('é«˜æ•ˆè¾“å‡º');
            return list;
        }
        function openStats() {
            statsShotsEl.textContent = stats.shotsFired;
            statsHitsEl.textContent = stats.shotsHit;
            const rate = stats.shotsFired ? (stats.shotsHit / stats.shotsFired) : 0;
            statsHitRateEl.textContent = `${Math.round(rate*100)}%`;
            const avg = stats.shotsFired ? Math.round(score / stats.shotsFired) : 0;
            statsAvgScoreEl.textContent = avg;
            const pct = targetsTotal ? Math.round((targetsDestroyed / targetsTotal) * 100) : 0;
            statsTargetsEffEl.textContent = `${targetsDestroyed}/${targetsTotal} (${pct}%)`;
            const names = { red:'çº¢', blue:'è“', yellow:'é»„', black:'é»‘', white:'ç™½', orange:'æ©™', green:'ç»¿' };
            const abilityText = Object.keys(stats.abilities).map(k => `${names[k]||k}:${stats.abilities[k]}`).join('ï¼Œ');
            statsAbilitiesListEl.textContent = abilityText || '--';
            statsExplosionsEl.textContent = stats.explosions;
            statsBestComboEl.textContent = `${bestCombo.toFixed(2)}x`;
            const ach = computeAchievements();
            const achText = ach.length ? ach.join('ï¼Œ') : '--';
            document.getElementById('statsAchievementsList').textContent = achText;
            const info = document.getElementById('statsPerf');
            if (info) { info.textContent = `FPS:${Math.round(perf.fps)} | è¾“å…¥å»¶è¿Ÿ:${Math.round(perf.inputLatencyMs)}ms | ä¸¢å¸§:${perf.droppedFrames}`; }
            statsPanel.style.display = 'flex';
        }

        (function(){ if (!document.getElementById('perfPanel')) createPerfPanel(); })();
        function closeStats(){ statsPanel.style.display = 'none'; }
        statsBtn.addEventListener('click', () => { openStats(); });
        statsCloseBtn.addEventListener('click', () => { closeStats(); });
        (function(){
            const el = document.getElementById('statsPanel');
            if (el) {
                const perfRow = document.createElement('div');
                perfRow.id = 'statsPerf';
                perfRow.style.marginTop = '8px';
                perfRow.style.color = '#1976D2';
                el.querySelector('.overlay-content')?.appendChild(perfRow);
            }
        })();
        function openSkills(){
            const desc = {
                red:'åŸºç¡€å¼¹è¯ï¼Œæ— ä¸»åŠ¨æŠ€èƒ½',
                blue:'åˆ†è£‚æˆå¤šæšï¼Œè¦†ç›–èŒƒå›´',
                yellow:'åŠ é€Ÿè´¯ç©¿ï¼Œç©¿é€æ …æ ç±»',
                black:'çˆ†ç‚¸ï¼ŒèŒƒå›´ç ´å',
                white:'ä¸‹è›‹ï¼Œè§¦åœ°çˆ†ç ´',
                orange:'è†¨èƒ€å¹¶äº§ç”Ÿå…‰ç¯ä¼¤å®³',
                green:'æ—‹è½¬åè¿½è¸ªï¼šéšæœºå¤„å†³2åªï¼ˆBosså…ç–«ï¼‰ï¼ŒæŠ€èƒ½æœŸé—´æ— æ•Œ'
            };
            const types = Array.from(new Set(birdQueue));
            const names = { red:'çº¢', blue:'è“', yellow:'é»„', black:'é»‘', white:'ç™½', orange:'æ©™', green:'ç»¿' };
            const html = types.map(t => `<div><strong>${names[t]||t}</strong>ï¼š${desc[t]||'æœªçŸ¥'}</div>`).join('');
            skillsListEl.innerHTML = html || '--';
            skillsPanel.style.display = 'flex';
        }
        function closeSkills(){ skillsPanel.style.display = 'none'; }
        skillsBtn.addEventListener('click', () => { openSkills(); });
        skillsCloseBtn.addEventListener('click', () => { closeSkills(); });
    </script>
</body>
</html>
